// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)

/**
 * Main function giving a function stack trace with a forced or passed in Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
 * @return {Array} of Strings with functions, lines, files, and arguments where possible
 */
function printStackTrace(options) {
    options = options || {guess: true};
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    var res = (guess) ? p.guessAnonymousFunctions(result) : result;
	for (var k = 0; k < 4; k++) {
		res.shift();
	}
	return res;
}

printStackTrace.implementation = function() {
};

printStackTrace.implementation.prototype = {
    run: function(ex) {
        ex = ex || this.createException();
        // Do not use the stored mode: different exceptions in Chrome
        // may or may not have arguments or stack
        var mode = this.mode(ex);
        // Use either the stored mode, or resolve it
        //var mode = this._mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException: function() {
        try {
            this.undef();
            return null;
        } catch (e) {
            return e;
        }
    },

    /**
     * @return {String} mode of operation for the environment in question.
     */
    mode: function(e) {
        if (e['arguments'] && e.stack) {
            return (this._mode = 'chrome');
        } else if (e.message && typeof window !== 'undefined' && window.opera) {
            return (this._mode = e.stacktrace ? 'opera10' : 'opera');
        } else if (e.stack) {
            return (this._mode = 'firefox');
        }
        return (this._mode = 'other');
    },

    /**
     * Given a context, function name, and callback function, overwrite it so that it calls
     * printStackTrace() first with a callback and then runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction: function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction: function(context, functionName) {
        if (context[functionName].constructor === Function &&
                context[functionName]._instrumented &&
                context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome: function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').
          replace(/^\s+at\s+/gm, '').
          replace(/^([^\(]+?)([\n$])/gm, '{anonymous}()@$1$2').
          replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox: function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10: function(e) {
        var stack = e.stacktrace;
        var lines = stack.split('\n'), ANON = '{anonymous}', lineRE = /.*line (\d+), column (\d+) in ((<anonymous function\:?\s*(\S+))|([^\(]+)\([^\)]*\))(?: in )?(.*)\s*$/i, i, j, len;
        for (i = 2, j = 0, len = lines.length; i < len - 2; i++) {
            if (lineRE.test(lines[i])) {
                var location = RegExp.$6 + ':' + RegExp.$1 + ':' + RegExp.$2;
                var fnName = RegExp.$3;
                fnName = fnName.replace(/<anonymous function\:?\s?(\S+)?>/g, ANON);
                lines[j++] = fnName + '@' + location;
            }
        }

        lines.splice(j, lines.length - j);
        return lines;
    },

    // Opera 7.x-9.x only!
    opera: function(e) {
        var lines = e.message.split('\n'), ANON = '{anonymous}', lineRE = /Line\s+(\d+).*script\s+(http\S+)(?:.*in\s+function\s+(\S+))?/i, i, j, len;

        for (i = 4, j = 0, len = lines.length; i < len; i += 2) {
            //TODO: RegExp.exec() would probably be cleaner here
            if (lineRE.test(lines[i])) {
                lines[j++] = (RegExp.$3 ? RegExp.$3 + '()@' + RegExp.$2 + RegExp.$1 : ANON + '()@' + RegExp.$2 + ':' + RegExp.$1) + ' -- ' + lines[i + 1].replace(/^\s+/, '');
            }
        }

        lines.splice(j, lines.length - j);
        return lines;
    },

    // Safari, IE, and others
    other: function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for non-string types.
     *
     * @param {Arguments} object
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments: function(args) {
        var slice = Array.prototype.slice;
        for (var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                args[i] = 'undefined';
            } else if (arg === null) {
                args[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        args[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        args[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    args[i] = '#object';
                } else if (arg.constructor === Function) {
                    args[i] = '#function';
                } else if (arg.constructor === String) {
                    args[i] = '"' + arg + '"';
                }
            }
        }
        return args.join(',');
    },

    sourceCache: {},

    /**
     * @return {*} the text from a given URL.
     */
    ajax: function(url) {
        var req = this.createXMLHTTPObject();
        if (!req) {
            return;
        }
        req.open('GET', url, false);
        //req.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
        req.send('');
        return req.responseText;
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject: function() {
        var xmlhttp, XMLHttpFactories = [
            function() {
                return new XMLHttpRequest();
            }, function() {
                return new ActiveXObject('Msxml2.XMLHTTP');
            }, function() {
                return new ActiveXObject('Msxml3.XMLHTTP');
            }, function() {
                return new ActiveXObject('Microsoft.XMLHTTP');
            }
        ];
        for (var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the source
     * via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain: function(url) {
        return url.indexOf(location.hostname) !== -1;
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource: function(url) {
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions: function(stack) {
        for (var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(\w+:\/\/([\-\w\.]+)+(:\d+)?[^:]+):(\d+):?(\d+)?/;
            var frame = stack[i], m = reStack.exec(frame);
            if (m) {
                var file = m[1], lineno = m[4], charno = m[7] || 0; //m[7] is character position in Chrome
                if (file && this.isSameDomain(file) && lineno) {
                    var functionName = this.guessAnonymousFunction(file, lineno, charno);
                    stack[i] = frame.replace('{anonymous}', functionName);
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction: function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName: function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = 10, m;
        for (var i = 0; i < maxLines; ++i) {
            // FIXME lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i];
            if (line) {
                code = line + code;

                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};;/************************/
/* Isogenic Game Engine */
/************************/
ige = null;

// When setting a new version please use this format:
// v{MAJOR}.{MINOR}.{SUB}@{YYYY-MM-DD}.{REVISION}
//
// For example, to tag version 1.1.2 on 25th April 2013
// as the third revision of the day:
// v1.1.2@2013-04-25.003
igeVersion = 'v1.5.5@2014-03-23.001';

// Define the global storage object for classes
igeClassStore = {};

igeConfig = {
	debug: {
		_enabled: true,
		_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
		_level: ['log', 'warning', 'error'],
		_stacks: true,
		_throwErrors: true,
		_timing: true,
		enabled: function (val) {
			if (val !== undefined) {
				this._enabled = val;
	
				if (!val) {
					this._timing = false;
	
					// Check if the engine exists
					if (ige) {
						// Turn off stats display in the engine
						ige.showStats(0);
					}
				}
	
				return this;
			}
	
			return this._enabled;
		}
	}
};

if (igeConfig.debug._node) {
	igeConfig.debug._util = require('util');
}

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Object.prototype, 'tween', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Augments all objects with the tween() method. Creates a new IgeTween
 * with the passed parameters that will act upon the object's properties.
 * The returned tween will not start tweening until a call to start() is
 * made.
 * @param {Object} props
 * @param {Number} durationMs
 * @param {Object=} options
 * @return {IgeTween}
 */
Object.prototype.tween = function (props, durationMs, options) {
	var newTween = new IgeTween()
		.targetObj(this)
		.properties(props)
		.duration(durationMs);

	if (options) {
		if (options.beforeTween) { newTween.beforeTween(options.beforeTween); }
		if (options.afterTween) { newTween.afterTween(options.afterTween); }
		if (options.easing) { newTween.easing(options.easing); }
		if (options.startTime) { newTween.startTime(options.startTime); }
	}

	return newTween;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Object.prototype, 'theSameAs', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Augments all objects with the theSameAs() method. Checks if the
 * property values of this object are equal to the property values
 * of the passed object. If they are the same then this method will
 * return true. Objects must not contain circular references!
 * @param {Object} obj The object to compare this one to.
 * @return {Boolean}
 */
Object.prototype.theSameAs = function (obj) {
	return JSON.stringify(this) === JSON.stringify(obj);
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'clone', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Clones the array and returns a new non-referenced
 * array.
 * @return {*}
 */
Array.prototype.clone = function () {
	var i, newArray = [];
	for (i in this) {
		if (this.hasOwnProperty(i)) {
			if (this[i] instanceof Array) {
				newArray[i] = this[i].clone();
			} else {
				newArray[i] = this[i];
			}
		}
	}

	return newArray;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'pull', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Removes the passed item from an array, the opposite of push().
 * @param item
 * @return {*}
 */
Array.prototype.pull = function (item) {
	var index = this.indexOf(item);
	if (index > -1) {
		this.splice(index, 1);
		return index;
	} else {
		return -1;
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'pushUnique', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Adds an item to an array, only if it does not already exist in the array.
 * @param item
 * @return {Boolean} True if the item was added, false if it already exists.
 */
Array.prototype.pushUnique = function (item) {
	var index = this.indexOf(item);
	if (index === -1) {
		this.push(item);
		return true;
	}
	
	return false;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'each', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one.
 * @param {Function} callback
 */
Array.prototype.each = function (callback) {
	var len = this.length,
		i;

	for (i = 0; i < len; i++) {
		callback(this[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'eachReverse', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one in reverse order.
 * @param {Function} callback
 */
Array.prototype.eachReverse = function (callback) {
	var arrCount = this.length,
		i;

	for (i = arrCount - 1; i >= 0; i--) {
		callback(this[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'destroyAll', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls each item's
 * destroy() method if it exists. Useful for destroying an
 * array of IgeEntity instances.
 */
Array.prototype.destroyAll = function () {
	var arrCount = this.length,
		i;

	for (i = arrCount - 1; i >= 0; i--) {
		if (typeof(this[i].destroy) === 'function') {
			this[i].destroy();
		}
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'eachIsolated', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one. Altering the array's structure
 * during the callback method will not affect the iteration of the
 * items.
 *
 * @param {Function} callback
 */
Array.prototype.eachIsolated = function (callback) {
	var arr = [],
		arrCount = arr.length,
		i;

	// Create a copy of the array
	for (i = 0; i < arrCount; i++) {
		arr[i] = this[i];
	}

	// Now iterate the array, passing the copied
	// array value at the index(i). Any changes to
	// "this" will not affect the index(i) values.
	for (i = 0; i < arrCount; i++) {
		callback(arr[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'PI180', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Stores a pre-calculated PI / 180 value.
 * @type {Number}
 */
Math.PI180 = Math.PI / 180;

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'PI180R', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Stores a pre-calculated 180 / PI value.
 * @type {Number}
 */
Math.PI180R = 180 / Math.PI;

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'toIso', {
	enumerable:false,
	writable:true,
	configurable:true
});

Math.toIso = function (x, y, z) {
	var sx = x - y,
		sy = (-z) * 1.2247 + (x + y) * 0.5;

	return {x: sx, y: sy};
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'radians', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Converts degrees to radians.
 * @param {Number} degrees
 * @return {Number} radians
 */
Math.radians = function (degrees) {
	return degrees * Math.PI180;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'degrees', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Converts radians to degrees.
 * @param {Number} radians
 * @return {Number} degrees
 */
Math.degrees = function (radians) {
	return radians * Math.PI180R;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'distance', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Calculates the distance from the first point to the second point.
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @return {Number}
 */
Math.distance = function (x1, y1, x2, y2) {
	return Math.sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
};

if (typeof(CanvasRenderingContext2D) !== 'undefined') {
	// Extend the canvas context to add some helper methods
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(CanvasRenderingContext2D.prototype, 'circle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	Object.defineProperty(CanvasRenderingContext2D.prototype, 'strokeCircle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	Object.defineProperty(CanvasRenderingContext2D.prototype, 'fillCircle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	CanvasRenderingContext2D.prototype.circle = function (x, y, radius) {
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
	};

	CanvasRenderingContext2D.prototype.strokeCircle = function (x, y, radius) {
		this.save();
		this.beginPath();
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
		this.stroke();
		this.restore();
	};

	CanvasRenderingContext2D.prototype.fillCircle = function (x, y, radius) {
		this.save();
		this.beginPath();
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
		this.fill();
		this.restore();
	};
}

if (typeof(ImageData) !== 'undefined') {
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'pixelAt', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * pixelAt() method. Gets the pixel color data for the given pixel at the
	 * x, y co-ordinates specified.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 * @return {Object} An object containing the pixel color data in properties
	 * {r, g, b, a}.
	 */
	ImageData.prototype.pixelAt = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		return {
			r: data[pixelStart],
			g: data[pixelStart + 1],
			b: data[pixelStart + 2],
			a: data[pixelStart + 3]
		};
	};

	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'isTransparent', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * isTransparent() method. Determines if the pixel at the passed x, y is
	 * fully transparent or not.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 * @return {Boolean} True if fully transparent, false if not.
	 */
	ImageData.prototype.isTransparent = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		return data[pixelStart + 3] === 0;
	};

	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'makeTransparent', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * makeTransparent() method. Makes the pixel at the passed x, y fully
	 * transparent.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 */
	ImageData.prototype.makeTransparent = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		data[pixelStart + 3] = 0;
	};
}

/**
 * Turn off the right-click default behaviour in the browser for the passed element.
 * @param obj
 */
var disableContextMenu = function (obj) {
	if (obj !== null) {
		//this.log('Disabling context menus for ' + obj, 'info');
		obj.oncontextmenu = function () { return false; };
	}
};

/**
 * Adds the indexOf method to all array objects if it does not already exist which
 * would you believe can still happen even in 2012!
 */
if(!Array.prototype.indexOf){
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'indexOf', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Get the index of the passed item.
	 * @param {*} obj The item to find the index for.
	 * @return {Number} The index of the passed item or -1 if not found.
	 */
	Array.prototype.indexOf = function(obj) {
		var i, l = this.length;
		for (i = 0; i < l; i++) {
			if(this[i] === obj){
				return i;
			}
		}
		return -1;
	};
}

if (typeof(window) !== 'undefined') {
	/**
	 * A cross-browser/platform requestAnimationFrame method.
	 */
	/*window.requestAnimFrame = (function(){
		return function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());*/

	requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
		function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());
} else {
	/**
	 * A cross-browser/platform requestAnimationFrame method.
	 */
	requestAnimFrame = (function(){
		return function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());
}

// Check console method existence
if (typeof(console) === 'object') {
	if (typeof(console.log) === 'function') {
		if (typeof(console.info) === 'undefined') {
			// We have console.log but not console.info so add it as a replica of console.log
			console.info = console.log;
		}

		if (typeof(console.warn) === 'undefined') {
			// We have console.log but not console.warn so add it as a replica of console.log
			console.warn = console.log;
		}
	}
} else {
	// Create dummy console
	console = {
		log: function () {},
		warn: function () {},
		info: function () {},
		error: function () {}
	};
};/**
 * The base class system.
 */
var IgeClass = (function () {
	var initializing = false,
		fnTest = /xyz/.test(function () {xyz;}) ? /\b_super\b/ : /.*/,

		// The base Class implementation (does nothing)
		IgeClass = function () {},
		
		/**
		 * Provides logging capabilities to all IgeClass instances.
		 * @param {String} text The text to log.
		 * @param {String} type The type of log to output, can be 'log',
		 * 'info', 'warning' or 'error'.
		 * @param {Object=} obj An optional object that will be output
		 * before the log text is output.
		 * @example #Log a message
		 *     var entity = new IgeEntity();
		 *     
		 *     // Will output:
		 *     //     IGE *log* [IgeEntity] : hello
		 *     entity.log('Hello');
		 * @example #Log an info message with an optional parameter
		 *     var entity = new IgeEntity(),
		 *         param = 'moo';
		 *	
		 *     // Will output:
		 *     //    moo
		 *     //    IGE *log* [IgeEntity] : hello
		 *     entity.log('Hello', 'info', param);
		 * @example #Log a warning message (which will cause a stack trace to be shown)
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output (stack trace is just an example here, real one will be more useful):
		 *     //    Stack: {anonymous}()@<anonymous>:2:8
		 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
		 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
		 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
		 *     //    IGE *warning* [IgeEntity] : A test warning
		 *     entity.log('A test warning', 'warning');
		 * @example #Log an error message (which will cause an exception to be raised and a stack trace to be shown)
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output (stack trace is just an example here, real one will be more useful):
		 *     //    Stack: {anonymous}()@<anonymous>:2:8
		 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
		 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
		 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
		 *     //    IGE *error* [IgeEntity] : An error message
		 *     entity.log('An error message', 'error');
		 */
		log = function (text, type, obj) {
			if (igeConfig.debug._enabled) {
				var indent = '',
					stack,
					thisId;
				
				if (typeof(this._id) !== 'undefined') {
					thisId = ':' + this._id;
				} else {
					thisId = '';
				}

				type = type || 'log';

				if (obj !== undefined) {
					console.warn(obj);
				}

				if (type === 'warning' || type === 'error') {
					if (igeConfig.debug._stacks) {
						if (igeConfig.debug._node) {
							if (console.trace) {
								console.trace();
							} else {
								stack = new Error().stack;
								//console.log(color.magenta('Stack:'), color.red(stack));
								console.log('Stack:', stack);
							}
						} else {
							if (typeof(printStackTrace) === 'function') {
								console.log('Stack:', printStackTrace().join('\n ---- '));
							}
						}
					}
				}

				if (type === 'error') {
					if (typeof(ige) !== 'undefined') {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + 'Error encountered, stopping engine to prevent console spamming...');
						ige.stop();
					}
					
					if (igeConfig.debug._throwErrors) {
						throw(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
					} else {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
					}
				} else {
					console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
				}
			}

			return this;
		},

		/**
		 * Returns the class id. Primarily used to help identify
		 * what class an instance was instantiated with and is also
		 * output during the ige.scenegraph() method's console logging
		 * to show what class an object belongs to.
		 * @example #Get the class id of an object
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output "IgeEntity"
		 *     console.log(entity.classId());
		 */
		classId = function () {
			return this._classId;
		},

		/**
		 * Creates a new instance of the component argument passing
		 * the options argument to the component as it is initialised.
		 * The new component instance is then added to "this" via
		 * a property name that is defined in the component class as
		 * "componentId".
		 * @param {IgeClass} component The class definition of the component.
		 * @param {Object=} options An options parameter to pass to the component
		 * on init.
		 * @example #Add the velocity component to an entity
		 *     var entity = new IgeEntity();
		 *     entity.addComponent(IgeVelocityComponent);
		 *     
		 *     // Now that the component is added, we can access
		 *     // the component via it's namespace. Call the 
		 *     // "byAngleAndPower" method of the velocity component:
		 *     entity.velocity.byAngleAndPower(Math.radians(20), 0.1);
		 */
		addComponent = function (component, options) {
			var newComponent = new component(this, options);
			this[newComponent.componentId] = newComponent;

			// Add the component reference to the class component array
			this._components = this._components || [];
			this._components.push(newComponent);

			return this;
		},

		/**
		 * Removes a component by it's id.
		 * @param {String} componentId The id of the component to remove.
		 * @example #Remove a component by it's id (namespace)
		 *     var entity = new IgeEntity();
		 *     
		 *     // Let's add the velocity component
		 *     entity.addComponent(IgeVelocityComponent);
		 *	
		 *     // Now that the component is added, let's remove
		 *     // it via it's id ("velocity")
		 *     entity.removeComponent('velocity');
		 */
		removeComponent = function (componentId) {
			// If the component has a destroy method, call it
			if (this[componentId] && this[componentId].destroy) {
				this[componentId].destroy();
			}

			// Remove the component from the class component array
			if (this._components) {
				this._components.pull(this[componentId]);
			}

			// Remove the component namespace from the class object
			delete this[componentId];
			return this;
		},

		addSystem = function (system, options) {
			var newSystem = new system(this, options);
			console.log('System ID: ' + newSystem.systemId);
			this[newSystem.systemId] = newSystem;

			// Add the system reference to the class system array
			this._systems = this._systems || [];
			this._systems.push(newSystem);
		},

		removeSystem = function (systemId) {
			// If the system has a destroy method, call it
			if (this[systemId] && this[systemId].destroy) {
				this[systemId].destroy();
			}

			// Remove the system from the class system array
			if (this._systems) {
				this._systems.pull(this[systemId]);
			}
		},

		/**
		 * Copies all properties and methods from the classObj object
		 * to "this". If the overwrite flag is not set or set to false,
		 * only properties and methods that don't already exists in
		 * "this" will be copied. If overwrite is true, they will be
		 * copied regardless.
		 * @param {Function} classObj
		 * @param {Boolean} overwrite
		 * @example #Implement all the methods of an object into another object
		 *     // Create a couple of test entities with ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *	
		 *     // Let's define an object with a couple of methods
		 *     var obj = {
		 *         newMethod1: function () {
		 *             console.log('method1 called on object: ' + this.id());
		 *         },
		 *         
		 *         newMethod2: function () {
		 *             console.log('method2 called on object: ' + this.id());
		 *         }
		 *     };
		 *	
		 *     // Now let's implement the methods on our entities
		 *     entity1.implement(obj);
		 *     entity2.implement(obj);
		 *     
		 *     // The entities now have the newMethod1 and newMethod2
		 *     // methods as part of their instance so we can call them:
		 *     entity1.newMethod1();
		 *     
		 *     // The output to the console is:
		 *     //    method1 called on object: entity1
		 *     
		 *     // Now let's call newMethod2 on entity2:
		 *     entity2.newMethod2();
		 *	
		 *     // The output to the console is:
		 *     //    method2 called on object: entity2
		 *     
		 *     // As you can see, this is a great way to add extra modular
		 *     // functionality to objects / entities at runtime.
		 */
		implement = function (classObj, overwrite) {
			var i, obj = classObj.prototype || classObj;

			// Copy the class object's properties to (this)
			for (i in obj) {
				// Only copy the property if this doesn't already have it
				if (obj.hasOwnProperty(i) && (overwrite || this[i] === undefined)) {
					this[i] = obj[i];
				}
			}
			return this;
		},

		abstractMethodError = function (methodName) {
			this.log('Called abstract method ' + methodName + ' of ' + this.classId() + '. Either the method was not '
				+ 'overridden or an abstract method was called.', 'error');
		},

		/**
		 * Gets / sets a key / value pair in the object's data object. Useful for
		 * storing arbitrary game data in the object.
		 * @param {String} key The key under which the data resides.
		 * @param {*=} value The data to set under the specified key.
		 * @example #Set some arbitrary data key value pair
		 *     var entity = new IgeEntity();
		 *     entity.data('playerScore', 100);
		 *     entity.data('playerName', 'iRock');
		 * @example #Get the value of a data key
		 *     console.log(entity.data('playerScore'));
		 *     console.log(entity.data('playerName'));
		 * @return {*}
		 */
		data = function (key, value) {
			if (key !== undefined) {
				if (value !== undefined) {
					this._data = this._data || {};
					this._data[key] = value;

					return this;
				}
				
				if (this._data) {
					return this._data[key];
				} else {
					return null;
				}
			}
		};

	/**
	 * Create a new IgeClass that inherits from this class
	 * @name extend
	 * @example #Creating a new class by extending an existing one
	 *     var NewClass = IgeClass.extend({
	 *         // Init is your constructor
	 *         init: function () {
	 *             console.log('I\'m alive!');
	 *         }
	 *     });
	 * 
	 * Further reading: [Extending Classes](http://www.isogenicengine.com/documentation/isogenic-game-engine/versions/1-1-0/manual/engine-fundamentals/classes/extending-classes/)
	 * @return {Function}
	 */
	IgeClass.extend = function () {
		var name,
			prototype,
			// Set prop to the last argument passed
			prop = arguments[arguments.length - 1],
			extensionArray = arguments[0],
			extensionItem,
			extensionOverwrite,
			extensionIndex,
			propertyIndex,
			propertyObject;

		// Check that the class has been assigned a classId and bug out if not
		if (!prop.classId) {
			console.log(prop);
			throw('Cannot create a new class without giving the class a classId property!');
		}

		// Check that the classId is not already in use
		if (igeClassStore[prop.classId]) {
			// This classId has already been used, bug out
			throw('Cannot create class with classId "' + prop.classId + '" because a class with that ID has already been created!');
		}

		// Instantiate a base class (but only create the instance,
		// don't run the init constructor)
		initializing = true;
		prototype = new this();
		initializing = false;

		// Copy the properties over onto the new prototype
		for (name in prop) {
			if (prop.hasOwnProperty(name)) {
				// Copy the property
				prototype[name] = prop[name];
			}
		}

		// Now implement any other extensions
		if (arguments.length > 1) {
			if (extensionArray && extensionArray.length) {
				for (extensionIndex = 0; extensionIndex < extensionArray.length; extensionIndex++) {
					extensionItem = extensionArray[extensionIndex];
					propertyObject = extensionItem.extension.prototype || extensionItem.extension;
					extensionOverwrite = extensionItem.overwrite;

					// Copy the class object's properties to (this)
					for (propertyIndex in propertyObject) {
						// Only copy the property if this doesn't already have it or
						// the extension is set to overwrite any existing properties
						if (propertyObject.hasOwnProperty(propertyIndex) && (extensionOverwrite || prototype[propertyIndex] === undefined)) {
							prototype[propertyIndex] = propertyObject[propertyIndex];
						}
					}
				}
			}
		}
		
		//prototype._superClass = this.prototype;
		//console.log(prop.classId, 'extends', this.prototype._classId);

		// The dummy class constructor
		function IgeClass() {
			if (!initializing && this.init) {
				// Call the class init method
				this.init.apply(this, arguments);
			}
		}

		// Populate our constructed prototype object
		IgeClass.prototype = prototype;

		// Enforce the constructor to be what we expect
		IgeClass.prototype.constructor = IgeClass;

		// And make this class extensible
		IgeClass.extend = arguments.callee;

		// Add log capability
		IgeClass.prototype.log = log;

		// Add data capability
		IgeClass.prototype.data = data;

		// Add class name capability
		IgeClass.prototype.classId = classId; // This is a method that returns _classId
		IgeClass.prototype._classId = prop.classId || 'IgeClass';

		// Add the addComponent method
		IgeClass.prototype.addComponent = addComponent;

		// Add the removeComponent method
		IgeClass.prototype.removeComponent = removeComponent;

		IgeClass.prototype.addSystem = addSystem;

		IgeClass.prototype.removeSystem = removeSystem;

		// Add the implement method
		IgeClass.prototype.implement = implement;

		IgeClass.prototype.abstractMethod = abstractMethodError;
		
		// Add editor settings
		IgeClass.prototype.__igeEditor = prop.editorOptions;

		// Register the class with the class store
		igeClassStore[prop.classId] = IgeClass;

		return IgeClass;
	};

	/**
	 * Test method
	 * @param prop
	 * @return {Function}
	 */
	IgeClass.vanilla = function (prop) {
		var IgeClass = prop.init || function () {},
			prototype = new this();
		
		// Copy the properties over onto the new prototype
		for (name in prop) {
			if (prop.hasOwnProperty(name) && name !== 'init') {
				// Copy the property
				prototype[name] = prop[name];
			}
		}
		
		// Populate our constructed prototype object
		IgeClass.prototype = prototype;

		// Enforce the constructor to be what we expect
		IgeClass.prototype.constructor = IgeClass;
		
		// And make this class extensible
		IgeClass.extend = this.extend;
		
		// Add log capability
		IgeClass.prototype.log = log;

		// Add data capability
		IgeClass.prototype.data = data;

		// Add class name capability
		IgeClass.prototype.classId = classId; // This is a method that returns _classId
		IgeClass.prototype._classId = prop.classId || 'IgeClass';

		// Add the addComponent method
		IgeClass.prototype.addComponent = addComponent;

		// Add the removeComponent method
		IgeClass.prototype.removeComponent = removeComponent;

		IgeClass.prototype.addSystem = addSystem;

		IgeClass.prototype.removeSystem = removeSystem;

		// Add the implement method
		IgeClass.prototype.implement = implement;

		// Register the class with the class store
		igeClassStore[prop.classId] = IgeClass;
		
		return IgeClass;
	};

	IgeClass.prototype._classId = 'IgeClass';

	return IgeClass;
}());

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeClass; };/**
 * Creates a new class with the capability to emit events.
 */
var IgeEventingClass = IgeClass.extend({
	classId: 'IgeEventingClass',

	/**
	 * Add an event listener method for an event.
	 * @param {String || Array} eventName The name of the event to listen for (string), or an array of events to listen for.
	 * @param {Function} call The method to call when the event listener is triggered.
	 * @param {Object=} context The context in which the call to the listening method will be made (sets the 'this' variable in the method to the object passed as this parameter).
	 * @param {Boolean=} oneShot If set, will instruct the listener to only listen to the event being fired once and will not fire again.
	 * @param {Boolean=} sendEventName If set, will instruct the emitter to send the event name as the argument instead of any emitted arguments.
	 * @return {Object} The event listener object. Hold this value if you later want to turn off the event listener.
	 * @example #Add an Event Listener
	 *     // Register event lister and store in "evt"
	 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
	 * @example #Listen for Event Data
	 *     // Set a listener to listen for the data (multiple values emitted
	 *     // from an event are passed as function arguments)
	 *     myEntity.on('hello', function (arg1, arg2) {
	 *         console.log(arg1, arg2);
	 *     }
	 *     
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', ['data1', 'data2']);
	 *     
	 *     // The console output is:
	 *     //    data1, data2
	 */
	on: function (eventName, call, context, oneShot, sendEventName) {
		var self = this,
			newListener,
			addListener,
			existingIndex,
			elArr,
			multiEvent,
			eventIndex,
			eventData,
			eventObj,
			multiEventName,
			i;

		// Check that we have an event listener object
		this._eventListeners = this._eventListeners || {};

		if (typeof call === 'function') {
			if (typeof eventName === 'string') {
				// Compose the new listener
				newListener = {
					call: call,
					context: context,
					oneShot: oneShot,
					sendEventName: sendEventName
				};

				elArr = this._eventListeners[eventName] = this._eventListeners[eventName] || [];

				// Check if we already have this listener in the list
				addListener = true;

				// TO-DO - Could this do with using indexOf? Would that work? Would be faster?
				existingIndex = elArr.indexOf(newListener);
				if (existingIndex > -1) {
					addListener = false;
				}

				// Add this new listener
				if (addListener) {
					elArr.push(newListener);
				}

				return newListener;
			} else {
				// The eventName is an array of names, creating a group of events
				// that must be fired to fire this event callback
				if (eventName.length) {
					// Loop the event array
					multiEvent = [];
					multiEvent[0] = 0; // This will hold our event count total
					multiEvent[1] = 0; // This will hold our number of events fired

					// Define the multi event callback
					multiEvent[3] = function (firedEventName) {
						multiEvent[1]++;

						if (multiEvent[0] === multiEvent[1]) {
							// All the multi-event events have fired
							// so fire the callback
							call.apply(context || self);
						}
					};

					for (eventIndex in eventName) {
						if (eventName.hasOwnProperty(eventIndex)) {
							eventData = eventName[eventIndex];
							eventObj = eventData[0];
							multiEventName = eventData[1];

							// Increment the event listening count total
							multiEvent[0]++;

							// Register each event against the event object with a callback
							eventObj.on(multiEventName, multiEvent[3], null, true, true);
						}
					}
				}
			}
		} else {
			if (typeof(eventName) !== 'string') {
				eventName = '*Multi-Event*';
			}
			this.log('Cannot register event listener for event "' + eventName + '" because the passed callback is not a function!', 'error');
		}
	},
	
	/**
	 * Remove an event listener. If the _processing flag is true
	 * then the removal will be placed in the removals array to be
	 * processed after the event loop has completed in the emit()
	 * method.
	 * @param {Boolean} eventName The name of the event you originally registered to listen for.
	 * @param {Object} evtListener The event listener object to cancel. This object is the one
	 * returned when calling the on() method. It is NOT the method you passed as the second argument
	 * to the on() method.
	 * @param {Function} callback The callback method to call when the event listener has been
	 * successfully removed. If you attempt to remove a listener during the event firing loop
	 * then the listener will not immediately be removed but will be queued for removal before
	 * the next listener loop is fired. In this case you may like to be informed via callback
	 * when the listener has been fully removed in which case, provide a method for this argument.
	 * 
	 * The callback will be passed a single boolean argument denoting if the removal was successful
	 * (true) or the listener did not exist to remove (false).
	 * @example #Switch off an Event Listener
	 *     // Register event lister and store in "evt"
	 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
	 *     
	 *     // Switch off event listener
	 *     myEntity.off('mouseDown', evt);
	 * @return {Boolean}
	 */
	off: function (eventName, evtListener, callback) {
		if (this._eventListeners) {
			if (!this._eventListeners._processing) {
				if (this._eventListeners[eventName]) {
					// Find this listener in the list
					var evtListIndex = this._eventListeners[eventName].indexOf(evtListener);
					if (evtListIndex > -1) {
						// Remove the listener from the event listener list
						this._eventListeners[eventName].splice(evtListIndex, 1);
						if (callback) {
							callback(true);
						}
						return true;
					} else {
						this.log('Failed to cancel event listener for event named "' + eventName + '" !', 'warning', evtListener);
					}
				} else {
					this.log('Failed to cancel event listener!');
				}
			} else {
				// Add the removal to a remove queue since we are processing
				// listeners at the moment and removing one would mess up the
				// loop!
				this._eventListeners._removeQueue = this._eventListeners._removeQueue || [];
				this._eventListeners._removeQueue.push([eventName, evtListener, callback]);

				return -1;
			}
		}

		if (callback) {
			callback(false);
		}
		return false;
	},

	/**
	 * Emit an event by name.
	 * @param {Object} eventName The name of the event to emit.
	 * @param {Object || Array} args The arguments to send to any listening methods.
	 * If you are sending multiple arguments, use an array containing each argument.
	 * @return {Number}
	 * @example #Emit an Event
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello');
	 * @example #Emit an Event With Data Object
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', {moo: true});
	 * @example #Emit an Event With Multiple Data Values
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', [{moo: true}, 'someString']);
	 * @example #Listen for Event Data
	 *     // Set a listener to listen for the data (multiple values emitted
	 *     // from an event are passed as function arguments)
	 *     myEntity.on('hello', function (arg1, arg2) {
	 *         console.log(arg1, arg2);
	 *     }
	 *     
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', ['data1', 'data2']);
	 *     
	 *     // The console output is:
	 *     //    data1, data2
	 */
	emit: function (eventName, args) {
		if (this._eventListeners) {
			// Check if the event has any listeners
			if (this._eventListeners[eventName]) {

				// Fire the listeners for this event
				var eventCount = this._eventListeners[eventName].length,
					eventCount2 = this._eventListeners[eventName].length - 1,
					finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;

				// If there are some events, ensure that the args is ready to be used
				if (eventCount) {
					finalArgs = [];
					if (typeof(args) === 'object' && args !== null && args[0] !== null && args[0] !== undefined) {
						for (i in args) {
							if (args.hasOwnProperty(i)) {
								finalArgs[i] = args[i];
							}
						}
					} else {
						finalArgs = [args];
					}

					// Loop and emit!
					cancelFlag = false;

					this._eventListeners._processing = true;
					while (eventCount--) {
						eventIndex = eventCount2 - eventCount;
						tempEvt = this._eventListeners[eventName][eventIndex];

						if (tempEvt === undefined) {
							continue;
						}

						// If the sendEventName flag is set, overwrite the arguments with the event name
						if (tempEvt.sendEventName) { finalArgs = [eventName]; }

						// Call the callback
						retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);

						// If the retVal === true then store the cancel flag and return to the emitting method
						if (retVal === true) {
							// The receiver method asked us to send a cancel request back to the emitter
							cancelFlag = true;
						}

						// Check if we should now cancel the event
						if (tempEvt.oneShot) {
							// The event has a oneShot flag so since we have fired the event,
							// lets cancel the listener now
							if (this.off(eventName, tempEvt) === true) {
								eventCount2--;	
							}
						}
					}

					// Check that the array still exists because an event
					// could have triggered a method that destroyed our object
					// which would have deleted the array!
					if (this._eventListeners) {
						this._eventListeners._processing = false;

						// Now process any event removal
						this._processRemovals();
					}

					if (cancelFlag) {
						return 1;
					}

				}

			}
		}
	},

	/**
	 * Returns an object containing the current event listeners.
	 * @return {Object}
	 */
	eventList: function () {
		return this._eventListeners;
	},
	
	/**
	 * Loops the removals array and processes off() calls for
	 * each array item.
	 * @private
	 */
	_processRemovals: function () {
		if (this._eventListeners) {
			var remArr = this._eventListeners._removeQueue,
				arrCount,
				item,
				result;

			// If the removal array exists
			if (remArr) {
				// Get the number of items in the removal array
				arrCount = remArr.length;

				// Loop the array
				while (arrCount--) {
					item = remArr[arrCount];

					// Call the off() method for this item
					result = this.off(item[0], item[1]);

					// Check if there is a callback
					if (typeof remArr[2] === 'function') {
						// Call the callback with the removal result
						remArr[2](result);
					}
				}
			}

			// Remove the removal array
			delete this._eventListeners._removeQueue;
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEventingClass; };var TLEntityComponent = IgeEventingClass.extend({
	classId: 'TLEntityComponent',

	_entity: undefined,

	init: function(entity, data) {
		this._entity = entity;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TLEntityComponent;
}
;var TLStreamedEntityComponent = TLEntityComponent.extend({
	classId: 'TLStreamedEntityComponent',

	init: function(entity, data) {
		TLEntityComponent.prototype.init.call(this, entity, data);
		this._actionCallbacks = this._actionCallbacks || {};
	},

	actions: function() {
		return this._entity.actions();
	},

	process: function(action) {
		if (!this._actionCallbacks[action.name]) {
			this.log("TLStreamedEntityComponent#process: no action callback for action: "
				+ action.name + " on entity: " + this._entity.classId(), "error");
		}

		this._actionCallbacks[action.name].call(this, action);
	},

	pushAction: function(name, data) {
		this.actions().push({
			id: this._entity.id(),
			component: this.componentId,
			name: name,
			data: data
		});
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TLStreamedEntityComponent;
};var TLSystem = IgeEventingClass.extend({
	classId: 'TLSystem',

	init: function(data) {

	},

	update: function() {
		this.abstractMethod('update');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = TLSystem; };var TLSubsystem = TLSystem.extend({
	classId: 'TLSubsystem',

	_supersystem: undefined,

	init: function(supersystem, data) {
		TLSystem.prototype.init.call(this, data);
		this._supersystem = supersystem;
	},

	start: function() {
		// TODO: Make this a behaviour addition instead once IgeEngine update function code has been refactored
		//this._supersystem.addBehaviour(this.systemId, this.update);
		this._supersystem._postTick.push(this.update.bind(this));
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = TLSubsystem; };/**
 * Creates a new 2d point (x, y).
 */
var IgePoint2d = IgeClass.extend({
	classId: 'IgePoint2d',

	init: function (x, y, floor) {
		// Set values to the passed parameters or
		// zero if they are undefined
		// Commented for increase performance over stability checks
		/*if (x === undefined) { debugger; }
		if (y === undefined) { debugger; }*/
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		
		this._floor = floor !== undefined;
		
		if (this._floor) {
			this.x2 = Math.floor(x / 2);
			this.y2 = Math.floor(y / 2);
		} else {
			this.x2 = x / 2;
			this.y2 = y / 2;
		}

		return this;
	},

	/**
	 * Gets / sets the floor mode of this point. If set to true the point's
	 * data will be mathematically floored when they are assigned.
	 * @param val
	 * @return {*}
	 */
	floor: function (val) {
		if (val !== undefined) {
			this._floor = val;
			return this;
		}

		return this._floor;
	},

	/**
	 * Compares this point's x, y data with the passed point and returns
	 * true if they are the same and false if any is different.
	 * @param {IgePoint2d} point The point to compare data with.
	 * @return {Boolean}
	 */
	compare: function (point) {
		return point && this.x === point.x && this.y === point.y;
	},

	/**
	 * Copies the x, y data from the passed point and overwrites this
	 * point's data with those values.
	 * @param {IgePoint2d} point The point to copy values from.
	 * @returns {*}
	 */
	copy: function (point) {
		this.x = point.x;
		this.y = point.y;
		this.z = point.z;
		
		return this;
	},

	/**
	 * Converts the point's x, y to an isometric x, y 2d co-ordinate
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	toIso: function () {
		var sx = this.x - this.y,
			sy = (this.x + this.y) * 0.5;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y data into isometric co-ordinate space
	 * and overwrites the previous x, y values with the result.
	 * @return {*}
	 */
	thisToIso: function () {
		var val = this.toIso();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Converts this point's x, y data into 2d co-ordinate space
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	to2d: function () {
		var sx = this.y + this.x / 2,
			sy = this.y - this.x / 2;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y data into 2d co-ordinate space
	 * and overwrites the previous x, y values with the result.
	 * @return {*}
	 */
	thisTo2d: function () {
		var val = this.to2d();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Adds this point's data by the x, y, values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	addPoint: function (point) {
		return new IgePoint2d(this.x + point.x, this.y + point.y);
	},

	/**
	 * Adds this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param point
	 * @return {*}
	 */
	thisAddPoint: function (point) {
		this.x += point.x;
		this.y += point.y;

		return this;
	},

	/**
	 * Minuses this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	minusPoint: function (point) {
		return new IgePoint2d(this.x - point.x, this.y - point.y);
	},

	/**
	 * Minuses this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param point
	 * @return {*}
	 */
	thisMinusPoint: function (point) {
		this.x -= point.x;
		this.y -= point.y;

		return this;
	},

	/**
	 * Multiplies this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	multiply: function (x, y) {
		return new IgePoint2d(this.x * x, this.y * y);
	},

	/**
	 * Multiplies this point's data by the point specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param {IgePoint2d} point
	 * @return {*}
	 */
	multiplyPoint: function (point) {
		return new IgePoint2d(this.x * point.x, this.y * point.y);
	},

	/**
	 * Multiplies this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisMultiply: function (x, y) {
		this.x *= x;
		this.y *= y;

		return this;
	},

	/**
	 * Divides this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	divide: function (x, y) {
		return new IgePoint2d(this.x / x, this.y / y);
	},
	
	/**
	 * Divides this point's data by the point specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param {IgePoint2d} point
	 * @return {*}
	 */
	dividePoint: function (point) {
		var newX = this.x,
			newY = this.y;
		
		if (point.x) { newX = this.x / point.x; }
		if (point.y) { newY = this.y / point.y; }
		
		return new IgePoint2d(newX, newY);
	},

	/**
	 * Divides this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	thisDivide: function (x, y) {
		this.x /= x;
		this.y /= y;

		return this;
	},

	/**
	 * Returns a clone of this IgePoint2d's data as a new instance.
	 * @return {*}
	 */
	clone: function () {
		return new IgePoint2d(this.x, this.y);
	},

	/**
	 * Interpolates the x, y values of this point towards the endPoint's
	 * x, y values based on the passed time variables and returns a new
	 * IgePoint2d whose values are the result.
	 * @param endPoint
	 * @param startTime
	 * @param currentTime
	 * @param endTime
	 * @return {*}
	 */
	interpolate: function (endPoint, startTime, currentTime, endTime) {
		var totalX = endPoint.x - this.x,
			totalY = endPoint.y - this.y,
			totalTime = endTime - startTime,
			deltaTime = totalTime - (currentTime - startTime),
			timeRatio = deltaTime / totalTime;

		return new IgePoint2d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio));
	},

	/**
	 * Rotates the point by the given radians.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint2d} A new point with the rotated x, y.
	 */
	rotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = c * this.x - s * this.y,
			y = s * this.x - c * this.y;
		
		return new IgePoint2d(x, y);
	},
	
	/**
	 * Rotates the point by the given radians and updates this point
	 * to the new x, y values.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint2d} This point.
	 */
	thisRotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = this.x,
			y = this.y;
		
		this.x = c * x - s * y;
		this.y = s * x - c * y;
		
		return this;
	},

	/**
	 * Returns a string representation of the point's x, y
	 * converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision);
	}
});

IgePoint2d.validatePoint = function(point) {
	return point !== undefined && point.x !== undefined && point.y !== undefined;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoint2d; };/**
 * Creates a new 3d point (x, y, z).
 */
var IgePoint3d = IgeClass.extend({
	classId: 'IgePoint3d',

	init: function (x, y, z, floor) {
		// Set values to the passed parameters or
		// zero if they are undefined
		// Commented for increase performance over stability checks
		/*if (x === undefined) { debugger; }
		if (y === undefined) { debugger; }
		if (z === undefined) { debugger; }*/
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		this.z = z = z !== undefined ? z : 0;
		
		this._floor = floor !== undefined;
		
		if (this._floor) {
			this.x2 = Math.floor(x / 2);
			this.y2 = Math.floor(y / 2);
			this.z2 = Math.floor(z / 2);
		} else {
			this.x2 = x / 2;
			this.y2 = y / 2;
			this.z2 = z / 2;
		}

		return this;
	},

	/**
	 * Gets / sets the floor mode of this point. If set to true the point's
	 * data will be mathematically floored when they are assigned.
	 * @param val
	 * @return {*}
	 */
	floor: function (val) {
		if (val !== undefined) {
			this._floor = val;
			return this;
		}

		return this._floor;
	},

	/**
	 * Compares this point's x, y, z data with the passed point and returns
	 * true if they are the same and false if any is different.
	 * @param {IgePoint3d} point The point to compare data with.
	 * @return {Boolean}
	 */
	compare: function (point) {
		return point && this.x === point.x && this.y === point.y && this.z === point.z;
	},

	/**
	 * Copies the x, y, z data from the passed point and overwrites this
	 * point's data with those values.
	 * @param {IgePoint3d} point The point to copy values from.
	 * @returns {*}
	 */
	copy: function (point) {
		this.x = point.x;
		this.y = point.y;
		this.z = point.z;
		
		return this;
	},

	/**
	 * Converts the point's x, y, z to an isometric x, y 2d co-ordinate
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	toIso: function () {
		var sx = this.x - this.y,
			sy = (-this.z) * 1.2247 + (this.x + this.y) * 0.5;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y, z data into isometric co-ordinate space
	 * and overwrites the previous x, y, z values with the result.
	 * @return {*}
	 */
	thisToIso: function () {
		var val = this.toIso();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Converts this point's x, y, z data into 2d co-ordinate space
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	to2d: function () {
		var sx = this.y + this.x / 2,
			sy = this.y - this.x / 2;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y, z data into 2d co-ordinate space
	 * and overwrites the previous x, y, z values with the result.
	 * @return {*}
	 */
	thisTo2d: function () {
		var val = this.to2d();
		this.x = val.x;
		this.y = val.y;
		this.z = 0;

		return this;
	},

	/**
	 * Adds this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	addPoint: function (point) {
		return new IgePoint3d(this.x + point.x, this.y + point.y, this.z + point.z);
	},

	/**
	 * Adds this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param point
	 * @return {*}
	 */
	thisAddPoint: function (point) {
		this.x += point.x;
		this.y += point.y;
		this.z += point.z;

		return this;
	},

	/**
	 * Minuses this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	minusPoint: function (point) {
		return new IgePoint3d(this.x - point.x, this.y - point.y, this.z - point.z);
	},

	/**
	 * Minuses this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param point
	 * @return {*}
	 */
	thisMinusPoint: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		this.z -= point.z;

		return this;
	},

	/**
	 * Multiplies this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	multiply: function (x, y, z) {
		return new IgePoint3d(this.x * x, this.y * y, this.z * z);
	},

	/**
	 * Multiplies this point's data by the point specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param {IgePoint3d} point
	 * @return {*}
	 */
	multiplyPoint: function (point) {
		return new IgePoint3d(this.x * point.x, this.y * point.y, this.z * point.z);
	},

	/**
	 * Multiplies this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisMultiply: function (x, y, z) {
		this.x *= x;
		this.y *= y;
		this.z *= z;

		return this;
	},

	/**
	 * Divides this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	divide: function (x, y, z) {
		return new IgePoint3d(this.x / x, this.y / y, this.z / z);
	},
	
	/**
	 * Divides this point's data by the point specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param {IgePoint3d} point
	 * @return {*}
	 */
	dividePoint: function (point) {
		var newX = this.x,
			newY = this.y,
			newZ = this.z;
		
		if (point.x) { newX = this.x / point.x; }
		if (point.y) { newY = this.y / point.y; }
		if (point.z) { newZ = this.z / point.z; }
		
		return new IgePoint3d(newX, newY, newZ);
	},

	/**
	 * Divides this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisDivide: function (x, y, z) {
		this.x /= x;
		this.y /= y;
		this.z /= z;

		return this;
	},

	/**
	 * Returns a clone of this IgePoint3d's data as a new instance.
	 * @return {*}
	 */
	clone: function () {
		return new IgePoint3d(this.x, this.y, this.z);
	},

	/**
	 * Interpolates the x, y, z values of this point towards the endPoint's
	 * x, y, z values based on the passed time variables and returns a new
	 * IgePoint3d whose values are the result.
	 * @param endPoint
	 * @param startTime
	 * @param currentTime
	 * @param endTime
	 * @return {*}
	 */
	interpolate: function (endPoint, startTime, currentTime, endTime) {
		var totalX = endPoint.x - this.x,
			totalY = endPoint.y - this.y,
			totalZ = endPoint.z - this.z,
			totalTime = endTime - startTime,
			deltaTime = totalTime - (currentTime - startTime),
			timeRatio = deltaTime / totalTime;

		return new IgePoint3d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio), endPoint.z - (totalZ * timeRatio));
	},

	/**
	 * Rotates the point by the given radians.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint3d} A new point with the rotated x, y.
	 */
	rotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = c * this.x - s * this.y,
			y = s * this.x - c * this.y;
		
		return new IgePoint3d(x, y, this.z);
	},
	
	/**
	 * Rotates the point by the given radians and updates this point
	 * to the new x, y values.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint3d} This point.
	 */
	thisRotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = this.x,
			y = this.y;
		
		this.x = c * x - s * y;
		this.y = s * x - c * y;
		
		return this;
	},

	/**
	 * Returns a string representation of the point's x, y, z
	 * converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.z.toFixed(precision);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoint3d; };/**
 * Creates a new 2d polygon made up of IgePoint2d instances.
 */
var IgePoly2d = IgeClass.extend({
	classId: 'IgePoly2d',

	init: function () {
		this._poly = [];
		this._scale = new IgePoint2d(1, 1);
	},

	scale: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._scale.x = x;
			this._scale.y = y;

			return this;
		}

		return this._scale;
	},

	/**
	 * Multiplies the points of the polygon by the supplied factor.
	 * @param {Number} factor The multiplication factor.
	 * @return {*}
	 */
	multiply: function (factor) {
		if (factor !== undefined) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex;

			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				polyPoints[pointIndex].x *= factor;
				polyPoints[pointIndex].y *= factor;
			}
		}

		return this;
	},

	/**
	 * Divides the points of the polygon by the supplied value.
	 * @param {Number} value The divide value.
	 * @return {*}
	 */
	divide: function (value) {
		if (value !== undefined) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex;

			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				polyPoints[pointIndex].x /= value;
				polyPoints[pointIndex].y /= value;
			}
		}

		return this;
	},

	/**
	 * Adds a point to the polygon relative to the polygon center at 0, 0.
	 * @param x
	 * @param y
	 */
	addPoint: function (x, y) {
		this._poly.push(new IgePoint2d(x, y));
		return this;
	},

	/**
	 * Returns the length of the poly array.
	 * @return {Number}
	 */
	length: function () {
		return this._poly.length;
	},

	/**
	 * Check if a point is inside this polygon.
	 * @param {IgePoint2d} point
	 * @return {Boolean}
	 */
	pointInPoly: function (point) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			pointIndex,
			oldPointIndex = pointCount - 1,
			c = 0;

		for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
			if (((polyPoints[pointIndex].y > point.y) !== (polyPoints[oldPointIndex].y > point.y)) &&
				(point.x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(point.y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
				c = !c;
			}
		}

		return Boolean(c);
	},
	
	/**
	 * Check if the passed x and y are inside this polygon.
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean}
	 */
	xyInside: function (x, y) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			pointIndex,
			oldPointIndex = pointCount - 1,
			c = 0;

		for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
			if (((polyPoints[pointIndex].y > y) !== (polyPoints[oldPointIndex].y > y)) &&
				(x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
				c = !c;
			}
		}

		return Boolean(c);
	},
	
	aabb: function () {
		var minX,
			minY,
			maxX,
			maxY,
			xArr = [],
			yArr = [],
			arr = this._poly,
			arrIndex,
			arrCount = arr.length;
		
		for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
			xArr.push(arr[arrIndex].x);
			yArr.push(arr[arrIndex].y);
		}
		
		// Get the extents of the newly transformed poly
		minX = Math.min.apply(Math, xArr);
		minY = Math.min.apply(Math, yArr);
		maxX = Math.max.apply(Math, xArr);
		maxY = Math.max.apply(Math, yArr);
	
		return new IgeRect(minX, minY, maxX - minX, maxY - minY);
	},

	/**
	 * Returns a copy of this IgePoly2d object that is
	 * it's own version, separate from the original.
	 * @return {IgePoly2d}
	 */
	clone: function () {
		var newPoly = new IgePoly2d(),
			arr = this._poly,
			arrCount = arr.length,
			i;

		for (i = 0; i < arrCount; i++) {
			newPoly.addPoint(arr[i].x, arr[i].y);
		}

		newPoly.scale(this._scale.x, this._scale.y);

		return newPoly;
	},

	/**
	 * Determines if the polygon is clockwise or not.
	 * @return {Boolean} A boolean true if clockwise or false
	 * if not.
	 */
	clockWiseTriangle: function () {
		// Loop the polygon points and determine if they are counter-clockwise
		var arr = this._poly,
			val,
			p1, p2, p3;

		p1 = arr[0];
		p2 = arr[1];
		p3 = arr[2];

		val = (p1.x * p2.y) + (p2.x * p3.y) + (p3.x * p1.y) - (p2.y * p3.x) - (p3.y * p1.x) - (p1.y * p2.x);

		return val > 0;
	},

	makeClockWiseTriangle: function () {
		// If our data is already clockwise exit
		if (!this.clockWiseTriangle()) {
			var p0 = this._poly[0],
				p1 = this._poly[1],
				p2 = this._poly[2];

			this._poly[2] = p1;
			this._poly[1] = p2;
		}
	},

	triangulate: function () {
		// Get the indices of each new triangle
		var poly = this._poly,
			triangles = [],
			indices = this.triangulationIndices(),
			i,
			point1,
			point2,
			point3,
			newPoly;

		// Generate new polygons from the index data
		for (i = 0; i < indices.length; i += 3) {
			point1 = poly[indices[i]];
			point2 = poly[indices[i + 1]];
			point3 = poly[indices[i + 2]];
			newPoly = new IgePoly2d();

			newPoly.addPoint(point1.x, point1.y);
			newPoly.addPoint(point2.x, point2.y);
			newPoly.addPoint(point3.x, point3.y);

			// Check the new poly and make sure it's clockwise
			newPoly.makeClockWiseTriangle();
			triangles.push(newPoly);
		}

		return triangles;
	},

	triangulationIndices: function () {
		var indices = [],
			n = this._poly.length,
			v = [],
			V = [],
			nv,
			count,
			m,
			u,
			w,
			a,
			b,
			c,
			s,
			t;
		
		if (n < 3) { return indices; }

		if (this._area() > 0) {
			for (v = 0; v < n; v++) {
				V[v] = v;
			}
		} else {
			for (v = 0; v < n; v++) {
				V[v] = (n - 1) - v;
			}
		}

		nv = n;
		count = 2 * nv;
		m = 0;

		for (v = nv - 1; nv > 2; ) {
			if ((count--) <= 0) {
				return indices;
			}

			u = v;
			if (nv <= u) {
				u = 0;
			}

			v = u + 1;

			if (nv <= v) {
				v = 0;
			}

			w = v + 1;

			if (nv <= w) {
				w = 0;
			}

			if (this._snip(u, v, w, nv, V)) {
				a = V[u];
				b = V[v];
				c = V[w];
				indices.push(a);
				indices.push(b);
				indices.push(c);
				m++;
				s = v;

				for (t = v + 1; t < nv; t++) {
					V[s] = V[t];
					s++;
				}

				nv--;
				count = 2 * nv;
			}
		}

		indices.reverse();
		return indices;
	},

	_area: function () {
		var n = this._poly.length,
			a = 0.0,
			q = 0,
			p,
			pval,
			qval;

		for (p = n - 1; q < n; p = q++) {
			pval = this._poly[p];
			qval = this._poly[q];
			a += pval.x * qval.y - qval.x * pval.y;
		}

		return (a * 0.5);
	},

	_snip: function (u, v, w, n, V) {
		var p,
			A = this._poly[V[u]],
			B = this._poly[V[v]],
			C = this._poly[V[w]],
			P;

		// Replaced Math.Epsilon with 0.00001
		if (0.00001 > (((B.x - A.x) * (C.y - A.y)) - ((B.y - A.y) * (C.x - A.x)))) {
			return false;
		}

		for (p = 0; p < n; p++) {
			if ((p == u) || (p == v) || (p == w)) {
				continue;
			}

			P = this._poly[V[p]];
			if (this._insideTriangle(A, B, C, P)) {
				return false;
			}
		}

		return true;
	},

	_insideTriangle: function (A, B, C, P) {
		var ax,
			ay,
			bx,
			by,
			cx,
			cy,
			apx,
			apy,
			bpx,
			bpy,
			cpx,
			cpy,
			cCROSSap,
			bCROSScp,
			aCROSSbp;

		ax = C.x - B.x; ay = C.y - B.y;
		bx = A.x - C.x; by = A.y - C.y;
		cx = B.x - A.x; cy = B.y - A.y;
		apx = P.x - A.x; apy = P.y - A.y;
		bpx = P.x - B.x; bpy = P.y - B.y;
		cpx = P.x - C.x; cpy = P.y - C.y;

		aCROSSbp = ax * bpy - ay * bpx;
		cCROSSap = cx * apy - cy * apx;
		bCROSScp = bx * cpy - by * cpx;

		return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
	},

	/**
	 * Draws the polygon bounding lines to the passed context.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	render: function (ctx, fill) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			scaleX = this._scale.x,
			scaleY = this._scale.y,
			i;

		ctx.beginPath();
		ctx.moveTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
		for (i = 1; i < pointCount; i++) {
			ctx.lineTo(polyPoints[i].x * scaleX, polyPoints[i].y * scaleY);
		}
		ctx.lineTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
		if (fill) { ctx.fill(); }
		ctx.stroke();

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoly2d; };/**
 * Creates a new rectangle (x, y, width, height).
 */
var IgeRect = IgeClass.extend({
	classId: 'IgeRect',

	init: function (x, y, width, height) {
		// Set values to the passed parameters or
		// zero if they are undefined
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		this.width = width = width !== undefined ? width : 0;
		this.height = height = height !== undefined ? height : 0;

		this.x2 = this.x / 2;
		this.y2 = this.y / 2;

		return this;
	},
	
	/**
	 * Combines the extents of the passed IgeRect with this rect
	 * to create a new rect whose bounds encapsulate both rects.
	 * @param {IgeRect} rect The rect to combine with this one.
	 * @return {IgeRect} The new rect encapsulating both rects.
	 */
	combineRect: function (rect) {
		var thisRectMaxX = this.x + this.width,
			thisRectMaxY = this.y + this.height,
			thatRectMaxX = rect.x + rect.width,
			thatRectMaxY = rect.y + rect.height,

			x = Math.min(this.x, rect.x),
			y = Math.min(this.y, rect.y),
			width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x),
			height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);

		return new IgeRect(x, y, width, height);
	},

	/**
	 * Combines the extents of the passed IgeRect with this rect
	 * and replaces this rect with one whose bounds encapsulate
	 * both rects.
	 * @param {IgeRect} rect The rect to combine with this one.
	 */
	thisCombineRect: function (rect) {
		var thisRectMaxX = this.x + this.width,
			thisRectMaxY = this.y + this.height,
			thatRectMaxX = rect.x + rect.width,
			thatRectMaxY = rect.y + rect.height;

		this.x = Math.min(this.x, rect.x);
		this.y = Math.min(this.y, rect.y);

		this.width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x);
		this.height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);
	},
	
	minusPoint: function (point) {
		return new IgeRect(this.x - point.x, this.y - point.y, this.width, this.height);
	},

	/**
	 * Compares this rect's dimensions with the passed rect and returns
	 * true if they are the same and false if any is different.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	compare: function (rect) {
		return rect && this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
	},

	/**
	 * Returns boolean indicating if the passed x, y is
	 * inside the rectangle.
	 * @param x
	 * @param y
	 * @return {Boolean}
	 */
	xyInside: function (x, y) {
		return x >= this.x && y > this.y && x <= this.x + this.width && y <= this.y + this.height;
	},

	/**
	 * Returns boolean indicating if the passed point is
	 * inside the rectangle.
	 * @param {IgePoint3d} point
	 * @return {Boolean}
	 */
	pointInside: function (point) {
		return point.x >= this.x && point.y > this.y && point.x <= this.x + this.width && point.y <= this.y + this.height;
	},

	/**
	 * Returns boolean indicating if the passed IgeRect is
	 * intersecting the rectangle.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	rectIntersect: function (rect) {
		this.log('rectIntersect has been renamed to "intersects". Please update your code. rectIntersect will be removed in a later version of IGE.', 'warning');
		return this.intersects(rect);
	},

	/**
	 * Returns boolean indicating if the passed IgeRect is
	 * intersecting the rectangle.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	intersects: function (rect) {
		if (rect) {
			var sX1 = this.x,
				sY1 = this.y,
				sW = this.width,
				sH = this.height,

				dX1 = rect.x,
				dY1 = rect.y,
				dW = rect.width,
				dH = rect.height,

				sX2 = sX1 + sW,
				sY2 = sY1 + sH,
				dX2 = dX1 + dW,
				dY2 = dY1 + dH;

			if (sX1 < dX2 && sX2 > dX1 && sY1 < dY2 && sY2 > dY1) {
				return true;
			}
		}

		return false;
	},
	
	/**
	 * Multiplies this rect's data by the values specified
	 * and returns a new IgeRect whose values are the result.
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return {*}
	 */
	multiply: function (x1, y1, x2, y2) {
		return new IgeRect(this.x * x1, this.y * y1, this.width * x2, this.height * y2);
	},
	
	/**
	 * Multiplies this rects's data by the values specified and
	 * overwrites the previous values with the result.
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return {*}
	 */
	thisMultiply: function (x1, y1, x2, y2) {
		this.x *= x1;
		this.y *= y1;
		this.width *= x2;
		this.height *= y2;

		return this;
	},

	/**
	 * Returns a clone of this object that is not a reference
	 * but retains the same values.
	 * @return {IgeRect}
	 */
	clone: function () {
		return new IgeRect(this.x, this.y, this.width, this.height);
	},

	/**
	 * Returns a string representation of the rect's x, y, width,
	 * height, converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.width.toFixed(precision) + ',' + this.height.toFixed(precision);
	},
	
	/**
	 * Draws the polygon bounding lines to the passed context.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	render: function (ctx, fill) {
		ctx.rect(this.x, this.y, this.width, this.height);
		if (fill) { ctx.fill(); }
		ctx.stroke();

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeRect; };// TODO: Clean up the variable declarations in this file so they all run on the same var call at the top of the method.
/**
 * Creates a new transformation matrix.
 */
var IgeMatrix2d = function() {
	this.matrix = [
		1.0,0.0,0.0,
		0.0,1.0,0.0,
		0.0,0.0,1.0
	];

	this._rotateOrigin = new IgePoint3d(0, 0, 0);
	this._scaleOrigin = new IgePoint3d(0, 0, 0);
};

IgeMatrix2d.prototype = {
	matrix:	null,

	/**
	 * Transform a point by this matrix. The parameter point will be modified with the transformation values.
	 * @param {IgePoint3d} point
	 * @return {IgePoint3d} The passed point.
	 */
	transformCoord: function(point, obj) {
		var x = point.x,
			y = point.y,
			tm = this.matrix;

		point.x = x * tm[0] + y * tm[1] + tm[2];
		point.y = x * tm[3] + y * tm[4] + tm[5];
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			obj.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return point;
	},

	/**
	 * Transform a point by this matrix in inverse. The parameter point will be modified with the transformation values.
	 * @param {IgePoint3d} point.
	 * @return {IgePoint3d} The passed point.
	 */
	transformCoordInverse: function(point, obj) {
		var x = point.x,
			y = point.y,
			tm = this.matrix;

		point.x = x * tm[0] - y * tm[1] + tm[2];
		point.y = x * tm[3] + y * tm[4] - tm[5];
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			obj.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return point;
	},

	transform: function (points, obj) {
		var pointIndex,
			pointCount = points.length;

		for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
			this.transformCoord(points[pointIndex], obj);
		}

		return points;
	},

	/**
	 * Create a new rotation matrix and set it up for the specified angle in radians.
	 * @param {Number} angle
	 * @return {IgeMatrix2d} A new matrix object.
	 */
	_newRotate: function(angle) {
		var m = new IgeMatrix2d();
		m.rotateTo(angle);
		return m;
	},

	rotateBy: function(angle) {
		var m = new IgeMatrix2d();

		m.translateBy(this._rotateOrigin.x, this._rotateOrigin.y);
		m.rotateTo(angle);
		m.translateBy(-this._rotateOrigin.x, -this._rotateOrigin.y);

		this.multiply(m);

		return this;
	},

	rotateTo: function (angle) {
		var tm = this.matrix,
			c = Math.cos(angle),
			s = Math.sin(angle);

		tm[0] = c;
		tm[1] = -s;
		tm[3] = s;
		tm[4] = c;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			console.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Gets the rotation from the matrix and returns it in
	 * radians.
	 * @return {Number}
	 */
	rotationRadians: function () {
		return Math.asin(this.matrix[3]);
	},

	/**
	 * Gets the rotation from the matrix and returns it in
	 * degrees.
	 * @return {Number}
	 */
	rotationDegrees: function () {
		return Math.degrees(Math.acos(this.matrix[0]));
	},

	/**
	 * Create a scale matrix.
	 * @param {Number} x X scale magnitude.
	 * @param {Number} y Y scale magnitude.
	 *
	 * @return {IgeMatrix2d} a matrix object.
	 *
	 * @static
	 */
	_newScale: function(x, y) {
		var m = new IgeMatrix2d();

		m.matrix[0] = x;
		m.matrix[4] = y;

		return m;
	},

	scaleBy: function(x, y) {
		var m = new IgeMatrix2d();

		m.matrix[0] = x;
		m.matrix[4] = y;

		this.multiply(m);

		return this;
	},

	scaleTo: function(x, y) {
		var tm = this.matrix;
		//this.identity();
		tm[0] = x;
		tm[4] = y;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			this.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Create a translation matrix.
	 * @param {Number} x X translation magnitude.
	 * @param {Number} y Y translation magnitude.
	 * @return {IgeMatrix2d} A new matrix object.
	 */
	_newTranslate: function (x, y) {
		var m = new IgeMatrix2d();

		m.matrix[2] = x;
		m.matrix[5] = y;

		return m;
	},

	translateBy: function (x, y) {
		var m = new IgeMatrix2d();

		m.matrix[2] = x;
		m.matrix[5] = y;

		this.multiply(m);

		return this;
	},

	/**
	 * Sets this matrix as a translation matrix.
	 * @param x
	 * @param y
	 */
	translateTo: function (x, y) {
		var tm = this.matrix;
		
		tm[2] = x;
		tm[5] = y;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			this.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Copy into this matrix the given matrix values.
	 * @param {IgeMatrix2d} matrix 
	 * @return {Object} "this".
	 */
	copy: function (matrix) {
		matrix = matrix.matrix;

		var tmatrix = this.matrix;
		tmatrix[0] = matrix[0];
		tmatrix[1] = matrix[1];
		tmatrix[2] = matrix[2];
		tmatrix[3] = matrix[3];
		tmatrix[4] = matrix[4];
		tmatrix[5] = matrix[5];
		tmatrix[6] = matrix[6];
		tmatrix[7] = matrix[7];
		tmatrix[8] = matrix[8];

		return this;
	},
	
	compare: function (matrix) {
		var thisMatrix = this.matrix,
			thatMatrix = matrix.matrix;
		
		for (var i = 0; i < 9; i++) {
			if (thisMatrix[i] !== thatMatrix[i]) {
				return false;
			}
		}
		
		return true;
	},

	/**
	 * Set this matrix to the identity matrix.
	 * @return {Object} "this".
	 */
	identity: function() {

		var m = this.matrix;
		m[0] = 1.0;
		m[1] = 0.0;
		m[2] = 0.0;

		m[3] = 0.0;
		m[4] = 1.0;
		m[5] = 0.0;

		m[6] = 0.0;
		m[7] = 0.0;
		m[8] = 1.0;

		return this;
	},

	/**
	 * Multiply this matrix by a given matrix.
	 * @param {IgeMatrix2d} m The IgeMatrix2d to multiply the
	 * current matrix by.
	 * @return {Object} "this".
	 */
	multiply: function (m) {
		var tm = this.matrix,
			mm = m.matrix,

			tm0 = tm[0],
			tm1 = tm[1],
			tm2 = tm[2],
			tm3 = tm[3],
			tm4 = tm[4],
			tm5 = tm[5],
			tm6 = tm[6],
			tm7 = tm[7],
			tm8 = tm[8],

			mm0 = mm[0],
			mm1 = mm[1],
			mm2 = mm[2],
			mm3 = mm[3],
			mm4 = mm[4],
			mm5 = mm[5],
			mm6 = mm[6],
			mm7 = mm[7],
			mm8 = mm[8];

		tm[0] = tm0*mm0 + tm1*mm3 + tm2*mm6;
		tm[1] = tm0*mm1 + tm1*mm4 + tm2*mm7;
		tm[2] = tm0*mm2 + tm1*mm5 + tm2*mm8;
		tm[3] = tm3*mm0 + tm4*mm3 + tm5*mm6;
		tm[4] = tm3*mm1 + tm4*mm4 + tm5*mm7;
		tm[5] = tm3*mm2 + tm4*mm5 + tm5*mm8;
		tm[6] = tm6*mm0 + tm7*mm3 + tm8*mm6;
		tm[7] = tm6*mm1 + tm7*mm4 + tm8*mm7;
		tm[8] = tm6*mm2 + tm7*mm5 + tm8*mm8;

		return this;
	},

	/**
	 * Premultiply this matrix by a given matrix.
	 * @param {IgeMatrix2d} m The IgeMatrix2d to premultiply the
	 * current matrix by.
	 * @return {Object} "this".
	 */
	premultiply: function(m) {

		var m00 = m.matrix[0]*this.matrix[0] + m.matrix[1]*this.matrix[3] + m.matrix[2]*this.matrix[6];
		var m01 = m.matrix[0]*this.matrix[1] + m.matrix[1]*this.matrix[4] + m.matrix[2]*this.matrix[7];
		var m02 = m.matrix[0]*this.matrix[2] + m.matrix[1]*this.matrix[5] + m.matrix[2]*this.matrix[8];

		var m10 = m.matrix[3]*this.matrix[0] + m.matrix[4]*this.matrix[3] + m.matrix[5]*this.matrix[6];
		var m11 = m.matrix[3]*this.matrix[1] + m.matrix[4]*this.matrix[4] + m.matrix[5]*this.matrix[7];
		var m12 = m.matrix[3]*this.matrix[2] + m.matrix[4]*this.matrix[5] + m.matrix[5]*this.matrix[8];

		var m20 = m.matrix[6]*this.matrix[0] + m.matrix[7]*this.matrix[3] + m.matrix[8]*this.matrix[6];
		var m21 = m.matrix[6]*this.matrix[1] + m.matrix[7]*this.matrix[4] + m.matrix[8]*this.matrix[7];
		var m22 = m.matrix[6]*this.matrix[2] + m.matrix[7]*this.matrix[5] + m.matrix[8]*this.matrix[8];

		this.matrix[0] = m00;
		this.matrix[1] = m01;
		this.matrix[2] = m02;

		this.matrix[3] = m10;
		this.matrix[4] = m11;
		this.matrix[5] = m12;

		this.matrix[6] = m20;
		this.matrix[7] = m21;
		this.matrix[8] = m22;


		return this;
	},

	/**
	 * Creates a new inverse matrix from this matrix.
	 * @return {IgeMatrix2d} An inverse matrix.
	 */
	getInverse: function() {
		var tm = this.matrix;

		var m00 = tm[0],
			m01 = tm[1],
			m02 = tm[2],
			m10 = tm[3],
			m11 = tm[4],
			m12 = tm[5],
			m20 = tm[6],
			m21 = tm[7],
			m22 = tm[8],

			newMatrix = new IgeMatrix2d(),
			determinant = m00* (m11*m22 - m21*m12) - m10*(m01*m22 - m21*m02) + m20 * (m01*m12 - m11*m02);

		if  (determinant===0) {
			return null;
		}

		var m = newMatrix.matrix;

		m[0] = m11*m22-m12*m21;
		m[1] = m02*m21-m01*m22;
		m[2] = m01*m12-m02*m11;

		m[3] = m12*m20-m10*m22;
		m[4] = m00*m22-m02*m20;
		m[5] = m02*m10-m00*m12;

		m[6] = m10*m21-m11*m20;
		m[7] = m01*m20-m00*m21;
		m[8] = m00*m11-m01*m10;

		newMatrix.multiplyScalar (1/determinant);

		return newMatrix;
	},

	/**
	 * Multiply this matrix by a scalar.
	 * @param scalar {number} Scalar value.
	 * @return this
	 */
	multiplyScalar: function (scalar) {
		var i;

		for (i=0; i<9; i++) {
			this.matrix[i]*=scalar;
		}

		return this;
	},

	/**
	 * Transforms the passed rendering context by the current matrix
	 * data using the setTransform() method so that the matrix data
	 * is set non-cumulative with the previous matrix data.
	 * @param {CanvasRenderingContext2d} ctx The rendering context to
	 * set the transform matrix for.
	 */
	transformRenderingContextSet: function(ctx) {
		var m = this.matrix;
		ctx.setTransform (m[0], m[3], m[1], m[4], m[2], m[5]);
		return this;
	},

	/**
	 * Transforms the passed rendering context by the current matrix
	 * data using the transform() method so that the matrix data
	 * is set cumulative with the previous matrix data.
	 * @param {CanvasRenderingContext2d} ctx The rendering context to
	 * set the transform matrix for.
	 */
	transformRenderingContext: function(ctx) {
		var m = this.matrix;
		ctx.transform(m[0], m[3], m[1], m[4], m[2], m[5]);
		return this;
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeMatrix2d; };var IgeTimeComponent = IgeEventingClass.extend({
	classId: 'IgeTimeComponent',
	componentId: 'time',
	
	/**
	 * @constructor
	 * @param {Object} entity The parent object that this component is being added to.
	 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._timers = [];
		this._additions = [];
		this._removals = [];

		// Add the animation behaviour to the entity
		entity.addBehaviour('time', this._update);
	},
	
	addTimer: function (timer) {
		if (timer) {
			if (!this._updating) {
				this._timers.push(timer);
			} else {
				this._additions.push(timer);
			}
		}
		
		return this;
	},
	
	removeTimer: function (timer) {
		if (timer) {
			if (!this._updating) {
				this._timers.pull(timer);
			} else {
				this._removals.push(timer);
			}
		}
		
		return this;
	},
	
	_update: function () {
		// Get the ige tick delta and tell our timers / intervals that an update has occurred
		var self = ige.time,
			delta = ige._tickDelta,
			arr = self._timers,
			arrCount = arr.length;
		
		while (arrCount--) {
			arr[arrCount]
				.addTime(delta)
				.update();
		}
		
		// Process removing any timers that were scheduled for removal
		self._processRemovals();
		
		// Now process any additions to the timers that were scheduled to be added
		self._processAdditions();
		
		return self;
	},
	
	_processAdditions: function () {
		var arr = this._additions,
			arrCount = arr.length;
		
		if (arrCount) {
			while (arrCount--) {
				this._timers.push(arr[arrCount]);
			}
			
			this._additions = [];
		}
		
		return this;
	},
	
	_processRemovals: function () {
		var arr = this._removals,
			arrCount = arr.length;
		
		if (arrCount) {
			while (arrCount--) {
				this._timers.pull(arr[arrCount]);
			}
			
			this._removals = [];
		}
		
		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTimeComponent; };/**
 * This component is already included in the IgeEngine (ige)
 * instance and is not designed for use in any other way!
 * It handles global tween processing on all tweening values.
 */
var IgeTweenComponent = IgeClass.extend({
	classId: 'IgeTweenComponent',
	componentId: 'tween',

	init: function (entity, options) {
		this._entity = entity;
		this._transform = entity.transform;

		// Setup the array that will hold our active tweens
		this._tweens = [];

		// Add the tween behaviour to the entity 
		entity.addBehaviour('tween', this.update);
	},

	/**
	 * Start tweening particular properties for the object.
	 * @param {IgeTween} tween The tween to start.
	 * @return {Number} The index of the added tween or -1 on error.
	 */
	start: function (tween) {
		if (tween._startTime > ige._currentTime) {
			// The tween is scheduled for later
			// Push the tween into the IgeTweenComponent's _tweens array
			this._tweens.push(tween);
		} else {
			// The tween should start immediately
			tween._currentStep = 0;
			
			// Setup the tween's step
			if (this._setupStep(tween, false)) {
				// Push the tween into the IgeTweenComponent's _tweens array
				this._tweens.push(tween);
			}
		}

		// Enable tweening on the IgeTweenComponent
		this.enable();

		// Return the tween
		return tween;
	},

	_setupStep: function (tween, newTime) {
		var targetObj = tween._targetObj,
			step = tween._steps[tween._currentStep],
			propertyNameAndValue, // = tween._propertyObj
			durationMs,
			endTime,
			easing,
			propertyIndex,
			targetData = [];

		if (step) {
			propertyNameAndValue = step.props;
		}

		if (targetObj) {
			// Check / fill some option defaults
			if (tween._currentStep === 0 && !newTime) {
				// Because we are on step zero we can check for a start time
				if (tween._startTime === undefined) {
					tween._startTime = ige._currentTime;
				}
			} else {
				// We're not on step zero anymore so the new step start time
				// is NOW!
				tween._startTime = ige._currentTime;
			}

			durationMs = step.durationMs ? step.durationMs : tween._durationMs;
			tween._selectedEasing = step.easing ? step.easing : tween._easing;

			// Calculate the end time
			tween._endTime = tween._startTime + durationMs;

			for (propertyIndex in propertyNameAndValue) {
				if (propertyNameAndValue.hasOwnProperty(propertyIndex)) {
					targetData.push({
						targetObj: targetObj,
						propName: propertyIndex,
						deltaVal: propertyNameAndValue[propertyIndex] - (step.isDelta ? 0 : targetObj[propertyIndex]), // The diff between end and start values
						oldDelta: 0 // Var to save the old delta in order to get the actual difference data.
					});
				}
			}

			tween._targetData = targetData;
			tween._destTime = tween._endTime - tween._startTime;

			return tween; // Return the tween
		} else {
			this.log('Cannot start tweening properties of the specified object "' + obj + '" because it does not exist!', 'error');
		}
	},

	/**
	 * Removes the specified tween from the active tween list.
	 * @param {IgeTween} tween The tween to stop.
	 */
	stop: function (tween) {
		// Store the new tween details in the item
		this._tweens.pull(tween);

		if (!this._tweens.length) {
			// Disable tweening on this item as there are
			// no more tweens to process
			this.disable();
		}
		
		return this;
	},

	/**
	 * Stop all tweening for the object.
	 */
	stopAll: function () {
		// Disable tweening
		this.disable();

		// Remove all tween details
		delete this._tweens;
		this._tweens = [];

		return this;
	},

	/**
	 * Enable tweening for the object.
	 */
	enable: function () {
		// Check if the item is currently tweening
		if (!this._tweening) {
			// Set the item to tweening
			this._tweening = true;
		}

		return this;
	},

	/**
	 * Disable tweening for the object.
	 */
	disable: function () {
		// Check if the item is currently tweening
		if (this._tweening) {
			// Set the item to not tweening
			this._tweening = false;
		}

		return this;
	},

	/**
	 * Process tweening for the object.
	 */
	update: function (ctx) {
		var thisTween = this.tween;
		if (thisTween._tweens && thisTween._tweens.length) {
			var currentTime = ige._tickStart,
				tweens = thisTween._tweens,
				tweenCount = tweens.length,
				tween,
				deltaTime,
				destTime,
				easing,
				item,
				targetProp,
				targetPropVal,
				targets,
				targetIndex,
				stepIndex,
				stopped,
				currentDelta;

			// Loop the item's tweens
			while (tweenCount--) {
				tween = tweens[tweenCount];
				stopped = false;

				// Check if we should be starting this tween yet
				if (tween._started || currentTime >= tween._startTime) {
					if (!tween._started) {
						// Check if the tween's step is -1 indicating no step
						// data has been set up yet
						if (tween._currentStep === -1) {
							// Setup the tween step now
							tween._currentStep = 0;
							thisTween._setupStep(tween, false);
						}
						
						// Check if we have a beforeTween callback to fire
						if (typeof(tween._beforeTween) === 'function') {
							// Fire the beforeTween callback
							tween._beforeTween(tween);

							// Delete the callback so we don't store it any longer
							delete tween._beforeTween;
						}

						// Check if we have a beforeStep callback to fire
						if (typeof(tween._beforeStep) === 'function') {
							// Fire the beforeStep callback
							if (tween._stepDirection) {
								stepIndex = tween._steps.length - (tween._currentStep + 1);
							} else {
								stepIndex = tween._currentStep;
							}
							tween._beforeStep(tween, stepIndex);
						}

						tween._started = true;
					}

					deltaTime = currentTime - tween._startTime; // Delta from start time to current time
					destTime = tween._destTime;
					easing = tween._selectedEasing;

					// Check if the tween has reached it's destination based upon
					// the current time
					if (deltaTime >= destTime) {
						// The tween time indicates the tween has ended so set to
						// the ending value
						targets = tween._targetData;

						for (targetIndex in targets) {
							if (targets.hasOwnProperty(targetIndex)) {
								item = targets[targetIndex];
								targetProp = item.targetObj;
								targetPropVal = targetProp[item.propName];
								
								// Check if the destination time is not zero
								// because otherwise the easing method will provide
								// a divide by zero error resulting in a NaN value
								if (destTime !== 0) {
									// Add the delta amount to destination
									currentDelta = thisTween.easing[easing](
										destTime,
										item.deltaVal,
										destTime
									);
								} else {
									currentDelta = item.deltaVal;
								}
								
								targetPropVal += currentDelta - item.oldDelta;
								
								// Round the value to correct floating point operation imprecision
								var roundingPrecision = Math.pow(10, 15-(targetPropVal.toFixed(0).toString().length));
								targetProp[item.propName] = Math.round(targetPropVal * roundingPrecision)/roundingPrecision;
							}
						}

						// Check if we have a afterStep callback to fire
						if (typeof(tween._afterStep) === 'function') {
							// Fire the afterStep
							if (tween._stepDirection) {
								stepIndex = tween._steps.length - (tween._currentStep + 1);
							} else {
								stepIndex = tween._currentStep;
							}
							tween._afterStep(tween, stepIndex);
						}

						if (tween._steps.length === tween._currentStep + 1) {
							// The tween has ended, is the tween repeat mode enabled?
							if (tween._repeatMode) {
								// We have a repeat mode, lets check for a count
								if (tween._repeatCount !== -1) {
									// Check if the repeat count has reached the
									// number of repeats we wanted
									tween._repeatedCount++;
									if (tween._repeatCount === tween._repeatedCount) {
										// The tween has ended
										stopped = true;
									}
								}

								if (!stopped) {
									// Work out what mode we're running on
									if (tween._repeatMode === 1) {
										tween._currentStep = 0;
									}

									if (tween._repeatMode === 2) {
										// We are on "reverse loop" mode so now
										// reverse the tween's steps and then
										// start from step zero
										tween._stepDirection = !tween._stepDirection;
										tween._steps.reverse();

										tween._currentStep = 1;
									}

									// Check if we have a stepsComplete callback to fire
									if (typeof(tween._stepsComplete) === 'function') {
										// Fire the stepsComplete callback
										tween._stepsComplete(tween, tween._currentStep);
									}

									// Check if we have a beforeStep callback to fire
									if (typeof(tween._beforeStep) === 'function') {
										// Fire the beforeStep callback
										if (tween._stepDirection) {
											stepIndex = tween._steps.length - (tween._currentStep + 1);
										} else {
											stepIndex = tween._currentStep;
										}
										tween._beforeStep(tween, stepIndex);
									}

									thisTween._setupStep(tween, true);
								}
							} else {
								stopped = true;
							}

							if (stopped) {
								// Now stop tweening this tween
								tween.stop();

								// If there is a callback, call it
								if (typeof(tween._afterTween) === 'function') {
									// Fire the afterTween callback
									tween._afterTween(tween);

									// Delete the callback so we don't store it any longer
									delete tween._afterTween;
								}
							}
						} else {
							// Start the next step
							tween._currentStep++;

							// Check if we have a beforeStep callback to fire
							if (typeof(tween._beforeStep) === 'function') {
								// Fire the beforeStep callback
								if (tween._stepDirection) {
									stepIndex = tween._steps.length - (tween._currentStep + 1);
								} else {
									stepIndex = tween._currentStep;
								}
								tween._beforeStep(tween, stepIndex);
							}

							thisTween._setupStep(tween, true);
						}
						
						if (typeof(tween._afterChange) === 'function') {
							tween._afterChange(tween, stepIndex);
						}
					} else {
						// The tween is still active, process the tween by passing it's details
						// to the selected easing method
						targets = tween._targetData;

						for (targetIndex in targets) {
							if (targets.hasOwnProperty(targetIndex)) {
								item = targets[targetIndex];
								var currentDelta = thisTween.easing[easing](
									deltaTime,
									item.deltaVal,
									destTime
								);
								item.targetObj[item.propName] += currentDelta - item.oldDelta;
								item.oldDelta = currentDelta;
							}
						}
						
						if (typeof(tween._afterChange) === 'function') {
							tween._afterChange(tween, stepIndex);
						}
					}
				}
			}
		}
	},

	/** tweenEasing - Contains all the tween easing functions. {
		category:"property",
		type:"object",
	} **/
	easing: {
		// Easing equations converted from AS to JS from original source at
		// http://robertpenner.com/easing/
		none: function(t, c, d) {
			return c*t/d;
		},
		inQuad: function(t, c, d) {
			return c*(t/=d)*t;
		},
		outQuad: function(t, c, d) {
			return -c *(t/=d)*(t-2);
		},
		inOutQuad: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t; }
			return -c/2 *((--t)*(t-2) - 1);
		},
		inCubic: function(t, c, d) {
			return c*(t/=d)*t*t;
		},
		outCubic: function(t, c, d) {
			return c*((t=t/d-1)*t*t + 1);
		},
		inOutCubic: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t; }
			return c/2*((t-=2)*t*t + 2);
		},
		outInCubic: function(t, c, d) {
			if(t < d/2) { return this.outCubic(t*2, c/2, d); }
			return this.inCubic((t*2)-d, c/2, c/2, d);
		},
		inQuart: function(t, c, d) {
			return c*(t/=d)*t*t*t;
		},
		outQuart: function(t, c, d) {
			return -c *((t=t/d-1)*t*t*t - 1);
		},
		inOutQuart: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t*t; }
			return -c/2 *((t-=2)*t*t*t - 2);
		},
		outInQuart: function(t, c, d) {
			if(t < d/2) { return this.outQuart(t*2, c/2, d); }
			return this.inQuart((t*2)-d, c/2, c/2, d);
		},
		inQuint: function(t, c, d) {
			return c*(t/=d)*t*t*t*t;
		},
		outQuint: function(t, c, d) {
			return c*((t=t/d-1)*t*t*t*t + 1);
		},
		inOutQuint: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t*t*t; }
			return c/2*((t-=2)*t*t*t*t + 2);
		},
		outInQuint: function(t, c, d) {
			if(t < d/2) { return this.outQuint(t*2, c/2, d); }
			return this.inQuint((t*2)-d, c/2, c/2, d);
		},
		inSine: function(t, c, d) {
			return -c * Math.cos(t/d *(Math.PI/2)) + c;
		},
		outSine: function(t, c, d) {
			return c * Math.sin(t/d *(Math.PI/2));
		},
		inOutSine: function(t, c, d) {
			return -c/2 *(Math.cos(Math.PI*t/d) - 1);
		},
		outInSine: function(t, c, d) {
			if(t < d/2) { return this.outSine(t*2, c/2, d); }
			return this.inSine((t*2)-d, c/2, c/2, d);
		},
		inExpo: function(t, c, d) {
			return(t === 0) ? 0 : c * Math.pow(2, 10 *(t/d - 1)) - c * 0.001;
		},
		outExpo: function(t, c, d) {
			return(t === d) ? c : c * 1.001 *(-Math.pow(2, -10 * t/d) + 1);
		},
		inOutExpo: function(t, c, d) {
			if(t === 0) { return 0; }
			if(t === d) { return c; }
			if((t/=d/2) < 1) { return c/2 * Math.pow(2, 10 *(t - 1)) - c * 0.0005; }
			return c/2 * 1.0005 *(-Math.pow(2, -10 * --t) + 2);
		},
		outInExpo: function(t, c, d) {
			if(t < d/2) { return this.outExpo(t*2, c/2, d); }
			return this.inExpo((t*2)-d, c/2, c/2, d);
		},
		inCirc: function(t, c, d) {
			return -c *(Math.sqrt(1 -(t/=d)*t) - 1);
		},
		outCirc: function(t, c, d) {
			return c * Math.sqrt(1 -(t=t/d-1)*t);
		},
		inOutCirc: function(t, c, d) {
			if((t/=d/2) < 1) { return -c/2 *(Math.sqrt(1 - t*t) - 1); }
			return c/2 *(Math.sqrt(1 -(t-=2)*t) + 1);
		},
		outInCirc: function(t, c, d) {
			if(t < d/2) { return this.outCirc(t*2, c/2, d); }
			return this.inCirc((t*2)-d, c/2, c/2, d);
		},
		inElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) {return 0;}
			if((t/=d)===1) { return c; }
			if(!p) { p=d*0.3; }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p ));
		},
		outElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) { return 0; }
			if((t/=d)===1) { return c; }
			if(!p) { p=d*0.3; }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			return(a*Math.pow(2,-10*t) * Math.sin((t*d-s)*(2*Math.PI)/p ) + c);
		},
		inOutElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) { return 0; }
			if((t/=d/2)===2) { return c; }
			if(!p) { p=d*(0.3*1.5); }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			if(t < 1) { return -0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p)); }
			return a*Math.pow(2,-10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p )*0.5 + c;
		},
		outInElastic: function(t, c, d, a, p) {
			if(t < d/2) { return this.outElastic(t*2, c/2, d, a, p); }
			return this.inElastic((t*2)-d, c/2, c/2, d, a, p);
		},
		inBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			return c*(t/=d)*t*((s+1)*t - s);
		},
		outBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			return c*((t=t/d-1)*t*((s+1)*t + s) + 1);
		},
		inOutBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			if((t/=d/2) < 1) { return c/2*(t*t*(((s*=(1.525))+1)*t - s)); }
			return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
		},
		outInBack: function(t, c, d, s) {
			if(t < d/2) { return this.outBack(t*2, c/2, d, s); }
			return this.inBack((t*2)-d, c/2, c/2, d, s);
		},
		inBounce: function(t, c, d) {
			return c - this.outBounce(d-t, 0, c, d);
		},
		outBounce: function(t, c, d) {
			if((t/=d) <(1/2.75)) {
				return c*(7.5625*t*t);
			} else if(t <(2/2.75)) {
				return c*(7.5625*(t-=(1.5/2.75))*t + 0.75);
			} else if(t <(2.5/2.75)) {
				return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375);
			} else {
				return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375);
			}
		},
		inOutBounce: function(t, c, d) {
			if(t < d/2) {
				return this.inBounce(t*2, 0, c, d) * 0.5;
			} else {
				return this.outBounce(t*2-d, 0, c, d) * 0.5 + c*0.5;
			}
		},
		outInBounce: function(t, c, d) {
			if(t < d/2) { return this.outBounce(t*2, c/2, d); }
			return this.inBounce((t*2)-d, c/2, c/2, d);
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTweenComponent; };var IgeInputComponent = IgeEventingClass.extend({
	classId: 'IgeInputComponent',
	componentId: 'input',

	init: function () {
		// Setup the input objects to hold the current input state
		this._eventQueue = [];
		this._eventControl = {
			_cancelled: false,
			stopPropagation: function () {
				this._cancelled = true;
			}
		};

		this.tick();

		this.mouse = {
			// Virtual codes
			dblClick: -302,
			down: -301,
			up: -300,
			move: -259,
			wheel: -258,
			wheelUp: -257,
			wheelDown: -256,
			x: -255,
			y: -254,
			button1: -253,
			button2: -252,
			button3: -251
		};

		this.pad1 = {
			// Virtual codes
			button1: -250,
			button2: -249,
			button3: -248,
			button4: -247,
			button5: -246,
			button6: -245,
			button7: -244,
			button8: -243,
			button9: -242,
			button10: -241,
			button11: -240,
			button12: -239,
			button13: -238,
			button14: -237,
			button15: -236,
			button16: -235,
			button17: -234,
			button18: -233,
			button19: -232,
			button20: -231,
			stick1: -230,
			stick2: -229,
			stick1Up: -228,
			stick1Down: -227,
			stick1Left: -226,
			stick1Right: -225,
			stick2Up: -224,
			stick2Down: -223,
			stick2Left: -222,
			stick2Right: -221
		};

		this.pad2 = {
			// Virtual codes
			button1: -220,
			button2: -219,
			button3: -218,
			button4: -217,
			button5: -216,
			button6: -215,
			button7: -214,
			button8: -213,
			button9: -212,
			button10: -211,
			button11: -210,
			button12: -209,
			button13: -208,
			button14: -207,
			button15: -206,
			button16: -205,
			button17: -204,
			button18: -203,
			button19: -202,
			button20: -201,
			stick1: -200,
			stick2: -199,
			stick1Up: -198,
			stick1Down: -197,
			stick1Left: -196,
			stick1Right: -195,
			stick2Up: -194,
			stick2Down: -193,
			stick2Left: -192,
			stick2Right: -191
		};

		// Keycodes from http://www.asciitable.com/
		// and general console.log efforts :)
		this.key = {
			// Virtual codes
			'shift': -3,
			'ctrl': -2,
			'alt': -1,
			// Read codes
			'backspace': 8,
			'tab': 9,
			'enter': 13,
			'escape': 27,
			'space': 32,
			'pageUp': 33,
			'pageDown': 34,
			'end': 35,
			'home': 36,
			'left': 37,
			'up': 38,
			'right': 39,
			'down': 40,
			'insert': 45,
			'del': 46,
			'0': 48,
			'1': 49,
			'2': 50,
			'3': 51,
			'4': 52,
			'5': 53,
			'6': 54,
			'7': 55,
			'8': 56,
			'9': 57,
			'a': 65,
			'b': 66,
			'c': 67,
			'd': 68,
			'e': 69,
			'f': 70,
			'g': 71,
			'h': 72,
			'i': 73,
			'j': 74,
			'k': 75,
			'l': 76,
			'm': 77,
			'n': 78,
			'o': 79,
			'p': 80,
			'q': 81,
			'r': 82,
			's': 83,
			't': 84,
			'u': 85,
			'v': 86,
			'w': 87,
			'x': 88,
			'y': 89,
			'z': 90
		};

		this._controlMap = [];
		this._state = [];

		// Set default values for the mouse position
		this._state[this.mouse.x] = 0;
		this._state[this.mouse.y] = 0;
	},

	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this;
		}

		return this._debug;
	},

	/**
	 * Sets up the event listeners on the main window and front
	 * buffer DOM objects.
	 * @private
	 */
	setupListeners: function (canvas) {
		this.log('Setting up input event listeners...');

		this._canvas = canvas;

		// Setup the event listeners
		var self = this;

		// Define event functions and keep references for later removal
		this._evRef = {
			'mousedown': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseDown(event); },
			'mouseup': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseUp(event); },
			'mousemove': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseMove(event); },
			'mousewheel': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseWheel(event); },

			'touchmove': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseMove(event); },
			'touchstart': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseDown(event); },
			'touchend': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseUp(event); },

			'contextmenu': function (event) { event.preventDefault(); event.igeType = 'mouse'; self._rationalise(event); self._contextMenu(event); },

			'keydown': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyDown(event); },
			'keyup': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyUp(event); }
		};

		// Listen for mouse events
		canvas.addEventListener('mousedown', this._evRef.mousedown, false);
		canvas.addEventListener('mouseup', this._evRef.mouseup, false);
		canvas.addEventListener('mousemove', this._evRef.mousemove, false);
		canvas.addEventListener('mousewheel', this._evRef.mousewheel, false);

		// Touch events
		canvas.addEventListener('touchmove', this._evRef.touchmove, false);
		canvas.addEventListener('touchstart', this._evRef.touchstart, false);
		canvas.addEventListener('touchend', this._evRef.touchend, false);

		// Kill the context menu on right-click, urgh!
		canvas.addEventListener('contextmenu', this._evRef.contextmenu, false);

		// Listen for keyboard events
		window.addEventListener('keydown', this._evRef.keydown, false);
		window.addEventListener('keyup', this._evRef.keyup, false);
	},

	destroyListeners: function () {
		this.log('Removing input event listeners...');

		// Remove the event listeners
		var canvas = this._canvas;

		// Listen for mouse events
		canvas.removeEventListener('mousedown', this._evRef.mousedown, false);
		canvas.removeEventListener('mouseup', this._evRef.mouseup, false);
		canvas.removeEventListener('mousemove', this._evRef.mousemove, false);
		canvas.removeEventListener('mousewheel', this._evRef.mousewheel, false);

		// Touch events
		canvas.removeEventListener('touchmove', this._evRef.touchmove, false);
		canvas.removeEventListener('touchstart', this._evRef.touchstart, false);
		canvas.removeEventListener('touchend', this._evRef.touchend, false);

		// Kill the context menu on right-click, urgh!
		canvas.removeEventListener('contextmenu', this._evRef.contextmenu, false);

		// Listen for keyboard events
		window.removeEventListener('keydown', this._evRef.keydown, false);
		window.removeEventListener('keyup', this._evRef.keyup, false);
	},

	/**
	 * Fires an input event that didn't occur on the main canvas, as if it had
	 * occurred on the main canvas, allowing you to pass through events like
	 * mousedown and mouseup that occurred elsewhere on the DOM but might be
	 * useful for the engine to be aware of, such as if you are dragging an entity
	 * and then the mouse goes off-canvas and the button is released.
	 * @param {String} eventName The lowercase name of the event to fire e.g. mousedown.
	 * @param {Object} eventObj The event object that was passed by the DOM.
	 */
	fireManualEvent: function (eventName, eventObj) {
		if (eventName && eventObj) {
			if (this._evRef[eventName]) {
				this._evRef[eventName](eventObj);
			} else {
				this.log('Cannot fire manual event "' + eventName + '" because no listener exists in the engine for this event type!', 'warning');
			}
		} else {
			this.log('Cannot fire manual event because both eventName and eventObj params are required.', 'warning');
		}
	},

	/**
	 * Sets igeX and igeY properties in the event object that
	 * can be relied on to provide the x, y co-ordinates of the
	 * mouse event including the canvas offset.
	 * @param {Event} event The event object.
	 * @param {Boolean} touch If the event was a touch event or
	 * not.
	 * @private
	 */
	_rationalise: function (event, touch) {
		// Check if we want to prevent default behaviour
		if (event.igeType === 'key') {
			if (event.keyCode === 8) { // Backspace
				// Check if the event occurred on the body
				var elem = event.srcElement || event.target;

				if (elem.tagName.toLowerCase() === 'body') {
					// The event occurred on our body element so prevent
					// default behaviour. This allows other elements on
					// the page to retain focus such as text boxes etc
					// and allows them to behave normally.
					event.preventDefault();
				}
			}
		}

		if (event.igeType === 'touch') {
			event.preventDefault();
		}

		if (touch) {
			event.button = 0; // Emulate left mouse button

			// Handle touch changed
			if (event.changedTouches && event.changedTouches.length) {
				event.igePageX = event.changedTouches[0].pageX;
				event.igePageY = event.changedTouches[0].pageY;
			}
		} else {
			event.igePageX = event.pageX;
			event.igePageY = event.pageY;
		}

		event.igeX = (event.igePageX - ige.rendering._canvasPosition().left);
		event.igeY = (event.igePageY - ige.rendering._canvasPosition().top);

		this.emit('inputEvent', event);
	},


	/**
	 * Emits the "mouseDown" event.
	 * @param event
	 * @private
	 */
	_mouseDown: function (event) {
		if (this._debug) {
			console.log('Mouse Down', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = true;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = true;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = true;
		}

		this.mouseDown = event;

		if (!self.emit('preMouseDown', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseDown', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseUp" event.
	 * @param event
	 * @private
	 */
	_mouseUp: function (event) {
		if (this._debug) {
			console.log('Mouse Up', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = false;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = false;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = false;
		}

		this.mouseUp = event;
		
		if (!self.emit('preMouseUp', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseUp', [event, mx, my, event.button + 1]);
			});
		}
	},
	
	_contextMenu: function (event) {
		if (this._debug) {
			console.log('Context Menu', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = false;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = false;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = false;
		}

		this.contextMenu = event;
		
		if (!self.emit('preContextMenu', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('contextMenu', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseMove" event.
	 * @param event
	 * @private
	 */
	_mouseMove: function (event) {
		// Update the mouse position within the viewports
		ige._mouseOverVp = this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		this._state[this.mouse.x] = mx;
		this._state[this.mouse.y] = my;

		this.mouseMove = event;

		if (!self.emit('preMouseMove', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseMove', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseWheel" event.
	 * @param event
	 * @private
	 */
	_mouseWheel: function (event) {
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		this._state[this.mouse.wheel] = event.wheelDelta;

		if (event.wheelDelta > 0) {
			this._state[this.mouse.wheelUp] = true;
		} else {
			this._state[this.mouse.wheelDown] = true;
		}

		this.mouseWheel = event;

		if (!self.emit('preMouseWheel', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseWheel', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "keyDown" event.
	 * @param event
	 * @private
	 */
	_keyDown: function (event) {
		var self = this;

		this._state[event.keyCode] = true;
		
		if (this._debug) {
			console.log('Key Down', event);
		}
		
		if (!self.emit('preKeyDown', [event, event.keyCode])) {
			this.queueEvent(this, function () {
				self.emit('keyDown', [event, event.keyCode]);
			});
		}
	},

	/**
	 * Emits the "keyUp" event.
	 * @param event
	 * @private
	 */
	_keyUp: function (event) {
		var self = this;

		this._state[event.keyCode] = false;
		
		if (this._debug) {
			console.log('Key Up', event);
		}
		
		if (!self.emit('preKeyUp', [event, event.keyCode])) {
			this.queueEvent(this, function () {
				self.emit('keyUp', [event, event.keyCode]);
			});
		}
	},

	/**
	 * Loops the mounted viewports and updates their respective mouse
	 * co-ordinates so that mouse events can work out where on a viewport
	 * they occurred.
	 *
	 * @param event
	 * @return {*}
	 * @private
	 */
	_updateMouseData: function (event) {
		// Loop the viewports and check if the mouse is inside
		var arr = ige._children,
			arrCount = arr.length,
			vp, vpUpdated,
			mx = (event.igeX - ige._bounds2d.x2) - ige._translate.x,
			my = (event.igeY - ige._bounds2d.y2) - ige._translate.y;

		ige._mousePos.x = mx;
		ige._mousePos.y = my;

		while (arrCount--) {
			vp = arr[arr.length - (arrCount + 1)];
			// Check if the mouse is inside this viewport's bounds
			// TODO: Update this code to take into account viewport rotation and camera rotation
			if (mx > vp._translate.x - vp._bounds2d.x / 2 && mx < vp._translate.x + vp._bounds2d.x / 2) {
				if (my > vp._translate.y - vp._bounds2d.y / 2 && my < vp._translate.y + vp._bounds2d.y / 2) {
					// Mouse is inside this viewport
					vp._mousePos = new IgePoint3d(
						Math.floor((mx - vp._translate.x) / vp.camera._scale.x + vp.camera._translate.x),
						Math.floor((my - vp._translate.y) / vp.camera._scale.y + vp.camera._translate.y),
						0
					);

					vpUpdated = vp;

					// Record the viewport that this event occurred on in the
					// event object
					event.igeViewport = vp;
					break;
				}
			}
		}

		return vpUpdated;
	},

	/**
	 * Defines an action that will be emitted when the specified event type
	 * occurs.
	 * @param actionName
	 * @param eventCode
	 */
	mapAction: function (actionName, eventCode) {
		this._controlMap[actionName] = eventCode;
	},

	/**
	 * Returns the passed action's input state value.
	 * @param actionName
	 */
	actionVal: function (actionName) {
		return this._state[this._controlMap[actionName]];
	},

	/**
	 * Returns true if the passed action's input is pressed or it's state
	 * is not zero.
	 * @param actionName
	 */
	actionState: function (actionName) {
		var val = this._state[this._controlMap[actionName]];
		return !!val; // "Not not" to convert to boolean true/false
	},

	/**
	 * Returns an input's current value.
	 * @param actionName
	 * @return {*}
	 */
	val: function (inputId) {
		return this._state[inputId];
	},

	/**
	 * Returns an input's current state as a boolean.
	 * @param stateId
	 * @return {Boolean}
	 */
	state: function (inputId) {
		return !!this._state[inputId];
	},

	/**
	 * Stops further event propagation for this tick.
	 * @return {*}
	 */
	stopPropagation: function () {
		this._eventControl._cancelled = true;
		return this;
	},

	/**
	 * Adds an event method to the eventQueue array. The array is
	 * processed during each tick after the scenegraph has been
	 * rendered.
	 * @param context
	 * @param ev
	 */
	queueEvent: function (context, ev, data) {
		if (ev !== undefined) {
			this._eventQueue.push([context, ev, data]);
		}

		return this;
	},

	/**
	 * Called by the engine after ALL other tick methods have processed.
	 * Call originates in IgeEngine.js. Allows us to reset any flags etc.
	 */
	tick: function () {
		// If we have an event queue, process it
		var arr = this._eventQueue,
			arrCount = arr.length,
			evc = this._eventControl;

		while (arrCount--) {
			arr[arrCount][1].apply(arr[arrCount][0], [evc, arr[arrCount][2]]);
			if (evc._cancelled) {
				// The last event queue method stopped propagation so cancel all further
				// event processing (the last event took control of the input)
				break;
			}
		}

		// Reset all the flags and variables for the next tick
		this._eventQueue = [];
		this._eventControl._cancelled = false;
		this.dblClick = false; // TODO: Add double-click event handling
		this.mouseMove = false;
		this.mouseDown = false;
		this.mouseUp = false;
		this.mouseWheel = false;
	},

	/**
	 * Emit an event by name. Overrides the IgeEventingClass emit method and
	 * checks for propagation stopped by calling ige.input.stopPropagation().
	 * @param {Object} eventName The name of the event to emit.
	 * @param {Object || Array} args The arguments to send to any listening methods.
	 * If you are sending multiple arguments, use an array containing each argument.
	 * @return {Number}
	 */
	emit: function (eventName, args) {
		if (this._eventListeners) {
			// Check if the event has any listeners
			if (this._eventListeners[eventName]) {

				// Fire the listeners for this event
				var eventCount = this._eventListeners[eventName].length,
					eventCount2 = this._eventListeners[eventName].length - 1,
					evc = this._eventControl,
					finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;

				// If there are some events, ensure that the args is ready to be used
				if (eventCount) {
					finalArgs = [];
					if (typeof(args) === 'object' && args !== null && args[0] !== null) {
						for (i in args) {
							if (args.hasOwnProperty(i)) {
								finalArgs[i] = args[i];
							}
						}
					} else {
						finalArgs = [args];
					}

					// Loop and emit!
					cancelFlag = false;

					this._eventListeners._processing = true;
					while (eventCount--) {
						if (evc._cancelled) {
							// The stopPropagation() method was called, cancel all other event calls
							break;
						}
						eventIndex = eventCount2 - eventCount;
						tempEvt = this._eventListeners[eventName][eventIndex];

						// If the sendEventName flag is set, overwrite the arguments with the event name
						if (tempEvt.sendEventName) { finalArgs = [eventName]; }

						// Call the callback
						retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);

						// If the retVal === true then store the cancel flag and return to the emitting method
						if (retVal === true || evc._cancelled === true) {
							// The receiver method asked us to send a cancel request back to the emitter
							cancelFlag = true;
						}

						// Check if we should now cancel the event
						if (tempEvt.oneShot) {
							// The event has a oneShot flag so since we have fired the event,
							// lets cancel the listener now
							this.off(eventName, tempEvt);
						}
					}
					this._eventListeners._processing = false;

					// Now process any event removal
					this._processRemovals();

					if (cancelFlag) {
						return 1;
					}

				}

			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeInputComponent; }
;var IgeEntityManager = IgeEventingClass.extend({
	classId: 'IgeEntityManager',
	componentId: 'entityManager',
	
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;
		
		// Create queue arrays that will store entities waiting to
		// be mounted or unmounted
		this._mountQueue = [];
		this._unMountQueue = [];
		this._maxMountsPerOp = 0;
		this._maxUnMountsPerOp = 0;
			
		// Create the _orphans array on the entity
		entity._orphans = [];
		
		// Set a method (behaviour) that will be called on every update
		entity.addBehaviour('entManager', this._updateBehaviour, false);
	},

	/**
	 * Called each update frame from the component parent and calls various private
	 * methods to ensure that entities that should be mounted are mounted and those
	 * that are to be unmounted are unmounted.
	 * @private
	 */
	_updateBehaviour: function (ctx) {
		// Draw visible area rect
		//var rect = ige._currentViewport.viewArea();
		
		/*new IgeEntity()
			.id('visArea')
			.texture(this.gameTexture.simpleBox)
			.opacity(0.5)
			.mount(ige.$('objectScene'));*/
		
		/*ige.$('visArea')
			.translateTo(rect.x + (rect.width / 2), rect.y + (rect.height / 2), 0)
			.height(rect.height)
			.width(rect.width);*/
		
		// Get our instance back
		var self = this.entityManager;
		
		self._updateOrphans();
		self._updateChildren();
		
		self._processMountQueue();
		self._processUnMountQueue();
	},

	/**
	 * Checks all the mounted entities of our component parent are still supposed
	 * to be in the scenegraph and if not, adds them to the un-mount queue. Also
	 * marks any entities that are non-managed but also off-screen as inView = false.
	 * @private
	 */
	_updateOrphans: function () {
		var arr = this._entity._children,
			arrCount = arr.length,
			viewportArr = ige._children,
			vpCount = viewportArr.length,
			item,
			itemAabb,
			vpIndex,
			inVisibleArea;
		
		while (arrCount--) {
			item = arr[arrCount];

			if (item._managed) {
				if (item.aabb) {
					if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
						itemAabb = item.bounds3dPolygon().aabb();
					} else {
						itemAabb = item.aabb();
					}
					
					inVisibleArea = false;
					
					// Check the entity to see if its bounds are "inside" any
					// viewport's visible area
					for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
						if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
							inVisibleArea = true;
							break;
						}
					}
					
					if (!inVisibleArea) {
						// Check for managed mode 1 (static entities that can be unmounted)
						// or managed mode 2 (dynamic and should just be marked as inView = false)
						if (item._managed === 1) {
							// The entity is not inside the viewport visible area
							// and is managed mode 1 (static) so unmount it
							this._unMountQueue.push(item);
						} else if (item._managed === 2) {
							// The entity is dynamic so mark is as inView = false
							item._inView = false;
						}
					} else if (item._managed === 2) {
						// The entity is dynamic so mark is as inView = true
						item._inView = true;
					}
				} else {
					this._unMountQueue.push(item);
				}
			}
		}
	},
	
	/**
	 * Checks all the un-mounted entities of our component parent to see if they are
	 * now inside the visible area of a viewport and if so, queues them for re-mounting.
	 * @private
	 */
	_updateChildren: function () {
		var arr = this._entity._orphans,
			arrCount = arr.length,
			viewportArr = ige._children,
			vpCount = viewportArr.length,
			item,
			itemAabb,
			vpIndex,
			inVisibleArea;
		
		while (arrCount--) {
			item = arr[arrCount];

			if (item._managed) {
				if (item.aabb) {
					if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
						itemAabb = item.bounds3dPolygon().aabb();
					} else {
						itemAabb = item.aabb();
					}
					
					inVisibleArea = false;
					
					// Check the entity to see if its bounds are "inside" any
					// viewport's visible area
					for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
						if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
							inVisibleArea = true;
							break;
						}
					}
					
					if (inVisibleArea) {
						// Check for managed mode 1 (static entities that can be mounted)
						// or managed mode 2 (dynamic and should just be marked as inView = true)
						if (item._managed === 1) {
							// The entity is inside the viewport visible area
							// and is managed mode 1 (static) so mount it
							this._mountQueue.push(item);
						} else if (item._managed === 2) {
							// The entity is dynamic so mark is as inView = true
							item._inView = true;
						}
					}
				} else {
					this._mountQueue.push(item);
				}
			}
		}
	},

	/**
	 * Loops any entities queued for mounting and mounts them.
	 * @private
	 */
	_processMountQueue: function () {
		var arr = this._mountQueue,
			arrCount = arr.length,
			item;
		
		while (arrCount--) {
			item = arr[arrCount];
			
			this._entity._orphans.pull(item);
			item.mount(this._entity);
		}
		
		this._mountQueue = [];
	},

	/**
	 * Loops any entities queued for un-mounting and un-mounts them.
	 * @private
	 */
	_processUnMountQueue: function () {
		var arr = this._unMountQueue,
			arrCount = arr.length,
			item;
		
		while (arrCount--) {
			item = arr[arrCount];
			item.unMount();
			
			this._entity._orphans.push(item);
		}
		
		this._unMountQueue = [];
	}
});
;// @server-side
var TLPhysicsBodyComponent = TLEntityComponent.extend({
	classId: 'TLPhysicsBodyComponent',
	componentId: 'physicsBody',

	bodyDef: undefined,
	// Read only!
	_defaultBodyDef: undefined,
	// Category bits, mask bits, and group index for the body's fixtures
	fixtureFilter: undefined,
	// Location in scaled box2d coordinates, updated by TLPhysicsSystem
	x: undefined,
	y: undefined,
	// Flag that indicates if the body is in transactional mode. We enter
	// transactional mode when we want to create many fixtures at once, like
	// during asteroid creation.
	_transactional: undefined,
	// Array that stores fixtures until we are ready to commit
	_transactionalFixtures: undefined,
	// Called when we get a response from the server that indicates if the
	// transaction has succeeded or failed
	_transactionalFixturesCallback: undefined,

	init: function (entity, options) {
		options = options || {};

		TLEntityComponent.prototype.init.call(this, entity, options);
		// Store the existing transform methods
		var entity = this._entity;
		this._translateToProto = entity.translateTo.bind(entity);
		this._translateByProto = entity.translateBy.bind(entity);

		this._rotateToProto = entity.rotateTo.bind(entity);
		this._rotateByProto = entity.rotateBy.bind(entity);

		this._destroyProto = entity.destroy.bind(entity);

		// Take over the transform methods
		entity.translateTo = this.translateTo.bind(this);
		entity.translateBy = this.translateBy.bind(this);

		entity.rotateTo = this.rotateTo.bind(this);
		entity.rotateBy = this.rotateBy.bind(this);

		entity.destroy = this._destroy.bind(this);

		this.bodyDef = options.bodyDef || {};
		this._defaultBodyDef = undefined;

		this.fixtureFilter = options.fixtureFilter || {};

		this._transactional = false;
		this._transactionalFixtures = [];
		this._transactionalFixturesCallback = undefined;
	},

	// Note: this._defaultBodyDef is read only! Otherwise we'll change the
	// default values.
	newBody: function () {
		var finalBodyDef;

		// If the bodyDef has no properties, use the default bodyDef
		if (Object.keys(this.bodyDef).length === 0) {
			finalBodyDef = this._defaultBodyDef;
		}
		// If the bodyDef has some properties, use those and fill in default
		// values for the rest.
		else {
			finalBodyDef = this.bodyDef;
			for (var key in this._defaultBodyDef) {
				if (this._defaultBodyDef.hasOwnProperty(key)) {
					if (!this.bodyDef.hasOwnProperty(key)) {
						finalBodyDef[key] = this._defaultBodyDef[key];
					}
				}
			}
		}

		// Set the initial physics body position
		// TODO: Add support for initial rotation as well
		this.x = finalBodyDef.x || 0;
		this.y = finalBodyDef.y || 0;

		ige.physicsSystem.newBody(this._entity, finalBodyDef);
	},

	// Default properties to fill in when creating a new body. These
	// properties have lower precedence than this.bodyDef
	registerDefaultBodyDef: function (defaultBodyDef) {
		this._defaultBodyDef = defaultBodyDef;
	},


	newFixture: function (fixtureEntity) {
		// Check if fixtureEntity has a physics fixture component
		if (fixtureEntity.physicsFixture === undefined) {
			this.log('TLPhysicsBodyComponent#newFixture: No physicsFixture component!',
				'error');
			return;
		}

		if (this._transactional) {
			this._transactionalFixtures.push({
				fixtureEntity: fixtureEntity,
				fixtureDef: fixtureEntity.physicsFixture.fixtureDef
			});
		}
		else {
			ige.physicsSystem.newFixture(this._entity, fixtureEntity,
				fixtureEntity.physicsFixture.fixtureDef);
		}
	},

	newTransactionalFixtures: function (addToTransactionalFixtures, opts) {
		this._transactional = true;
		this._transactionalFixturesCallback = opts.callback;

		addToTransactionalFixtures();

		opts.bodyAabbWidth = this._entity.aabb().width;
		opts.bodyAabbHeight = this._entity.aabb().height;

		ige.physicsSystem.newTransactionalFixtures(this._entity,
			this._transactionalFixtures, opts);

		// Destroy list of fixtures
		this._transactionalFixtures = [];

		this._transactional = false;
	},

	// Called from TLPhysicsSystem upon physics server message
	onTransactionalFixtures: function(success) {
		this._transactionalFixturesCallback(success);
		this._transactionalFixturesCallback = undefined;
	},

	applyAngularImpulse: function (impulse) {
		ige.physicsSystem.applyAngularImpulse(this._entity, impulse);
	},

	applyLinearImpulseLocal: function (opts) {
		ige.physicsSystem.applyLinearImpulseLocal(this._entity, opts);
	},

	destroyFixture: function (fixtureEntity) {
		fixtureEntity.physicsFixture.fixtureDef = {};
		ige.physicsSystem.destroyFixture(this._entity, fixtureEntity);
	},

	destroyBody: function () {
		this.bodyDef = {};
		ige.physicsSystem.destroyBody(this._entity);
	},

	attractTo: function (attractingBodyEntity, strength) {
		ige.physicsSystem.attractTo(this._entity, attractingBodyEntity, strength);
	},

	setLinkedId: function (linkedId) {
		ige.physicsSystem.setLinkedId(this._entity, linkedId);
	},

	translateTo: function (x, y, z) {
		this._translateToProto(x, y, z);
		// Send a translate command to the physics server.
		// If the physics system is updating the positions of entities,
		// don't do this
		if (!ige.physicsSystem.updating) {
			ige.physicsSystem.setTransform(this._entity, {
				x: x,
				y: y,
				angle: this._entity._rotate.z
			});
		}
		return this._entity;
	},

	translateBy: function (x, y, z) {
		this.translateTo(
			this._entity._translate.x + x,
			this._entity._translate.y + y,
			this._entity._translate.z + z
		);
	},

	// TODO: Support translateToPoint

	rotateTo: function (x, y, z) {
		this._rotateToProto(x, y, z);

		if(!ige.physicsSystem.updating) {
			ige.physicsSystem.setTransform(this._entity, {
				x: this._entity._translate.x,
				y: this._entity._translate.y,
				angle: z
			});
		}
		return this._entity;
	},

	rotateBy: function (x, y, z) {
		this._rotateTo(
			this._entity._rotate.x + x,
			this._entity._rotate.y + y,
			this._entity._rotate.z + z
		);
	},

	// This destroys the physics body and the entity.
	// To only destroy the body, use destroyBody()
	_destroy: function (x, y, z) {
		this.destroyBody();
		this._destroyProto();
	},

});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TLPhysicsBodyComponent; }
;// @server-side
var TLPhysicsFixtureComponent = TLEntityComponent.extend({
	classId: 'TLPhysicsFixtureComponent',
	componentId: 'physicsFixture',

	fixtureDef: undefined,

	// TODO: Default fixtureDef in the same style as TLPhysicsBodyComponent

	init: function (entity, options) {
		TLEntityComponent.prototype.init.call(this, entity, options);
		this.fixtureDef = {};
	},

});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TLPhysicsFixtureComponent; }
;/**
 *  TLPhysicsSystem. Handles network communication from the game server to the
 *  physics server.
 */
// @server-side
var TLPhysicsSystem = TLSystem.extend({
	classId: 'TLPhysicsSystem',
	componentId: 'physicsSystem',
	_WebSocket: undefined,
	_ProtoBuf: undefined,
	// Default scale factor from pixels to meters
	_scaleFactor: 100,
	// Gets set to true when the physics system is updating the positions of all
	// physics entites. This is necessary to override default functionality of
	// the entitys' translate and rotate functions
	updating: false,
	// Maps ray cast requests to their callbacks
	_rayCastsMap: {},

	validBodyTypes: {
		STATIC: true,
		KINEMATIC: true,
		DYNAMIC: true
	},

	// Called when we get a contact message from the physics server
	_beginContactCallback: function() {},
	_endContactCallback: function() {},
	_preSolveCallback: function() {},
	_postSolveCallback: function() {},


	init: function (entity, options) {
		this._WebSocket = rootRequire('ws');
		this._ProtoBuf = rootRequire('protobufjs');
		this._scaleFactor = options.scaleFactor || this._scaleFactor;

		// Connect to the physics server
		this._ws = new this._WebSocket(global.config.physicsServerUrl);

		this._ws.on('message', this._onMessage.bind(this));
		var path = TLPhysicsPath + 'physics_server/cosmos.proto';
		this._builder = this._ProtoBuf.loadProtoFile(path);
		this._request = this._builder.build('Cosmos').ClientToServer;
		this._response = this._builder.build('Cosmos').ServerToClient;
		this._enums = {
			worldBodiesUpdate:
				this._builder.lookup("Cosmos.ServerToClient.ResponseType.WORLD_BODIES_UPDATE").id,
			contact:
				this._builder.lookup("Cosmos.ServerToClient.ResponseType.CONTACT").id,
			beginContact:
				this._builder.lookup("Cosmos.ServerToClient.Contact.ContactType.BEGIN_CONTACT").id,
			endContact:
				this._builder.lookup("Cosmos.ServerToClient.Contact.ContactType.END_CONTACT").id,
			preSolve:
				this._builder.lookup("Cosmos.ServerToClient.Contact.ContactType.PRE_SOLVE").id,
			postSolve:
				this._builder.lookup("Cosmos.ServerToClient.Contact.ContactType.POST_SOLVE").id,
			transactionalFixtures:
				this._builder.lookup("Cosmos.ServerToClient.ResponseType.TRANSACTIONAL_FIXTURES").id,
			rayCast:
				this._builder.lookup("Cosmos.ServerToClient.ResponseType.RAY_CAST").id,
		}
		this.log('TL physics system initiated! Scale factor: ' + this._scaleFactor);
	},

	scaleFactor: function () {
		return this._scaleFactor;
	},

	newBody: function (bodyEntity, opts) {
		if(!this.validBodyTypes.hasOwnProperty(opts.bodyType)) {
			this.log('TLPhysicsSystem#newBody: Invalid body type!', 'error');
		}
		// Build request
		var request = new this._request({
			"type": "NEW_BODY",
			"new_body": {
				"body_id": bodyEntity.id(),
				"body_type": opts.bodyType,
				"linked_id": opts.linkedId || '',
				"x": opts.x / this._scaleFactor,
				"y": opts.y / this._scaleFactor,
				"angle": opts.angle,
				"linear_damping": opts.linearDamping,
				"angular_damping": opts.angularDamping,
				"bullet": opts.bullet,
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	newFixture: function (bodyEntity, fixtureEntity, opts) {
		var requestDef = {
			"type": "NEW_FIXTURE",
			"new_fixture": this._newFixturePartial(bodyEntity, fixtureEntity, opts)
		}
		requestDef["type"] = "NEW_FIXTURE";

		var request = new this._request(requestDef);
		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	_newFixturePartial: function (bodyEntity, fixtureEntity, opts) {
		// Build request
			var newFixture = {
				"fixture_id": fixtureEntity.id(),
				"body_id": bodyEntity.id(),
				"friction": opts.friction,
				"restitution": opts.restitution,
				"density": opts.density,
				"is_sensor": opts.isSensor,
				"category_bits": opts.categoryBits,
				"mask_bits": opts.maskBits,
				"group_index": opts.groupIndex || 0,
			}

		// Fill in shape
		switch(opts.shapeType) {
			case 'BOX':
				newFixture['shape_type'] = 'BOX';
				newFixture['box'] = {
					"hwidth": opts.hwidth / this._scaleFactor,
					"hheight": opts.hheight / this._scaleFactor,
					"x": opts.x / this._scaleFactor,
					"y": opts.y / this._scaleFactor,
					"angle": opts.angle
				}
				break;
			case 'CIRCLE':
				newFixture['shape_type'] = 'CIRCLE';
				newFixture['circle'] = {
					"radius": opts.radius / this._scaleFactor,
					"x": opts.x / this._scaleFactor,
					"y": opts.y / this._scaleFactor
				}
				break;
			default:
				this.log('TLPhysicsSystem#_createFixtureRequestDef: Invalid shape type!',
					'error');
				break;
		}

		return newFixture;
	},

	newTransactionalFixtures: function (bodyEntity, transactionalFixtures, opts) {
		var fixtureRequestDefs = [];

		for (var i = 0; i < transactionalFixtures.length; i++) {
			var fixtureEntity = transactionalFixtures[i].fixtureEntity;
			var fixtureDef = transactionalFixtures[i].fixtureDef;
			fixtureRequestDefs.push(this._newFixturePartial(
				bodyEntity, fixtureEntity, fixtureDef));
		}

		var request = new this._request({
			"type": "NEW_TRANSACTIONAL_FIXTURES",
			"new_transactional_fixtures": {
				"new_fixtures": fixtureRequestDefs,
				"body_id": bodyEntity.id(),
				"body_aabb_width": opts.bodyAabbWidth / this._scaleFactor,
				"body_aabb_height": opts.bodyAabbHeight / this._scaleFactor,
				"viable_aabb_width": opts.viableAabbWidth / this._scaleFactor,
				"viable_aabb_height": opts.viableAabbHeight / this._scaleFactor,
				"viable_x": opts.viableX / this._scaleFactor,
				"viable_y": opts.viableY / this._scaleFactor,
				"num_retries": opts.numRetries
			}
		});
		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	applyAngularImpulse: function (bodyEntity, impulse) {
		// Build request
		var request = new this._request({
			"type": "APPLY_ANGULAR_IMPULSE",
			"apply_angular_impulse": {
				"body_id": bodyEntity.id(),
				"impulse": impulse,
				"wake": true
				}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	applyLinearImpulseLocal: function (bodyEntity, opts) {
		// Build request
		var request = new this._request({
			"type": "APPLY_LINEAR_IMPULSE",
			"apply_linear_impulse": {
				"body_id": bodyEntity.id(),
				"impulse_x": opts.impulseX,
				"impulse_y": opts.impulseY,
				"pos_x": opts.posX / this._scaleFactor,
				"pos_y": opts.posY / this._scaleFactor,
				"wake": true,
				"local": true
				}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	destroyFixture: function (bodyEntity, fixtureEntity) {
		var request = new this._request({
			"type": "DESTROY_FIXTURE",
			"destroy_fixture": {
				"body_id": bodyEntity.id(),
				"fixture_id": fixtureEntity.id()
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	destroyBody: function (bodyEntity) {
		var request = new this._request({
			"type": "DESTROY_BODY",
			"destroy_body": {
				"body_id": bodyEntity.id()
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	setTransform: function (bodyEntity, opts) {
		var request = new this._request({
			"type": "SET_TRANSFORM",
			"set_transform": {
				"body_id": bodyEntity.id(),
				"x": opts.x / this._scaleFactor,
				"y": opts.y / this._scaleFactor,
				"angle": opts.angle
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	newCustomContacts: function (opts) {
		var request = new this._request({
			"type": "NEW_CUSTOM_CONTACTS",
			"new_custom_contacts": {
				"contact_type": opts.contactType,
				"contacts": opts.contacts
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	attractTo: function (attractedBodyEntity, attractingBodyEntity, strength) {
		var request = new this._request({
			"type": "ATTRACT_TO",
			"attract_to": {
				"attracted_body_id": attractedBodyEntity.id(),
				"attracting_body_id": attractingBodyEntity.id(),
				"attraction_strength": strength
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	setLinkedId: function (bodyEntity, linkedId) {
		var request = new this._request({
			"type": "SET_LINKED_ID",
			"set_linked_id": {
				"body_id": bodyEntity.id(),
				"linked_id": linkedId || ''
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
	},

	/**
	 * Asks the physics server to perform a ray cast.
	 * The callback will receive an array that looks like this:
	 *
	 * [{entity: <entity here>
	 * pointX: 4107.2998046875      // Point of intersection
	 * pointY: 4107.2998046875
	 * normalX: 0                   // Normal vector at intersection
	 * normalY: -100
	 * fraction: 0.7281833291053772 // Position on ray of intersection
	 * },
	 * {...},
	 * {...}];
	 *
	 * The array that is returned is sorted by increasing fraction, which means
	 * that the closest entities hit are first in the array.
	 *
	 * @returns {string} The raycast request id
	 */
	newRayCast: function (opts, callback) {
		// Use an id to associate the ray cast request with its callback
		var rayCastId = ige.newIdHex();
		this._rayCastsMap[rayCastId] = callback;

		var request = new this._request({
			"type": "NEW_RAY_CAST",
			"new_ray_cast": {
				"ray_cast_id": rayCastId,
				"point1_x": opts.point1X / this._scaleFactor,
				"point1_y": opts.point1Y / this._scaleFactor,
				"point2_x": opts.point2X / this._scaleFactor,
				"point2_y": opts.point2Y / this._scaleFactor,
				"ignore_body_ids": opts.ignoreBodyIds,
				"ignore_fixture_ids": opts.ignoreFixtureIds,
				"ignore_fixture_categories": opts.ignoreFixtureCategories,
			}
		});

		this._ws.send(request.toArrayBuffer(), {binary: true, mask: true});
		return rayCastId;
	},

	_onMessage: function (data) {
		var response = this._response.decode(data);
		switch (response.type) {
			// World bodies update
			case this._enums.worldBodiesUpdate:
				this.updating = true;
				this._onWorldBodiesUpdate(response.world_bodies_update.body_updates);
				this.updating = false;
				break;
			// Contact
			case this._enums.contact:
				this._onContact(response.contact);
				break;
			// Transactional fixtures
			case this._enums.transactionalFixtures:
				this._onTransactionalFixtures(response.transactional_fixtures);
				break;
			// Ray cast
			case this._enums.rayCast:
				this._onRayCast(response.ray_cast);
				break;
			default:
				this.log('TLPhysicsSystem#_onMessage: Bad response type!','warning');
				break;
		}
	},

	// Moves game entities with new updates from physics server
	_onWorldBodiesUpdate: function (bodyUpdates) {
		for (var i = 0; i < bodyUpdates.length; i++) {
			var bodyUpdate = bodyUpdates[i];
			var entity = ige.$(bodyUpdate.id);
			if (entity === undefined) {
				// Note: This could be normal behavior.
				// This happens when an entity is destroyed on the client, but
				// the destroy command has not been processed by the physics server.
				// This will resolve itself in the next physics server cycle.
				return;
			}

			// Update physicsBody component
			entity.physicsBody.x = bodyUpdate.x * this._scaleFactor;
			entity.physicsBody.y = bodyUpdate.y * this._scaleFactor;

			// Update entity translation
			var theta = bodyUpdate.angle;
			var physicsOffset = {
				x: 0,
				y: 0
			};

			if (entity._physicsOffset) {
				physicsOffset.x = entity._physicsOffset.x * Math.cos(theta)
					- entity._physicsOffset.y * Math.sin(theta);
				physicsOffset.y = entity._physicsOffset.x * Math.sin(theta)
					+ entity._physicsOffset.y * Math.cos(theta);
			}

			entity.translateTo(
				bodyUpdate.x * this._scaleFactor + physicsOffset.x,
				bodyUpdate.y * this._scaleFactor + physicsOffset.y,
				entity._translate.z
			);

			// Update entity rotation
			entity.rotateTo(entity._rotate.x, entity._rotate.y, bodyUpdate.angle);
		}
	},

	_onContact: function (contact) {
		var entity1 = ige.$(contact.body1_id);
		var entity2 = ige.$(contact.body2_id);
		if ((entity1 === undefined) || (entity2 === undefined)) {
			// Note: This could be normal behavior.
			// This happens when an entity is destroyed on the client, but
			// the destroy command has not been processed by the physics server.
			// This will resolve itself in the next physics server cycle.
			return;
		}

		var identifier = contact.identifier;
		switch(contact.contact_type) {
			case this._enums.beginContact:
				this._beginContactCallback(entity1, entity2, identifier);
				break;
			case this._enums.endContact:
				this._endContactCallback(entity1, entity2, identifier);
				break;
			case this._enums.preSolve:
				this._preSolveCallback(entity1, entity2, identifier);
				break;
			case this._enums.postSolve:
				this._postSolveCallback(entity1, entity2, identifier);
				break;
		}
	},

	_onTransactionalFixtures: function (transactionalFixtures) {
		var entity = ige.$(transactionalFixtures.body_id);
		var success = transactionalFixtures.success;
		if (entity === undefined) {
			this.log('Cosmos:TLPhysicsSystem#_onTransactionalFixtures: ' + 
				'Invalid entity id on transactional fixtures. ' +
				'This should not happen!.', 'warning');
			return;
		}
		// Let entity know if the transaction was successful
		// TODO: Allow multiple transactions in parallel. This involves storing
		// many callbacks
		entity.physicsBody.onTransactionalFixtures(success);
	},

	_onRayCast: function (rayCast) {
		var rayCastId = rayCast.ray_cast_id;
		if (!this._rayCastsMap.hasOwnProperty(rayCastId)) {
			this.log('Cosmos:TLPhysicsSystem#_onRayCast: Bad ray cast id!',
				'warning');
			return;
		}

		// Prepare results for callback function
		var results = [];
		var reportFixtures = rayCast.report_fixtures;
		for (var i = 0; i < reportFixtures.length; i++) {
			var reportFixture = reportFixtures[i];

			// Verify existence of entity
			var entity = ige.$(reportFixture.fixture_id);
			if (entity === undefined) {
				this.log('Cosmos:TLPhysicsSystem#_onRayCast: Fixture does not exist!',
					'warning');
				continue;
			}

			var result = {};
			result.entity = entity;
			result.pointX = reportFixture.point_x * this._scaleFactor;
			result.pointY = reportFixture.point_y * this._scaleFactor;
			result.normalX = reportFixture.normal_x * this._scaleFactor;
			result.normalY = reportFixture.normal_y * this._scaleFactor;
			result.fraction = reportFixture.fraction;
			results.push(result);
		}

		// Execute callback function for this ray cast request
		this._rayCastsMap[rayCastId](results);

		// Remove callback function from map
		delete this._rayCastsMap[rayCastId];
	},

	registerCollisionCallbacks: function (callbacks) {
		this._beginContactCallback = callbacks.beginContact;
		this._endContactCallback = callbacks.endContact;
		this._preSolveCallback = callbacks.preSolve;
		this._postSolveCallback = callbacks.postSolve;
	}



});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TLPhysicsSystem; }
;var TLRenderingSystem = TLSubsystem.extend({
	classId: 'TLRenderingSystem',
	systemId: 'rendering',

	init: function(supersystem, data) {
		// TODO: Uncomment this error condition once IGE server has been decoupled from rendering
		/*if (ige.isServer) {
			this.log('Rendering systems should never be added to the server.', 'error');
			return;
		}*/

		data = data || {};

		this._autoSize = data.autoSize;
		this._dontScale = data.dontScale;

		TLSubsystem.prototype.init.call(this, supersystem, data);
	},

	start: function() {
		if (ige.isServer) {
			return;
		}
		this._createFrontBuffer(this._autoSize, this._dontScale);
		TLSubsystem.prototype.start.call(this);
	},

	/**
	 * Checks to ensure that a canvas has been assigned to the engine or that the
	 * engine is in server mode.
	 * @return {Boolean}
	 */
	canvasReady: function () {
		// TODO: Once rendering can no longer be included on server, remove the or statement checking if this is the
		// IGE server.
		return (this._canvas !== undefined || ige.isServer);
	},

	_createFrontBuffer: function(autoSize, dontScale) {
		if (ige.isClient) {
			if (!this._canvas) {
				this._createdFrontBuffer = true;
				this._pixelRatioScaling = !dontScale;

				this._frontBufferSetup(autoSize, dontScale);
			}
		}
	},

	/**
	 * Gets the bounding rectangle for the HTML canvas element being
	 * used as the front buffer for the engine. Uses DOM methods.
	 * @returns {ClientRect}
	 * @private
	 */
	_canvasPosition: function () {
		try {
			return this._canvas.getBoundingClientRect();
		} catch (e) {
			return {
				top: this._canvas.offsetTop,
				left: this._canvas.offsetLeft
			};
		}
	},

	/**
	 * Handles the screen resize event.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		var canvasBoundingRect;

		if (this._autoSize) {
			var newWidth = window.innerWidth,
				newHeight = window.innerHeight / 2,
				arr = ige._children,
				arrCount = arr.length;

			// Only update canvas dimensions if it exists
			if (this._canvas) {
				// Check if we can get the position of the canvas
				canvasBoundingRect = this._canvasPosition();

				// Adjust the newWidth and newHeight by the canvas offset
				newWidth -= parseInt(canvasBoundingRect.left);
				newHeight -= parseInt(canvasBoundingRect.top);

				// Make sure we can divide the new width and height by 2...
				// otherwise minus 1 so we get an even number so that we
				// negate the blur effect of sub-pixel rendering
				if (newWidth % 2) { newWidth--; }
				if (newHeight % 2) { newHeight--; }

				this._canvas.width = newWidth * this._deviceFinalDrawRatio;
				this._canvas.height = newHeight * this._deviceFinalDrawRatio;

				if (this._deviceFinalDrawRatio !== 1) {
					this._canvas.style.width = newWidth + 'px';
					this._canvas.style.height = newHeight + 'px';

					// Scale the canvas context to account for the change
					this._ctx.scale(this._deviceFinalDrawRatio, this._deviceFinalDrawRatio);
				}
			}

			ige._bounds2d = new IgePoint3d(newWidth, newHeight, 0);

			// Loop any mounted children and check if
			// they should also get resized
			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		} else {
			if (this._canvas) {
				ige._bounds2d = new IgePoint3d(this._canvas.width, this._canvas.height, 0);
			}
		}

		ige._resized = true;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = TLRenderingSystem; };var TLRenderableComponent = TLEntityComponent.extend({
	classId: 'TLRenderableComponent',
	componentId: 'renderable',

	init: function(entity, data) {
		var self = this;
		TLEntityComponent.prototype.init.call(this, entity, data);

		if (ige.isClient && !(ige.rendering instanceof TLRenderingSystem)) {
			this.log('No rendering system was attached to the engine.', 'error');
			return;
		}

		data = data || {};

		this._anchor = data.anchor || new IgePoint2d(0, 0);

		if (ige.isServer) {
			return;
		}

		this._renderPos = new IgePoint2d(0, 0);
		this._computedOpacity = 1;
		this._opacity = 1;
		this._cell = 1;
		this._highlight = false;
		this._hidden = false;
		this._updateChildren = false;
		this._updateChildrenNeeded = false;

		this._cache = false;
		this._compositeCache = false;

		if (ige.isClient && !this._entity) {
			console.trace();
		}
		// Set the parent of this renderable component as the renderable component for the entity's parent.
		if (this._entity._parent && this._entity._parent.renderable) {
			this._parent = this._entity._parent.renderable;
		}

		this._entity.addBehaviour(ige.rendering.systemId, this.update.bind(this));
	},

	update: function() {
		this.abstractMethod('update');
	},

	texture: function(texture) {
		if (texture !== undefined) {
			this._texture = texture;
			return this._entity;
		}

		return this._texture;
	},

	anchor: function(newAnchor) {
		if (newAnchor !== undefined) {
			this._anchor = newAnchor;
			return this;
		}

		return this._anchor;
	},

	compositeCache: function(val) {
		if (val !== undefined) {
			this._compositeCache = val;
			return this._entity;
		}

		return this._compositeCache;
	},

	/**
	 * When using the caching system, this boolean determines if the
	 * cache canvas should have image smoothing enabled or not. If
	 * not set, the ige global smoothing setting will be used instead.
	 * @param {Boolean=} val True to enable smoothing, false to disable.
	 * @returns {*}
	 */
	cacheSmoothing: function (val) {
		if (val !== undefined) {
			this._cacheSmoothing = val;
			return this._entity;
		}

		return this._cacheSmoothing;
	},

	/**
	 * Gets / sets the cache dirty flag. If set to true this will
	 * instruct the entity to re-draw it's cached image from the
	 * assigned texture. Once that occurs the flag will automatically
	 * be set back to false. This works in either standard cache mode
	 * or composite cache mode.
	 * @param {Boolean=} val True to force a cache update.
	 * @example #Get cache dirty flag value
	 *     var val = entity.cacheDirty();
	 * @example #Set cache dirty flag value
	 *     entity.cacheDirty(true);
	 * @return {*}
	 */
	cacheDirty: function (val) {
		var entity = this._entity;
		if (val !== undefined) {
			this._cacheDirty = val;

			// Check if the entity is a child of a composite or composite
			// entity chain and propagate the dirty cache up the chain
			if (val && entity._compositeParent && entity._parent) {
				entity._parent.cacheDirty(val);

				if (!this._cache && !this._compositeCache) {
					// Set clean immediately as no caching is enabled on this child
					this._cacheDirty = false;
				}
			}

			return entity;
		}

		return this._cacheDirty;
	},

	/**
	 * Gets / sets the current texture cell used when rendering the game
	 * object's texture. If the texture is not cell-based, this value is
	 * ignored.
	 * @param {Number=} val The cell index.
	 * @example #Set the entity texture as a 4x4 cell sheet and then set the cell to use
	 *     var texture = new IgeCellSheet('path/to/some/cellSheet.png', 4, 4);
	 *     entity.texture(texture)
	 *         .cell(3);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	cell: function (val) {
		if (val > 0 || val === null) {
			this._cell = val;
			return this._entity;
		}

		return this._cell;
	},

	/**
	 * Gets / sets the entity opacity from 0.0 to 1.0.
	 * @param {Number=} val The opacity value.
	 * @example #Set the entity to half-visible
	 *     entity.opacity(0.5);
	 * @example #Set the entity to fully-visible
	 *     entity.opacity(1.0);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	opacity: function (val) {
		if (val !== undefined) {
			this._opacity = val;
			return this._entity;
		}

		return this._opacity;
	},

	/**
	 * Gets / sets the highlight mode. True is on false is off.
	 * @param {Boolean} val The highlight mode true or false.
	 * @example #Set the entity to render highlighted
	 *     entity.highlight(true);
	 * @example #Get the current highlight state
	 *     var isHighlighted = entity.highlight();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	highlight: function (val) {
		if (val !== undefined) {
			this._highlight = val;
			return this._entity;
		}

		return this._highlight;
	},

	/**
	 * Sets the entity as visible and able to be interacted with.
	 * @example #Show a hidden entity
	 *     entity.show();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	show: function () {
		this._hidden = false;
		return this._entity;
	},

	/**
	 * Sets the entity as hidden and cannot be interacted with.
	 * @example #Hide a visible entity
	 *     entity.hide();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	hide: function () {
		this._hidden = true;
		return this._entity;
	},

	/**
	 * Checks if the entity is visible.
	 * @returns {boolean} True if the entity is visible.
	 */
	isVisible: function () {
		return this._hidden === false;
	},

	/**
	 * Checks if the entity is hidden.
	 * @returns {boolean} True if the entity is hidden.
	 */
	isHidden: function () {
		return this._hidden === true;
	},

	/**
	 * Gets / sets the texture to use as the background
	 * pattern for this entity.
	 * @param {IgeTexture} texture The texture to use as
	 * the background.
	 * @param {String=} repeat The type of repeat mode either: "repeat",
	 * "repeat-x", "repeat-y" or "none".
	 * @param {Boolean=} trackCamera If set to true, will track the camera
	 * translation and "move" the background with the camera.
	 * @param {Boolean=} isoTile If true the tiles of the background will
	 * be treated as isometric and will therefore be drawn so that they are
	 * layered seamlessly in isometric view.
	 * @example #Set a background pattern for this entity with 2d tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, false);
	 * @example #Set a background pattern for this entity with isometric tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, true);
	 * @return {*}
	 */
	backgroundPattern: function (texture, repeat, trackCamera, isoTile) {
		if (texture !== undefined) {
			this._backgroundPattern = texture;
			this._backgroundPatternRepeat = repeat || 'repeat';
			this._backgroundPatternTrackCamera = trackCamera;
			this._backgroundPatternIsoTile = isoTile;
			this._backgroundPatternFill = null;
			return this._entity;
		}

		return this._backgroundPattern;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = TLRenderableComponent; };var IgeRenderingSystem = TLRenderingSystem.extend({
	classId: 'IgeRenderingSystem',
	systemId: 'igeRendering',

	init: function(supersystem, data) {
		TLRenderingSystem.prototype.init.call(this, supersystem, data);
		data = data || {};

		this._autoSize = data.autoSize;
		this._dontScale = data.dontScale;
		this._renderContext = '2d'; // The rendering context, default is 2d
		this._showSgTree = false;
		this._globalSmoothing = false;

		// Set some defaults
		this._renderModes = [
			'2d',
			'three'
		];
	},

	/**
	 * Gets / sets the default smoothing value for all new
	 * IgeTexture class instances. If set to true, all newly
	 * created textures will have smoothing enabled by default.
	 * @param val
	 * @return {*}
	 */
	globalSmoothing: function (val) {
		if (val !== undefined) {
			this._globalSmoothing = val;
			return this;
		}

		return this._globalSmoothing;
	},

	/**
	 * Gets / sets the rendering context that will be used when getting the
	 * context from canvas elements.
	 * @param {String=} contextId The context such as '2d'. Defaults to '2d'.
	 * @return {*}
	 */
	renderContext: function (contextId) {
		if (contextId !== undefined) {
			this._renderContext = contextId;
			this._renderMode = this._renderModes[contextId];

			this.log('Rendering mode set to: ' + contextId);

			return this;
		}

		return this._renderContext;
	},

	update: function() {
		var self = this;
		this._ctx.save();
		this._ctx.translate(ige._bounds2d.x2, ige._bounds2d.y2);
		ige.traverseEntityGraph(
			function(child) {
				self._ctx.save();
				var continueRecursing = child.renderable.render(self._ctx);
				//if (continueRecursing && child.renderable._compositeCache && !child.renderable._cacheDirty) {
				//	return false;
				//}
				return continueRecursing;
			},
			function(child) {
				//if (child.renderable._compositeCache && child.renderable._cacheDirty) {
					//child.renderable._renderCache(self._ctx);
				//	child.renderable._cacheDirty = false;
				//}
				self._ctx.restore();
			}
		);
		this._ctx.restore();
	},

	/**
	 * Sets the canvas element that will be used as the front-buffer.
	 * @param elem The canvas element.
	 * @param autoSize If set to true, the engine will automatically size
	 * the canvas to the width and height of the window upon window resize.
	 */
	canvas: function (elem, autoSize) {
		if (elem !== undefined) {
			if (!this._canvas) {
				// Setup front-buffer canvas element
				this._canvas = elem;
				this._ctx = this._canvas.getContext(this._renderContext);

				// Handle pixel ratio settings
				if (this._pixelRatioScaling) {
					// Support high-definition devices and "retina" (stupid marketing name)
					// displays by adjusting for device and back store pixels ratios
					this._devicePixelRatio = window.devicePixelRatio || 1;
					this._backingStoreRatio = this._ctx.webkitBackingStorePixelRatio ||
						this._ctx.mozBackingStorePixelRatio ||
						this._ctx.msBackingStorePixelRatio ||
						this._ctx.oBackingStorePixelRatio ||
						this._ctx.backingStorePixelRatio || 1;

					this._deviceFinalDrawRatio = this._devicePixelRatio / this._backingStoreRatio;
				} else {
					// No auto-scaling
					this._devicePixelRatio = 1;
					this._backingStoreRatio = 1;
					this._deviceFinalDrawRatio = 1;
				}

				this._ctx.imageSmoothingEnabled = this._globalSmoothing;
				this._ctx.webkitImageSmoothingEnabled = this._globalSmoothing;
				this._ctx.mozImageSmoothingEnabled = this._globalSmoothing;

				// Add some event listeners even if autosize is off
				window.addEventListener('resize', this._resizeEvent.bind(this));

				// Fire the resize event for the first time
				// which sets up initial canvas dimensions
				this._resizeEvent();
				this._ctx = this._canvas.getContext(this._renderContext);
				ige._headless = false;

				// Ask the input component to setup any listeners it has
				ige.input.setupListeners(this._canvas);
			}
		}

		return this._canvas;
	},

	_frontBufferSetup: function (autoSize, dontScale) {
		// Create a new canvas element to use as the
		// rendering front-buffer
		var tempCanvas = document.createElement('canvas');

		// Set the canvas element id
		tempCanvas.id = 'igeFrontBuffer';

		tempCanvas.height = window.innerHeight / 2;

		this.canvas(tempCanvas, autoSize);
		//document.body.appendChild(tempCanvas);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeRenderingSystem; };/**
 * @license
 * pixi.js - v1.6.1
 * Copyright (c) 2012-2014, Mat Groves
 * http://goodboydigital.com/
 *
 * Compiled: 2014-08-28
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license.php
 */
(function(){var a=this,b=b||{};b.WEBGL_RENDERER=0,b.CANVAS_RENDERER=1,b.VERSION="v1.6.1",b.blendModes={NORMAL:0,ADD:1,MULTIPLY:2,SCREEN:3,OVERLAY:4,DARKEN:5,LIGHTEN:6,COLOR_DODGE:7,COLOR_BURN:8,HARD_LIGHT:9,SOFT_LIGHT:10,DIFFERENCE:11,EXCLUSION:12,HUE:13,SATURATION:14,COLOR:15,LUMINOSITY:16},b.scaleModes={DEFAULT:0,LINEAR:0,NEAREST:1},b._UID=0,"undefined"!=typeof Float32Array?(b.Float32Array=Float32Array,b.Uint16Array=Uint16Array):(b.Float32Array=Array,b.Uint16Array=Array),b.INTERACTION_FREQUENCY=30,b.AUTO_PREVENT_DEFAULT=!0,b.RAD_TO_DEG=180/Math.PI,b.DEG_TO_RAD=Math.PI/180,b.dontSayHello=!1,b.sayHello=function(a){if(!b.dontSayHello){if(navigator.userAgent.toLowerCase().indexOf("chrome")>-1){var c=["%c %c %c Pixi.js "+b.VERSION+" - "+a+"  %c  %c  http://www.pixijs.com/  %c %c %c%c ","background: #ff66a5","background: #ff66a5","color: #ff66a5; background: #030307;","background: #ff66a5","background: #ffc3dc","background: #ff66a5","color: #ff2424; background: #fff","color: #ff2424; background: #fff","color: #ff2424; background: #fff"];console.log.apply(console,c)}else window.console&&console.log("Pixi.js "+b.VERSION+" - http://www.pixijs.com/");b.dontSayHello=!0}},b.Point=function(a,b){this.x=a||0,this.y=b||0},b.Point.prototype.clone=function(){return new b.Point(this.x,this.y)},b.Point.prototype.set=function(a,b){this.x=a||0,this.y=b||(0!==b?this.x:0)},b.Point.prototype.constructor=b.Point,b.Rectangle=function(a,b,c,d){this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0},b.Rectangle.prototype.clone=function(){return new b.Rectangle(this.x,this.y,this.width,this.height)},b.Rectangle.prototype.contains=function(a,b){if(this.width<=0||this.height<=0)return!1;var c=this.x;if(a>=c&&a<=c+this.width){var d=this.y;if(b>=d&&b<=d+this.height)return!0}return!1},b.Rectangle.prototype.constructor=b.Rectangle,b.EmptyRectangle=new b.Rectangle(0,0,0,0),b.Polygon=function(a){if(a instanceof Array||(a=Array.prototype.slice.call(arguments)),"number"==typeof a[0]){for(var c=[],d=0,e=a.length;e>d;d+=2)c.push(new b.Point(a[d],a[d+1]));a=c}this.points=a},b.Polygon.prototype.clone=function(){for(var a=[],c=0;c<this.points.length;c++)a.push(this.points[c].clone());return new b.Polygon(a)},b.Polygon.prototype.contains=function(a,b){for(var c=!1,d=0,e=this.points.length-1;d<this.points.length;e=d++){var f=this.points[d].x,g=this.points[d].y,h=this.points[e].x,i=this.points[e].y,j=g>b!=i>b&&(h-f)*(b-g)/(i-g)+f>a;j&&(c=!c)}return c},b.Polygon.prototype.constructor=b.Polygon,b.Circle=function(a,b,c){this.x=a||0,this.y=b||0,this.radius=c||0},b.Circle.prototype.clone=function(){return new b.Circle(this.x,this.y,this.radius)},b.Circle.prototype.contains=function(a,b){if(this.radius<=0)return!1;var c=this.x-a,d=this.y-b,e=this.radius*this.radius;return c*=c,d*=d,e>=c+d},b.Circle.prototype.getBounds=function(){return new b.Rectangle(this.x-this.radius,this.y-this.radius,this.width,this.height)},b.Circle.prototype.constructor=b.Circle,b.Ellipse=function(a,b,c,d){this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0},b.Ellipse.prototype.clone=function(){return new b.Ellipse(this.x,this.y,this.width,this.height)},b.Ellipse.prototype.contains=function(a,b){if(this.width<=0||this.height<=0)return!1;var c=(a-this.x)/this.width,d=(b-this.y)/this.height;return c*=c,d*=d,1>=c+d},b.Ellipse.prototype.getBounds=function(){return new b.Rectangle(this.x-this.width,this.y-this.height,this.width,this.height)},b.Ellipse.prototype.constructor=b.Ellipse,b.Matrix=function(){this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0},b.Matrix.prototype.fromArray=function(a){this.a=a[0],this.b=a[1],this.c=a[3],this.d=a[4],this.tx=a[2],this.ty=a[5]},b.Matrix.prototype.toArray=function(a){this.array||(this.array=new Float32Array(9));var b=this.array;return a?(b[0]=this.a,b[1]=this.c,b[2]=0,b[3]=this.b,b[4]=this.d,b[5]=0,b[6]=this.tx,b[7]=this.ty,b[8]=1):(b[0]=this.a,b[1]=this.b,b[2]=this.tx,b[3]=this.c,b[4]=this.d,b[5]=this.ty,b[6]=0,b[7]=0,b[8]=1),b},b.identityMatrix=new b.Matrix,b.determineMatrixArrayType=function(){return"undefined"!=typeof Float32Array?Float32Array:Array},b.Matrix2=b.determineMatrixArrayType(),b.DisplayObject=function(){this.position=new b.Point,this.scale=new b.Point(1,1),this.pivot=new b.Point(0,0),this.rotation=0,this.alpha=1,this.visible=!0,this.hitArea=null,this.buttonMode=!1,this.renderable=!1,this.parent=null,this.stage=null,this.worldAlpha=1,this._interactive=!1,this.defaultCursor="pointer",this.worldTransform=new b.Matrix,this.color=[],this.dynamic=!0,this._sr=0,this._cr=1,this.filterArea=null,this._bounds=new b.Rectangle(0,0,1,1),this._currentBounds=null,this._mask=null,this._cacheAsBitmap=!1,this._cacheIsDirty=!1},b.DisplayObject.prototype.constructor=b.DisplayObject,b.DisplayObject.prototype.setInteractive=function(a){this.interactive=a},Object.defineProperty(b.DisplayObject.prototype,"interactive",{get:function(){return this._interactive},set:function(a){this._interactive=a,this.stage&&(this.stage.dirty=!0)}}),Object.defineProperty(b.DisplayObject.prototype,"worldVisible",{get:function(){var a=this;do{if(!a.visible)return!1;a=a.parent}while(a);return!0}}),Object.defineProperty(b.DisplayObject.prototype,"mask",{get:function(){return this._mask},set:function(a){this._mask&&(this._mask.isMask=!1),this._mask=a,this._mask&&(this._mask.isMask=!0)}}),Object.defineProperty(b.DisplayObject.prototype,"filters",{get:function(){return this._filters},set:function(a){if(a){for(var b=[],c=0;c<a.length;c++)for(var d=a[c].passes,e=0;e<d.length;e++)b.push(d[e]);this._filterBlock={target:this,filterPasses:b}}this._filters=a}}),Object.defineProperty(b.DisplayObject.prototype,"cacheAsBitmap",{get:function(){return this._cacheAsBitmap},set:function(a){this._cacheAsBitmap!==a&&(a?this._generateCachedSprite():this._destroyCachedSprite(),this._cacheAsBitmap=a)}}),b.DisplayObject.prototype.updateTransform=function(){this.rotation!==this.rotationCache&&(this.rotationCache=this.rotation,this._sr=Math.sin(this.rotation),this._cr=Math.cos(this.rotation));var a=this.parent.worldTransform,b=this.worldTransform,c=this.pivot.x,d=this.pivot.y,e=this._cr*this.scale.x,f=-this._sr*this.scale.y,g=this._sr*this.scale.x,h=this._cr*this.scale.y,i=this.position.x-e*c-d*f,j=this.position.y-h*d-c*g,k=a.a,l=a.b,m=a.c,n=a.d;b.a=k*e+l*g,b.b=k*f+l*h,b.tx=k*i+l*j+a.tx,b.c=m*e+n*g,b.d=m*f+n*h,b.ty=m*i+n*j+a.ty,this.worldAlpha=this.alpha*this.parent.worldAlpha},b.DisplayObject.prototype.getBounds=function(a){return a=a,b.EmptyRectangle},b.DisplayObject.prototype.getLocalBounds=function(){return this.getBounds(b.identityMatrix)},b.DisplayObject.prototype.setStageReference=function(a){this.stage=a,this._interactive&&(this.stage.dirty=!0)},b.DisplayObject.prototype.generateTexture=function(a){var c=this.getLocalBounds(),d=new b.RenderTexture(0|c.width,0|c.height,a);return d.render(this,new b.Point(-c.x,-c.y)),d},b.DisplayObject.prototype.updateCache=function(){this._generateCachedSprite()},b.DisplayObject.prototype._renderCachedSprite=function(a){this._cachedSprite.worldAlpha=this.worldAlpha,a.gl?b.Sprite.prototype._renderWebGL.call(this._cachedSprite,a):b.Sprite.prototype._renderCanvas.call(this._cachedSprite,a)},b.DisplayObject.prototype._generateCachedSprite=function(){this._cacheAsBitmap=!1;var a=this.getLocalBounds();if(this._cachedSprite)this._cachedSprite.texture.resize(0|a.width,0|a.height);else{var c=new b.RenderTexture(0|a.width,0|a.height);this._cachedSprite=new b.Sprite(c),this._cachedSprite.worldTransform=this.worldTransform}var d=this._filters;this._filters=null,this._cachedSprite.filters=d,this._cachedSprite.texture.render(this,new b.Point(-a.x,-a.y)),this._cachedSprite.anchor.x=-(a.x/a.width),this._cachedSprite.anchor.y=-(a.y/a.height),this._filters=d,this._cacheAsBitmap=!0},b.DisplayObject.prototype._destroyCachedSprite=function(){this._cachedSprite&&(this._cachedSprite.texture.destroy(!0),this._cachedSprite=null)},b.DisplayObject.prototype._renderWebGL=function(a){a=a},b.DisplayObject.prototype._renderCanvas=function(a){a=a},Object.defineProperty(b.DisplayObject.prototype,"x",{get:function(){return this.position.x},set:function(a){this.position.x=a}}),Object.defineProperty(b.DisplayObject.prototype,"y",{get:function(){return this.position.y},set:function(a){this.position.y=a}}),b.DisplayObjectContainer=function(){b.DisplayObject.call(this),this.children=[]},b.DisplayObjectContainer.prototype=Object.create(b.DisplayObject.prototype),b.DisplayObjectContainer.prototype.constructor=b.DisplayObjectContainer,Object.defineProperty(b.DisplayObjectContainer.prototype,"width",{get:function(){return this.scale.x*this.getLocalBounds().width},set:function(a){var b=this.getLocalBounds().width;this.scale.x=0!==b?a/(b/this.scale.x):1,this._width=a}}),Object.defineProperty(b.DisplayObjectContainer.prototype,"height",{get:function(){return this.scale.y*this.getLocalBounds().height},set:function(a){var b=this.getLocalBounds().height;this.scale.y=0!==b?a/(b/this.scale.y):1,this._height=a}}),b.DisplayObjectContainer.prototype.addChild=function(a){return this.addChildAt(a,this.children.length)},b.DisplayObjectContainer.prototype.addChildAt=function(a,b){if(b>=0&&b<=this.children.length)return a.parent&&a.parent.removeChild(a),a.parent=this,this.children.splice(b,0,a),this.stage&&a.setStageReference(this.stage),a;throw new Error(a+" The index "+b+" supplied is out of bounds "+this.children.length)},b.DisplayObjectContainer.prototype.swapChildren=function(a,b){if(a!==b){var c=this.children.indexOf(a),d=this.children.indexOf(b);if(0>c||0>d)throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");this.children[c]=b,this.children[d]=a}},b.DisplayObjectContainer.prototype.getChildAt=function(a){if(a>=0&&a<this.children.length)return this.children[a];throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller")},b.DisplayObjectContainer.prototype.removeChild=function(a){return this.removeChildAt(this.children.indexOf(a))},b.DisplayObjectContainer.prototype.removeChildAt=function(a){var b=this.getChildAt(a);return this.stage&&b.removeStageReference(),b.parent=void 0,this.children.splice(a,1),b},b.DisplayObjectContainer.prototype.removeChildren=function(a,b){var c=a||0,d="number"==typeof b?b:this.children.length,e=d-c;if(e>0&&d>=e){for(var f=this.children.splice(c,e),g=0;g<f.length;g++){var h=f[g];this.stage&&h.removeStageReference(),h.parent=void 0}return f}throw new Error("Range Error, numeric values are outside the acceptable range")},b.DisplayObjectContainer.prototype.updateTransform=function(){if(this.visible&&(b.DisplayObject.prototype.updateTransform.call(this),!this._cacheAsBitmap))for(var a=0,c=this.children.length;c>a;a++)this.children[a].updateTransform()},b.DisplayObjectContainer.prototype.getBounds=function(a){if(0===this.children.length)return b.EmptyRectangle;if(a){var c=this.worldTransform;this.worldTransform=a,this.updateTransform(),this.worldTransform=c}for(var d,e,f,g=1/0,h=1/0,i=-1/0,j=-1/0,k=!1,l=0,m=this.children.length;m>l;l++){var n=this.children[l];n.visible&&(k=!0,d=this.children[l].getBounds(a),g=g<d.x?g:d.x,h=h<d.y?h:d.y,e=d.width+d.x,f=d.height+d.y,i=i>e?i:e,j=j>f?j:f)}if(!k)return b.EmptyRectangle;var o=this._bounds;return o.x=g,o.y=h,o.width=i-g,o.height=j-h,o},b.DisplayObjectContainer.prototype.getLocalBounds=function(){var a=this.worldTransform;this.worldTransform=b.identityMatrix;for(var c=0,d=this.children.length;d>c;c++)this.children[c].updateTransform();var e=this.getBounds();return this.worldTransform=a,e},b.DisplayObjectContainer.prototype.setStageReference=function(a){this.stage=a,this._interactive&&(this.stage.dirty=!0);for(var b=0,c=this.children.length;c>b;b++){var d=this.children[b];d.setStageReference(a)}},b.DisplayObjectContainer.prototype.removeStageReference=function(){for(var a=0,b=this.children.length;b>a;a++){var c=this.children[a];c.removeStageReference()}this._interactive&&(this.stage.dirty=!0),this.stage=null},b.DisplayObjectContainer.prototype._renderWebGL=function(a){if(this.visible&&!(this.alpha<=0)){if(this._cacheAsBitmap)return void this._renderCachedSprite(a);var b,c;if(this._mask||this._filters){for(this._filters&&(a.spriteBatch.flush(),a.filterManager.pushFilter(this._filterBlock)),this._mask&&(a.spriteBatch.stop(),a.maskManager.pushMask(this.mask,a),a.spriteBatch.start()),b=0,c=this.children.length;c>b;b++)this.children[b]._renderWebGL(a);a.spriteBatch.stop(),this._mask&&a.maskManager.popMask(this._mask,a),this._filters&&a.filterManager.popFilter(),a.spriteBatch.start()}else for(b=0,c=this.children.length;c>b;b++)this.children[b]._renderWebGL(a)}},b.DisplayObjectContainer.prototype._renderCanvas=function(a){if(this.visible!==!1&&0!==this.alpha){if(this._cacheAsBitmap)return void this._renderCachedSprite(a);this._mask&&a.maskManager.pushMask(this._mask,a.context);for(var b=0,c=this.children.length;c>b;b++){var d=this.children[b];d._renderCanvas(a)}this._mask&&a.maskManager.popMask(a.context)}},b.Sprite=function(a){b.DisplayObjectContainer.call(this),this.anchor=new b.Point,this.texture=a,this._width=0,this._height=0,this.tint=16777215,this.blendMode=b.blendModes.NORMAL,a.baseTexture.hasLoaded?this.onTextureUpdate():(this.onTextureUpdateBind=this.onTextureUpdate.bind(this),this.texture.addEventListener("update",this.onTextureUpdateBind)),this.renderable=!0},b.Sprite.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Sprite.prototype.constructor=b.Sprite,Object.defineProperty(b.Sprite.prototype,"width",{get:function(){return this.scale.x*this.texture.frame.width},set:function(a){this.scale.x=a/this.texture.frame.width,this._width=a}}),Object.defineProperty(b.Sprite.prototype,"height",{get:function(){return this.scale.y*this.texture.frame.height},set:function(a){this.scale.y=a/this.texture.frame.height,this._height=a}}),b.Sprite.prototype.setTexture=function(a){this.texture=a,this.cachedTint=16777215},b.Sprite.prototype.onTextureUpdate=function(){this._width&&(this.scale.x=this._width/this.texture.frame.width),this._height&&(this.scale.y=this._height/this.texture.frame.height)},b.Sprite.prototype.getBounds=function(a){var b=this.texture.frame.width,c=this.texture.frame.height,d=b*(1-this.anchor.x),e=b*-this.anchor.x,f=c*(1-this.anchor.y),g=c*-this.anchor.y,h=a||this.worldTransform,i=h.a,j=h.c,k=h.b,l=h.d,m=h.tx,n=h.ty,o=i*e+k*g+m,p=l*g+j*e+n,q=i*d+k*g+m,r=l*g+j*d+n,s=i*d+k*f+m,t=l*f+j*d+n,u=i*e+k*f+m,v=l*f+j*e+n,w=-1/0,x=-1/0,y=1/0,z=1/0;y=y>o?o:y,y=y>q?q:y,y=y>s?s:y,y=y>u?u:y,z=z>p?p:z,z=z>r?r:z,z=z>t?t:z,z=z>v?v:z,w=o>w?o:w,w=q>w?q:w,w=s>w?s:w,w=u>w?u:w,x=p>x?p:x,x=r>x?r:x,x=t>x?t:x,x=v>x?v:x;var A=this._bounds;return A.x=y,A.width=w-y,A.y=z,A.height=x-z,this._currentBounds=A,A},b.Sprite.prototype._renderWebGL=function(a){if(this.visible&&!(this.alpha<=0)){var b,c;if(this._mask||this._filters){var d=a.spriteBatch;for(this._filters&&(d.flush(),a.filterManager.pushFilter(this._filterBlock)),this._mask&&(d.stop(),a.maskManager.pushMask(this.mask,a),d.start()),d.render(this),b=0,c=this.children.length;c>b;b++)this.children[b]._renderWebGL(a);d.stop(),this._mask&&a.maskManager.popMask(this._mask,a),this._filters&&a.filterManager.popFilter(),d.start()}else for(a.spriteBatch.render(this),b=0,c=this.children.length;c>b;b++)this.children[b]._renderWebGL(a)}},b.Sprite.prototype._renderCanvas=function(a){if(this.visible!==!1&&0!==this.alpha){if(this.blendMode!==a.currentBlendMode&&(a.currentBlendMode=this.blendMode,a.context.globalCompositeOperation=b.blendModesCanvas[a.currentBlendMode]),this._mask&&a.maskManager.pushMask(this._mask,a.context),this.texture.valid){a.context.globalAlpha=this.worldAlpha,a.roundPixels?a.context.setTransform(this.worldTransform.a,this.worldTransform.c,this.worldTransform.b,this.worldTransform.d,0|this.worldTransform.tx,0|this.worldTransform.ty):a.context.setTransform(this.worldTransform.a,this.worldTransform.c,this.worldTransform.b,this.worldTransform.d,this.worldTransform.tx,this.worldTransform.ty),a.smoothProperty&&a.scaleMode!==this.texture.baseTexture.scaleMode&&(a.scaleMode=this.texture.baseTexture.scaleMode,a.context[a.smoothProperty]=a.scaleMode===b.scaleModes.LINEAR);var c=this.texture.trim?this.texture.trim.x-this.anchor.x*this.texture.trim.width:this.anchor.x*-this.texture.frame.width,d=this.texture.trim?this.texture.trim.y-this.anchor.y*this.texture.trim.height:this.anchor.y*-this.texture.frame.height;16777215!==this.tint?(this.cachedTint!==this.tint&&(this.cachedTint=this.tint,this.tintedTexture=b.CanvasTinter.getTintedTexture(this,this.tint)),a.context.drawImage(this.tintedTexture,0,0,this.texture.crop.width,this.texture.crop.height,c,d,this.texture.crop.width,this.texture.crop.height)):a.context.drawImage(this.texture.baseTexture.source,this.texture.crop.x,this.texture.crop.y,this.texture.crop.width,this.texture.crop.height,c,d,this.texture.crop.width,this.texture.crop.height)}for(var e=0,f=this.children.length;f>e;e++)this.children[e]._renderCanvas(a);this._mask&&a.maskManager.popMask(a.context)}},b.Sprite.fromFrame=function(a){var c=b.TextureCache[a];if(!c)throw new Error('The frameId "'+a+'" does not exist in the texture cache'+this);return new b.Sprite(c)},b.Sprite.fromImage=function(a,c,d){var e=b.Texture.fromImage(a,c,d);return new b.Sprite(e)},b.SpriteBatch=function(a){b.DisplayObjectContainer.call(this),this.textureThing=a,this.ready=!1},b.SpriteBatch.prototype=Object.create(b.DisplayObjectContainer.prototype),b.SpriteBatch.constructor=b.SpriteBatch,b.SpriteBatch.prototype.initWebGL=function(a){this.fastSpriteBatch=new b.WebGLFastSpriteBatch(a),this.ready=!0},b.SpriteBatch.prototype.updateTransform=function(){b.DisplayObject.prototype.updateTransform.call(this)},b.SpriteBatch.prototype._renderWebGL=function(a){!this.visible||this.alpha<=0||!this.children.length||(this.ready||this.initWebGL(a.gl),a.spriteBatch.stop(),a.shaderManager.setShader(a.shaderManager.fastShader),this.fastSpriteBatch.begin(this,a),this.fastSpriteBatch.render(this),a.spriteBatch.start())},b.SpriteBatch.prototype._renderCanvas=function(a){var c=a.context;c.globalAlpha=this.worldAlpha,b.DisplayObject.prototype.updateTransform.call(this);for(var d=this.worldTransform,e=!0,f=0;f<this.children.length;f++){var g=this.children[f];if(g.visible){var h=g.texture,i=h.frame;if(c.globalAlpha=this.worldAlpha*g.alpha,g.rotation%(2*Math.PI)===0)e&&(c.setTransform(d.a,d.c,d.b,d.d,d.tx,d.ty),e=!1),c.drawImage(h.baseTexture.source,i.x,i.y,i.width,i.height,g.anchor.x*-i.width*g.scale.x+g.position.x+.5|0,g.anchor.y*-i.height*g.scale.y+g.position.y+.5|0,i.width*g.scale.x,i.height*g.scale.y);else{e||(e=!0),b.DisplayObject.prototype.updateTransform.call(g);var j=g.worldTransform;a.roundPixels?c.setTransform(j.a,j.c,j.b,j.d,0|j.tx,0|j.ty):c.setTransform(j.a,j.c,j.b,j.d,j.tx,j.ty),c.drawImage(h.baseTexture.source,i.x,i.y,i.width,i.height,g.anchor.x*-i.width+.5|0,g.anchor.y*-i.height+.5|0,i.width,i.height)}}}},b.MovieClip=function(a){b.Sprite.call(this,a[0]),this.textures=a,this.animationSpeed=1,this.loop=!0,this.onComplete=null,this.currentFrame=0,this.playing=!1},b.MovieClip.prototype=Object.create(b.Sprite.prototype),b.MovieClip.prototype.constructor=b.MovieClip,Object.defineProperty(b.MovieClip.prototype,"totalFrames",{get:function(){return this.textures.length}}),b.MovieClip.prototype.stop=function(){this.playing=!1},b.MovieClip.prototype.play=function(){this.playing=!0},b.MovieClip.prototype.gotoAndStop=function(a){this.playing=!1,this.currentFrame=a;var b=this.currentFrame+.5|0;this.setTexture(this.textures[b%this.textures.length])},b.MovieClip.prototype.gotoAndPlay=function(a){this.currentFrame=a,this.playing=!0},b.MovieClip.prototype.updateTransform=function(){if(b.Sprite.prototype.updateTransform.call(this),this.playing){this.currentFrame+=this.animationSpeed;var a=this.currentFrame+.5|0;this.currentFrame=this.currentFrame%this.textures.length,this.loop||a<this.textures.length?this.setTexture(this.textures[a%this.textures.length]):a>=this.textures.length&&(this.gotoAndStop(this.textures.length-1),this.onComplete&&this.onComplete())}},b.MovieClip.fromFrames=function(a){for(var c=[],d=0;d<a.length;d++)c.push(new b.Texture.fromFrame(a[d]));return new b.MovieClip(c)},b.MovieClip.fromImages=function(a){for(var c=[],d=0;d<a.length;d++)c.push(new b.Texture.fromImage(a[d]));return new b.MovieClip(c)},b.FilterBlock=function(){this.visible=!0,this.renderable=!0},b.Text=function(a,c){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),b.Sprite.call(this,b.Texture.fromCanvas(this.canvas)),this.setText(a),this.setStyle(c)},b.Text.prototype=Object.create(b.Sprite.prototype),b.Text.prototype.constructor=b.Text,Object.defineProperty(b.Text.prototype,"width",{get:function(){return this.dirty&&(this.updateText(),this.dirty=!1),this.scale.x*this.texture.frame.width},set:function(a){this.scale.x=a/this.texture.frame.width,this._width=a}}),Object.defineProperty(b.Text.prototype,"height",{get:function(){return this.dirty&&(this.updateText(),this.dirty=!1),this.scale.y*this.texture.frame.height},set:function(a){this.scale.y=a/this.texture.frame.height,this._height=a}}),b.Text.prototype.setStyle=function(a){a=a||{},a.font=a.font||"bold 20pt Arial",a.fill=a.fill||"black",a.align=a.align||"left",a.stroke=a.stroke||"black",a.strokeThickness=a.strokeThickness||0,a.wordWrap=a.wordWrap||!1,a.wordWrapWidth=a.wordWrapWidth||100,a.wordWrapWidth=a.wordWrapWidth||100,a.dropShadow=a.dropShadow||!1,a.dropShadowAngle=a.dropShadowAngle||Math.PI/6,a.dropShadowDistance=a.dropShadowDistance||4,a.dropShadowColor=a.dropShadowColor||"black",this.style=a,this.dirty=!0},b.Text.prototype.setText=function(a){this.text=a.toString()||" ",this.dirty=!0},b.Text.prototype.updateText=function(){this.context.font=this.style.font;var a=this.text;this.style.wordWrap&&(a=this.wordWrap(this.text));for(var b=a.split(/(?:\r\n|\r|\n)/),c=[],d=0,e=0;e<b.length;e++){var f=this.context.measureText(b[e]).width;c[e]=f,d=Math.max(d,f)}var g=d+this.style.strokeThickness;this.style.dropShadow&&(g+=this.style.dropShadowDistance),this.canvas.width=g+this.context.lineWidth;var h=this.determineFontHeight("font: "+this.style.font+";")+this.style.strokeThickness,i=h*b.length;this.style.dropShadow&&(i+=this.style.dropShadowDistance),this.canvas.height=i,navigator.isCocoonJS&&this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.context.font=this.style.font,this.context.strokeStyle=this.style.stroke,this.context.lineWidth=this.style.strokeThickness,this.context.textBaseline="top";var j,k;if(this.style.dropShadow){this.context.fillStyle=this.style.dropShadowColor;var l=Math.sin(this.style.dropShadowAngle)*this.style.dropShadowDistance,m=Math.cos(this.style.dropShadowAngle)*this.style.dropShadowDistance;for(e=0;e<b.length;e++)j=this.style.strokeThickness/2,k=this.style.strokeThickness/2+e*h,"right"===this.style.align?j+=d-c[e]:"center"===this.style.align&&(j+=(d-c[e])/2),this.style.fill&&this.context.fillText(b[e],j+l,k+m)}for(this.context.fillStyle=this.style.fill,e=0;e<b.length;e++)j=this.style.strokeThickness/2,k=this.style.strokeThickness/2+e*h,"right"===this.style.align?j+=d-c[e]:"center"===this.style.align&&(j+=(d-c[e])/2),this.style.stroke&&this.style.strokeThickness&&this.context.strokeText(b[e],j,k),this.style.fill&&this.context.fillText(b[e],j,k);this.updateTexture()},b.Text.prototype.updateTexture=function(){this.texture.baseTexture.width=this.canvas.width,this.texture.baseTexture.height=this.canvas.height,this.texture.crop.width=this.texture.frame.width=this.canvas.width,this.texture.crop.height=this.texture.frame.height=this.canvas.height,this._width=this.canvas.width,this._height=this.canvas.height,this.requiresUpdate=!0},b.Text.prototype._renderWebGL=function(a){this.requiresUpdate&&(this.requiresUpdate=!1,b.updateWebGLTexture(this.texture.baseTexture,a.gl)),b.Sprite.prototype._renderWebGL.call(this,a)},b.Text.prototype.updateTransform=function(){this.dirty&&(this.updateText(),this.dirty=!1),b.Sprite.prototype.updateTransform.call(this)},b.Text.prototype.determineFontHeight=function(a){var c=b.Text.heightCache[a];if(!c){var d=document.getElementsByTagName("body")[0],e=document.createElement("div"),f=document.createTextNode("M");e.appendChild(f),e.setAttribute("style",a+";position:absolute;top:0;left:0"),d.appendChild(e),c=e.offsetHeight,b.Text.heightCache[a]=c,d.removeChild(e)}return c},b.Text.prototype.wordWrap=function(a){for(var b="",c=a.split("\n"),d=0;d<c.length;d++){for(var e=this.style.wordWrapWidth,f=c[d].split(" "),g=0;g<f.length;g++){var h=this.context.measureText(f[g]).width,i=h+this.context.measureText(" ").width;0===g||i>e?(g>0&&(b+="\n"),b+=f[g],e=this.style.wordWrapWidth-h):(e-=i,b+=" "+f[g])}d<c.length-1&&(b+="\n")}return b},b.Text.prototype.destroy=function(a){this.context=null,this.canvas=null,this.texture.destroy(void 0===a?!0:a)},b.Text.heightCache={},b.BitmapText=function(a,c){b.DisplayObjectContainer.call(this),this._pool=[],this.setText(a),this.setStyle(c),this.updateText(),this.dirty=!1},b.BitmapText.prototype=Object.create(b.DisplayObjectContainer.prototype),b.BitmapText.prototype.constructor=b.BitmapText,b.BitmapText.prototype.setText=function(a){this.text=a||" ",this.dirty=!0},b.BitmapText.prototype.setStyle=function(a){a=a||{},a.align=a.align||"left",this.style=a;var c=a.font.split(" ");this.fontName=c[c.length-1],this.fontSize=c.length>=2?parseInt(c[c.length-2],10):b.BitmapText.fonts[this.fontName].size,this.dirty=!0,this.tint=a.tint},b.BitmapText.prototype.updateText=function(){for(var a=b.BitmapText.fonts[this.fontName],c=new b.Point,d=null,e=[],f=0,g=[],h=0,i=this.fontSize/a.size,j=0;j<this.text.length;j++){var k=this.text.charCodeAt(j);if(/(?:\r\n|\r|\n)/.test(this.text.charAt(j)))g.push(c.x),f=Math.max(f,c.x),h++,c.x=0,c.y+=a.lineHeight,d=null;else{var l=a.chars[k];l&&(d&&l[d]&&(c.x+=l.kerning[d]),e.push({texture:l.texture,line:h,charCode:k,position:new b.Point(c.x+l.xOffset,c.y+l.yOffset)}),c.x+=l.xAdvance,d=k)}}g.push(c.x),f=Math.max(f,c.x);var m=[];for(j=0;h>=j;j++){var n=0;"right"===this.style.align?n=f-g[j]:"center"===this.style.align&&(n=(f-g[j])/2),m.push(n)}var o=this.children.length,p=e.length,q=this.tint||16777215;for(j=0;p>j;j++){var r=o>j?this.children[j]:this._pool.pop();r?r.setTexture(e[j].texture):r=new b.Sprite(e[j].texture),r.position.x=(e[j].position.x+m[e[j].line])*i,r.position.y=e[j].position.y*i,r.scale.x=r.scale.y=i,r.tint=q,r.parent||this.addChild(r)}for(;this.children.length>p;){var s=this.getChildAt(this.children.length-1);this._pool.push(s),this.removeChild(s)}this.textWidth=f*i,this.textHeight=(c.y+a.lineHeight)*i},b.BitmapText.prototype.updateTransform=function(){this.dirty&&(this.updateText(),this.dirty=!1),b.DisplayObjectContainer.prototype.updateTransform.call(this)},b.BitmapText.fonts={},b.InteractionData=function(){this.global=new b.Point,this.target=null,this.originalEvent=null},b.InteractionData.prototype.getLocalPosition=function(a){var c=a.worldTransform,d=this.global,e=c.a,f=c.b,g=c.tx,h=c.c,i=c.d,j=c.ty,k=1/(e*i+f*-h);return new b.Point(i*k*d.x+-f*k*d.y+(j*f-g*i)*k,e*k*d.y+-h*k*d.x+(-j*e+g*h)*k)},b.InteractionData.prototype.constructor=b.InteractionData,b.InteractionManager=function(a){this.stage=a,this.mouse=new b.InteractionData,this.touchs={},this.tempPoint=new b.Point,this.mouseoverEnabled=!0,this.pool=[],this.interactiveItems=[],this.interactionDOMElement=null,this.onMouseMove=this.onMouseMove.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseOut=this.onMouseOut.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.last=0,this.currentCursorStyle="inherit",this.mouseOut=!1},b.InteractionManager.prototype.constructor=b.InteractionManager,b.InteractionManager.prototype.collectInteractiveSprite=function(a,b){for(var c=a.children,d=c.length,e=d-1;e>=0;e--){var f=c[e];f._interactive?(b.interactiveChildren=!0,this.interactiveItems.push(f),f.children.length>0&&this.collectInteractiveSprite(f,f)):(f.__iParent=null,f.children.length>0&&this.collectInteractiveSprite(f,b))}},b.InteractionManager.prototype.setTarget=function(a){this.target=a,null===this.interactionDOMElement&&this.setTargetDomElement(a.view)},b.InteractionManager.prototype.setTargetDomElement=function(a){this.removeEvents(),window.navigator.msPointerEnabled&&(a.style["-ms-content-zooming"]="none",a.style["-ms-touch-action"]="none"),this.interactionDOMElement=a,a.addEventListener("mousemove",this.onMouseMove,!0),a.addEventListener("mousedown",this.onMouseDown,!0),a.addEventListener("mouseout",this.onMouseOut,!0),a.addEventListener("touchstart",this.onTouchStart,!0),a.addEventListener("touchend",this.onTouchEnd,!0),a.addEventListener("touchmove",this.onTouchMove,!0),window.addEventListener("mouseup",this.onMouseUp,!0)},b.InteractionManager.prototype.removeEvents=function(){this.interactionDOMElement&&(this.interactionDOMElement.style["-ms-content-zooming"]="",this.interactionDOMElement.style["-ms-touch-action"]="",this.interactionDOMElement.removeEventListener("mousemove",this.onMouseMove,!0),this.interactionDOMElement.removeEventListener("mousedown",this.onMouseDown,!0),this.interactionDOMElement.removeEventListener("mouseout",this.onMouseOut,!0),this.interactionDOMElement.removeEventListener("touchstart",this.onTouchStart,!0),this.interactionDOMElement.removeEventListener("touchend",this.onTouchEnd,!0),this.interactionDOMElement.removeEventListener("touchmove",this.onTouchMove,!0),this.interactionDOMElement=null,window.removeEventListener("mouseup",this.onMouseUp,!0))},b.InteractionManager.prototype.update=function(){if(this.target){var a=Date.now(),c=a-this.last;if(c=c*b.INTERACTION_FREQUENCY/1e3,!(1>c)){this.last=a;var d=0;this.dirty&&this.rebuildInteractiveGraph();var e=this.interactiveItems.length,f="inherit",g=!1;for(d=0;e>d;d++){var h=this.interactiveItems[d];h.__hit=this.hitTest(h,this.mouse),this.mouse.target=h,h.__hit&&!g?(h.buttonMode&&(f=h.defaultCursor),h.interactiveChildren||(g=!0),h.__isOver||(h.mouseover&&h.mouseover(this.mouse),h.__isOver=!0)):h.__isOver&&(h.mouseout&&h.mouseout(this.mouse),h.__isOver=!1)}this.currentCursorStyle!==f&&(this.currentCursorStyle=f,this.interactionDOMElement.style.cursor=f)}}},b.InteractionManager.prototype.rebuildInteractiveGraph=function(){this.dirty=!1;for(var a=this.interactiveItems.length,b=0;a>b;b++)this.interactiveItems[b].interactiveChildren=!1;this.interactiveItems=[],this.stage.interactive&&this.interactiveItems.push(this.stage),this.collectInteractiveSprite(this.stage,this.stage)},b.InteractionManager.prototype.onMouseMove=function(a){this.dirty&&this.rebuildInteractiveGraph(),this.mouse.originalEvent=a||window.event;var b=this.interactionDOMElement.getBoundingClientRect();this.mouse.global.x=(a.clientX-b.left)*(this.target.width/b.width),this.mouse.global.y=(a.clientY-b.top)*(this.target.height/b.height);for(var c=this.interactiveItems.length,d=0;c>d;d++){var e=this.interactiveItems[d];e.mousemove&&e.mousemove(this.mouse)}},b.InteractionManager.prototype.onMouseDown=function(a){this.dirty&&this.rebuildInteractiveGraph(),this.mouse.originalEvent=a||window.event,b.AUTO_PREVENT_DEFAULT&&this.mouse.originalEvent.preventDefault();for(var c=this.interactiveItems.length,d=0;c>d;d++){var e=this.interactiveItems[d];if((e.mousedown||e.click)&&(e.__mouseIsDown=!0,e.__hit=this.hitTest(e,this.mouse),e.__hit&&(e.mousedown&&e.mousedown(this.mouse),e.__isDown=!0,!e.interactiveChildren)))break}},b.InteractionManager.prototype.onMouseOut=function(){this.dirty&&this.rebuildInteractiveGraph();var a=this.interactiveItems.length;this.interactionDOMElement.style.cursor="inherit";for(var b=0;a>b;b++){var c=this.interactiveItems[b];c.__isOver&&(this.mouse.target=c,c.mouseout&&c.mouseout(this.mouse),c.__isOver=!1)}this.mouseOut=!0,this.mouse.global.x=-1e4,this.mouse.global.y=-1e4},b.InteractionManager.prototype.onMouseUp=function(a){this.dirty&&this.rebuildInteractiveGraph(),this.mouse.originalEvent=a||window.event;
for(var b=this.interactiveItems.length,c=!1,d=0;b>d;d++){var e=this.interactiveItems[d];e.__hit=this.hitTest(e,this.mouse),e.__hit&&!c?(e.mouseup&&e.mouseup(this.mouse),e.__isDown&&e.click&&e.click(this.mouse),e.interactiveChildren||(c=!0)):e.__isDown&&e.mouseupoutside&&e.mouseupoutside(this.mouse),e.__isDown=!1}},b.InteractionManager.prototype.hitTest=function(a,c){var d=c.global;if(!a.worldVisible)return!1;var e=a instanceof b.Sprite,f=a.worldTransform,g=f.a,h=f.b,i=f.tx,j=f.c,k=f.d,l=f.ty,m=1/(g*k+h*-j),n=k*m*d.x+-h*m*d.y+(l*h-i*k)*m,o=g*m*d.y+-j*m*d.x+(-l*g+i*j)*m;if(c.target=a,a.hitArea&&a.hitArea.contains)return a.hitArea.contains(n,o)?(c.target=a,!0):!1;if(e){var p,q=a.texture.frame.width,r=a.texture.frame.height,s=-q*a.anchor.x;if(n>s&&s+q>n&&(p=-r*a.anchor.y,o>p&&p+r>o))return c.target=a,!0}for(var t=a.children.length,u=0;t>u;u++){var v=a.children[u],w=this.hitTest(v,c);if(w)return c.target=a,!0}return!1},b.InteractionManager.prototype.onTouchMove=function(a){this.dirty&&this.rebuildInteractiveGraph();var b,c=this.interactionDOMElement.getBoundingClientRect(),d=a.changedTouches,e=0;for(e=0;e<d.length;e++){var f=d[e];b=this.touchs[f.identifier],b.originalEvent=a||window.event,b.global.x=(f.clientX-c.left)*(this.target.width/c.width),b.global.y=(f.clientY-c.top)*(this.target.height/c.height),navigator.isCocoonJS&&(b.global.x=f.clientX,b.global.y=f.clientY);for(var g=0;g<this.interactiveItems.length;g++){var h=this.interactiveItems[g];h.touchmove&&h.__touchData&&h.__touchData[f.identifier]&&h.touchmove(b)}}},b.InteractionManager.prototype.onTouchStart=function(a){this.dirty&&this.rebuildInteractiveGraph();var c=this.interactionDOMElement.getBoundingClientRect();b.AUTO_PREVENT_DEFAULT&&a.preventDefault();for(var d=a.changedTouches,e=0;e<d.length;e++){var f=d[e],g=this.pool.pop();g||(g=new b.InteractionData),g.originalEvent=a||window.event,this.touchs[f.identifier]=g,g.global.x=(f.clientX-c.left)*(this.target.width/c.width),g.global.y=(f.clientY-c.top)*(this.target.height/c.height),navigator.isCocoonJS&&(g.global.x=f.clientX,g.global.y=f.clientY);for(var h=this.interactiveItems.length,i=0;h>i;i++){var j=this.interactiveItems[i];if((j.touchstart||j.tap)&&(j.__hit=this.hitTest(j,g),j.__hit&&(j.touchstart&&j.touchstart(g),j.__isDown=!0,j.__touchData=j.__touchData||{},j.__touchData[f.identifier]=g,!j.interactiveChildren)))break}}},b.InteractionManager.prototype.onTouchEnd=function(a){this.dirty&&this.rebuildInteractiveGraph();for(var b=this.interactionDOMElement.getBoundingClientRect(),c=a.changedTouches,d=0;d<c.length;d++){var e=c[d],f=this.touchs[e.identifier],g=!1;f.global.x=(e.clientX-b.left)*(this.target.width/b.width),f.global.y=(e.clientY-b.top)*(this.target.height/b.height),navigator.isCocoonJS&&(f.global.x=e.clientX,f.global.y=e.clientY);for(var h=this.interactiveItems.length,i=0;h>i;i++){var j=this.interactiveItems[i];j.__touchData&&j.__touchData[e.identifier]&&(j.__hit=this.hitTest(j,j.__touchData[e.identifier]),f.originalEvent=a||window.event,(j.touchend||j.tap)&&(j.__hit&&!g?(j.touchend&&j.touchend(f),j.__isDown&&j.tap&&j.tap(f),j.interactiveChildren||(g=!0)):j.__isDown&&j.touchendoutside&&j.touchendoutside(f),j.__isDown=!1),j.__touchData[e.identifier]=null)}this.pool.push(f),this.touchs[e.identifier]=null}},b.Stage=function(a){b.DisplayObjectContainer.call(this),this.worldTransform=new b.Matrix,this.interactive=!0,this.interactionManager=new b.InteractionManager(this),this.dirty=!0,this.stage=this,this.stage.hitArea=new b.Rectangle(0,0,1e5,1e5),this.setBackgroundColor(a)},b.Stage.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Stage.prototype.constructor=b.Stage,b.Stage.prototype.setInteractionDelegate=function(a){this.interactionManager.setTargetDomElement(a)},b.Stage.prototype.updateTransform=function(){this.worldAlpha=1;for(var a=0,b=this.children.length;b>a;a++)this.children[a].updateTransform();this.dirty&&(this.dirty=!1,this.interactionManager.dirty=!0),this.interactive&&this.interactionManager.update()},b.Stage.prototype.setBackgroundColor=function(a){this.backgroundColor=a||0,this.backgroundColorSplit=b.hex2rgb(this.backgroundColor);var c=this.backgroundColor.toString(16);c="000000".substr(0,6-c.length)+c,this.backgroundColorString="#"+c},b.Stage.prototype.getMousePosition=function(){return this.interactionManager.mouse.global};for(var c=0,d=["ms","moz","webkit","o"],e=0;e<d.length&&!window.requestAnimationFrame;++e)window.requestAnimationFrame=window[d[e]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[d[e]+"CancelAnimationFrame"]||window[d[e]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(a){var b=(new Date).getTime(),d=Math.max(0,16-(b-c)),e=window.setTimeout(function(){a(b+d)},d);return c=b+d,e}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(a){clearTimeout(a)}),window.requestAnimFrame=window.requestAnimationFrame,b.hex2rgb=function(a){return[(a>>16&255)/255,(a>>8&255)/255,(255&a)/255]},b.rgb2hex=function(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]},"function"!=typeof Function.prototype.bind&&(Function.prototype.bind=function(){var a=Array.prototype.slice;return function(b){function c(){var f=e.concat(a.call(arguments));d.apply(this instanceof c?this:b,f)}var d=this,e=a.call(arguments,1);if("function"!=typeof d)throw new TypeError;return c.prototype=function f(a){return a&&(f.prototype=a),this instanceof f?void 0:new f}(d.prototype),c}}()),b.AjaxRequest=function(){var a=["Msxml2.XMLHTTP.6.0","Msxml2.XMLHTTP.3.0","Microsoft.XMLHTTP"];if(!window.ActiveXObject)return window.XMLHttpRequest?new window.XMLHttpRequest:!1;for(var b=0;b<a.length;b++)try{return new window.ActiveXObject(a[b])}catch(c){}},b.canUseNewCanvasBlendModes=function(){var a=document.createElement("canvas");a.width=1,a.height=1;var b=a.getContext("2d");return b.fillStyle="#000",b.fillRect(0,0,1,1),b.globalCompositeOperation="multiply",b.fillStyle="#fff",b.fillRect(0,0,1,1),0===b.getImageData(0,0,1,1).data[0]},b.getNextPowerOfTwo=function(a){if(a>0&&0===(a&a-1))return a;for(var b=1;a>b;)b<<=1;return b},b.EventTarget=function(){var a={};this.addEventListener=this.on=function(b,c){void 0===a[b]&&(a[b]=[]),-1===a[b].indexOf(c)&&a[b].unshift(c)},this.dispatchEvent=this.emit=function(b){if(a[b.type]&&a[b.type].length)for(var c=a[b.type].length-1;c>=0;c--)a[b.type][c](b)},this.removeEventListener=this.off=function(b,c){if(void 0!==a[b]){var d=a[b].indexOf(c);-1!==d&&a[b].splice(d,1)}},this.removeAllEventListeners=function(b){var c=a[b];c&&(c.length=0)}},b.autoDetectRenderer=function(a,c,d,e,f){a||(a=800),c||(c=600);var g=function(){try{var a=document.createElement("canvas");return!!window.WebGLRenderingContext&&(a.getContext("webgl")||a.getContext("experimental-webgl"))}catch(b){return!1}}();return g?new b.WebGLRenderer(a,c,d,e,f):new b.CanvasRenderer(a,c,d,e)},b.autoDetectRecommendedRenderer=function(a,c,d,e,f){a||(a=800),c||(c=600);var g=function(){try{var a=document.createElement("canvas");return!!window.WebGLRenderingContext&&(a.getContext("webgl")||a.getContext("experimental-webgl"))}catch(b){return!1}}(),h=/Android/i.test(navigator.userAgent);return g&&!h?new b.WebGLRenderer(a,c,d,e,f):new b.CanvasRenderer(a,c,d,e)},b.PolyK={},b.PolyK.Triangulate=function(a){var c=!0,d=a.length>>1;if(3>d)return[];for(var e=[],f=[],g=0;d>g;g++)f.push(g);g=0;for(var h=d;h>3;){var i=f[(g+0)%h],j=f[(g+1)%h],k=f[(g+2)%h],l=a[2*i],m=a[2*i+1],n=a[2*j],o=a[2*j+1],p=a[2*k],q=a[2*k+1],r=!1;if(b.PolyK._convex(l,m,n,o,p,q,c)){r=!0;for(var s=0;h>s;s++){var t=f[s];if(t!==i&&t!==j&&t!==k&&b.PolyK._PointInTriangle(a[2*t],a[2*t+1],l,m,n,o,p,q)){r=!1;break}}}if(r)e.push(i,j,k),f.splice((g+1)%h,1),h--,g=0;else if(g++>3*h){if(!c)return window.console.log("PIXI Warning: shape too complex to fill"),[];for(e=[],f=[],g=0;d>g;g++)f.push(g);g=0,h=d,c=!1}}return e.push(f[0],f[1],f[2]),e},b.PolyK._PointInTriangle=function(a,b,c,d,e,f,g,h){var i=g-c,j=h-d,k=e-c,l=f-d,m=a-c,n=b-d,o=i*i+j*j,p=i*k+j*l,q=i*m+j*n,r=k*k+l*l,s=k*m+l*n,t=1/(o*r-p*p),u=(r*q-p*s)*t,v=(o*s-p*q)*t;return u>=0&&v>=0&&1>u+v},b.PolyK._convex=function(a,b,c,d,e,f,g){return(b-d)*(e-c)+(c-a)*(f-d)>=0===g},b.initDefaultShaders=function(){},b.CompileVertexShader=function(a,c){return b._CompileShader(a,c,a.VERTEX_SHADER)},b.CompileFragmentShader=function(a,c){return b._CompileShader(a,c,a.FRAGMENT_SHADER)},b._CompileShader=function(a,b,c){var d=b.join("\n"),e=a.createShader(c);return a.shaderSource(e,d),a.compileShader(e),a.getShaderParameter(e,a.COMPILE_STATUS)?e:(window.console.log(a.getShaderInfoLog(e)),null)},b.compileProgram=function(a,c,d){var e=b.CompileFragmentShader(a,d),f=b.CompileVertexShader(a,c),g=a.createProgram();return a.attachShader(g,f),a.attachShader(g,e),a.linkProgram(g),a.getProgramParameter(g,a.LINK_STATUS)||window.console.log("Could not initialise shaders"),g},b.PixiShader=function(a){this._UID=b._UID++,this.gl=a,this.program=null,this.fragmentSrc=["precision lowp float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;","}"],this.textureCount=0,this.attributes=[],this.init()},b.PixiShader.prototype.init=function(){var a=this.gl,c=b.compileProgram(a,this.vertexSrc||b.PixiShader.defaultVertexSrc,this.fragmentSrc);a.useProgram(c),this.uSampler=a.getUniformLocation(c,"uSampler"),this.projectionVector=a.getUniformLocation(c,"projectionVector"),this.offsetVector=a.getUniformLocation(c,"offsetVector"),this.dimensions=a.getUniformLocation(c,"dimensions"),this.aVertexPosition=a.getAttribLocation(c,"aVertexPosition"),this.aTextureCoord=a.getAttribLocation(c,"aTextureCoord"),this.colorAttribute=a.getAttribLocation(c,"aColor"),-1===this.colorAttribute&&(this.colorAttribute=2),this.attributes=[this.aVertexPosition,this.aTextureCoord,this.colorAttribute];for(var d in this.uniforms)this.uniforms[d].uniformLocation=a.getUniformLocation(c,d);this.initUniforms(),this.program=c},b.PixiShader.prototype.initUniforms=function(){this.textureCount=1;var a,b=this.gl;for(var c in this.uniforms){a=this.uniforms[c];var d=a.type;"sampler2D"===d?(a._init=!1,null!==a.value&&this.initSampler2D(a)):"mat2"===d||"mat3"===d||"mat4"===d?(a.glMatrix=!0,a.glValueLength=1,"mat2"===d?a.glFunc=b.uniformMatrix2fv:"mat3"===d?a.glFunc=b.uniformMatrix3fv:"mat4"===d&&(a.glFunc=b.uniformMatrix4fv)):(a.glFunc=b["uniform"+d],a.glValueLength="2f"===d||"2i"===d?2:"3f"===d||"3i"===d?3:"4f"===d||"4i"===d?4:1)}},b.PixiShader.prototype.initSampler2D=function(a){if(a.value&&a.value.baseTexture&&a.value.baseTexture.hasLoaded){var b=this.gl;if(b.activeTexture(b["TEXTURE"+this.textureCount]),b.bindTexture(b.TEXTURE_2D,a.value.baseTexture._glTextures[b.id]),a.textureData){var c=a.textureData,d=c.magFilter?c.magFilter:b.LINEAR,e=c.minFilter?c.minFilter:b.LINEAR,f=c.wrapS?c.wrapS:b.CLAMP_TO_EDGE,g=c.wrapT?c.wrapT:b.CLAMP_TO_EDGE,h=c.luminance?b.LUMINANCE:b.RGBA;if(c.repeat&&(f=b.REPEAT,g=b.REPEAT),b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL,!!c.flipY),c.width){var i=c.width?c.width:512,j=c.height?c.height:2,k=c.border?c.border:0;b.texImage2D(b.TEXTURE_2D,0,h,i,j,k,h,b.UNSIGNED_BYTE,null)}else b.texImage2D(b.TEXTURE_2D,0,h,b.RGBA,b.UNSIGNED_BYTE,a.value.baseTexture.source);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,d),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,e),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,f),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,g)}b.uniform1i(a.uniformLocation,this.textureCount),a._init=!0,this.textureCount++}},b.PixiShader.prototype.syncUniforms=function(){this.textureCount=1;var a,c=this.gl;for(var d in this.uniforms)a=this.uniforms[d],1===a.glValueLength?a.glMatrix===!0?a.glFunc.call(c,a.uniformLocation,a.transpose,a.value):a.glFunc.call(c,a.uniformLocation,a.value):2===a.glValueLength?a.glFunc.call(c,a.uniformLocation,a.value.x,a.value.y):3===a.glValueLength?a.glFunc.call(c,a.uniformLocation,a.value.x,a.value.y,a.value.z):4===a.glValueLength?a.glFunc.call(c,a.uniformLocation,a.value.x,a.value.y,a.value.z,a.value.w):"sampler2D"===a.type&&(a._init?(c.activeTexture(c["TEXTURE"+this.textureCount]),c.bindTexture(c.TEXTURE_2D,a.value.baseTexture._glTextures[c.id]||b.createWebGLTexture(a.value.baseTexture,c)),c.uniform1i(a.uniformLocation,this.textureCount),this.textureCount++):this.initSampler2D(a))},b.PixiShader.prototype.destroy=function(){this.gl.deleteProgram(this.program),this.uniforms=null,this.gl=null,this.attributes=null},b.PixiShader.defaultVertexSrc=["attribute vec2 aVertexPosition;","attribute vec2 aTextureCoord;","attribute vec2 aColor;","uniform vec2 projectionVector;","uniform vec2 offsetVector;","varying vec2 vTextureCoord;","varying vec4 vColor;","const vec2 center = vec2(-1.0, 1.0);","void main(void) {","   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);","   vTextureCoord = aTextureCoord;","   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;","   vColor = vec4(color * aColor.x, aColor.x);","}"],b.PixiFastShader=function(a){this._UID=b._UID++,this.gl=a,this.program=null,this.fragmentSrc=["precision lowp float;","varying vec2 vTextureCoord;","varying float vColor;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;","}"],this.vertexSrc=["attribute vec2 aVertexPosition;","attribute vec2 aPositionCoord;","attribute vec2 aScale;","attribute float aRotation;","attribute vec2 aTextureCoord;","attribute float aColor;","uniform vec2 projectionVector;","uniform vec2 offsetVector;","uniform mat3 uMatrix;","varying vec2 vTextureCoord;","varying float vColor;","const vec2 center = vec2(-1.0, 1.0);","void main(void) {","   vec2 v;","   vec2 sv = aVertexPosition * aScale;","   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);","   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);","   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;","   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);","   vTextureCoord = aTextureCoord;","   vColor = aColor;","}"],this.textureCount=0,this.init()},b.PixiFastShader.prototype.init=function(){var a=this.gl,c=b.compileProgram(a,this.vertexSrc,this.fragmentSrc);a.useProgram(c),this.uSampler=a.getUniformLocation(c,"uSampler"),this.projectionVector=a.getUniformLocation(c,"projectionVector"),this.offsetVector=a.getUniformLocation(c,"offsetVector"),this.dimensions=a.getUniformLocation(c,"dimensions"),this.uMatrix=a.getUniformLocation(c,"uMatrix"),this.aVertexPosition=a.getAttribLocation(c,"aVertexPosition"),this.aPositionCoord=a.getAttribLocation(c,"aPositionCoord"),this.aScale=a.getAttribLocation(c,"aScale"),this.aRotation=a.getAttribLocation(c,"aRotation"),this.aTextureCoord=a.getAttribLocation(c,"aTextureCoord"),this.colorAttribute=a.getAttribLocation(c,"aColor"),-1===this.colorAttribute&&(this.colorAttribute=2),this.attributes=[this.aVertexPosition,this.aPositionCoord,this.aScale,this.aRotation,this.aTextureCoord,this.colorAttribute],this.program=c},b.PixiFastShader.prototype.destroy=function(){this.gl.deleteProgram(this.program),this.uniforms=null,this.gl=null,this.attributes=null},b.StripShader=function(a){this._UID=b._UID++,this.gl=a,this.program=null,this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","uniform float alpha;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));","}"],this.vertexSrc=["attribute vec2 aVertexPosition;","attribute vec2 aTextureCoord;","uniform mat3 translationMatrix;","uniform vec2 projectionVector;","uniform vec2 offsetVector;","varying vec2 vTextureCoord;","void main(void) {","   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);","   v -= offsetVector.xyx;","   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);","   vTextureCoord = aTextureCoord;","}"],this.init()},b.StripShader.prototype.init=function(){var a=this.gl,c=b.compileProgram(a,this.vertexSrc,this.fragmentSrc);a.useProgram(c),this.uSampler=a.getUniformLocation(c,"uSampler"),this.projectionVector=a.getUniformLocation(c,"projectionVector"),this.offsetVector=a.getUniformLocation(c,"offsetVector"),this.colorAttribute=a.getAttribLocation(c,"aColor"),this.aVertexPosition=a.getAttribLocation(c,"aVertexPosition"),this.aTextureCoord=a.getAttribLocation(c,"aTextureCoord"),this.attributes=[this.aVertexPosition,this.aTextureCoord],this.translationMatrix=a.getUniformLocation(c,"translationMatrix"),this.alpha=a.getUniformLocation(c,"alpha"),this.program=c},b.PrimitiveShader=function(a){this._UID=b._UID++,this.gl=a,this.program=null,this.fragmentSrc=["precision mediump float;","varying vec4 vColor;","void main(void) {","   gl_FragColor = vColor;","}"],this.vertexSrc=["attribute vec2 aVertexPosition;","attribute vec4 aColor;","uniform mat3 translationMatrix;","uniform vec2 projectionVector;","uniform vec2 offsetVector;","uniform float alpha;","uniform vec3 tint;","varying vec4 vColor;","void main(void) {","   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);","   v -= offsetVector.xyx;","   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);","   vColor = aColor * vec4(tint * alpha, alpha);","}"],this.init()},b.PrimitiveShader.prototype.init=function(){var a=this.gl,c=b.compileProgram(a,this.vertexSrc,this.fragmentSrc);a.useProgram(c),this.projectionVector=a.getUniformLocation(c,"projectionVector"),this.offsetVector=a.getUniformLocation(c,"offsetVector"),this.tintColor=a.getUniformLocation(c,"tint"),this.aVertexPosition=a.getAttribLocation(c,"aVertexPosition"),this.colorAttribute=a.getAttribLocation(c,"aColor"),this.attributes=[this.aVertexPosition,this.colorAttribute],this.translationMatrix=a.getUniformLocation(c,"translationMatrix"),this.alpha=a.getUniformLocation(c,"alpha"),this.program=c},b.PrimitiveShader.prototype.destroy=function(){this.gl.deleteProgram(this.program),this.uniforms=null,this.gl=null,this.attribute=null},b.ComplexPrimitiveShader=function(a){this._UID=b._UID++,this.gl=a,this.program=null,this.fragmentSrc=["precision mediump float;","varying vec4 vColor;","void main(void) {","   gl_FragColor = vColor;","}"],this.vertexSrc=["attribute vec2 aVertexPosition;","uniform mat3 translationMatrix;","uniform vec2 projectionVector;","uniform vec2 offsetVector;","uniform vec3 tint;","uniform float alpha;","uniform vec3 color;","varying vec4 vColor;","void main(void) {","   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);","   v -= offsetVector.xyx;","   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);","   vColor = vec4(color * alpha * tint, alpha);","}"],this.init()},b.ComplexPrimitiveShader.prototype.init=function(){var a=this.gl,c=b.compileProgram(a,this.vertexSrc,this.fragmentSrc);a.useProgram(c),this.projectionVector=a.getUniformLocation(c,"projectionVector"),this.offsetVector=a.getUniformLocation(c,"offsetVector"),this.tintColor=a.getUniformLocation(c,"tint"),this.color=a.getUniformLocation(c,"color"),this.aVertexPosition=a.getAttribLocation(c,"aVertexPosition"),this.attributes=[this.aVertexPosition,this.colorAttribute],this.translationMatrix=a.getUniformLocation(c,"translationMatrix"),this.alpha=a.getUniformLocation(c,"alpha"),this.program=c},b.ComplexPrimitiveShader.prototype.destroy=function(){this.gl.deleteProgram(this.program),this.uniforms=null,this.gl=null,this.attribute=null},b.WebGLGraphics=function(){},b.WebGLGraphics.renderGraphics=function(a,c){var d,e=c.gl,f=c.projection,g=c.offset,h=c.shaderManager.primitiveShader;a.dirty&&b.WebGLGraphics.updateGraphics(a,e);for(var i=a._webGL[e.id],j=0;j<i.data.length;j++)1===i.data[j].mode?(d=i.data[j],c.stencilManager.pushStencil(a,d,c),e.drawElements(e.TRIANGLE_FAN,4,e.UNSIGNED_SHORT,2*(d.indices.length-4)),c.stencilManager.popStencil(a,d,c),this.last=d.mode):(d=i.data[j],c.shaderManager.setShader(h),h=c.shaderManager.primitiveShader,e.uniformMatrix3fv(h.translationMatrix,!1,a.worldTransform.toArray(!0)),e.uniform2f(h.projectionVector,f.x,-f.y),e.uniform2f(h.offsetVector,-g.x,-g.y),e.uniform3fv(h.tintColor,b.hex2rgb(a.tint)),e.uniform1f(h.alpha,a.worldAlpha),e.bindBuffer(e.ARRAY_BUFFER,d.buffer),e.vertexAttribPointer(h.aVertexPosition,2,e.FLOAT,!1,24,0),e.vertexAttribPointer(h.colorAttribute,4,e.FLOAT,!1,24,8),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,d.indexBuffer),e.drawElements(e.TRIANGLE_STRIP,d.indices.length,e.UNSIGNED_SHORT,0))},b.WebGLGraphics.updateGraphics=function(a,c){var d=a._webGL[c.id];d||(d=a._webGL[c.id]={lastIndex:0,data:[],gl:c}),a.dirty=!1;var e;if(a.clearDirty){for(a.clearDirty=!1,e=0;e<d.data.length;e++){var f=d.data[e];f.reset(),b.WebGLGraphics.graphicsDataPool.push(f)}d.data=[],d.lastIndex=0}var g;for(e=d.lastIndex;e<a.graphicsData.length;e++){var h=a.graphicsData[e];h.type===b.Graphics.POLY?(h.fill&&h.points.length>6&&(h.points.length>10?(g=b.WebGLGraphics.switchMode(d,1),b.WebGLGraphics.buildComplexPoly(h,g)):(g=b.WebGLGraphics.switchMode(d,0),b.WebGLGraphics.buildPoly(h,g))),h.lineWidth>0&&(g=b.WebGLGraphics.switchMode(d,0),b.WebGLGraphics.buildLine(h,g))):(g=b.WebGLGraphics.switchMode(d,0),h.type===b.Graphics.RECT?b.WebGLGraphics.buildRectangle(h,g):h.type===b.Graphics.CIRC||h.type===b.Graphics.ELIP?b.WebGLGraphics.buildCircle(h,g):h.type===b.Graphics.RREC&&b.WebGLGraphics.buildRoundedRectangle(h,g)),d.lastIndex++}for(e=0;e<d.data.length;e++)g=d.data[e],g.dirty&&g.upload()},b.WebGLGraphics.switchMode=function(a,c){var d;return a.data.length?(d=a.data[a.data.length-1],(d.mode!==c||1===c)&&(d=b.WebGLGraphics.graphicsDataPool.pop()||new b.WebGLGraphicsData(a.gl),d.mode=c,a.data.push(d))):(d=b.WebGLGraphics.graphicsDataPool.pop()||new b.WebGLGraphicsData(a.gl),d.mode=c,a.data.push(d)),d.dirty=!0,d},b.WebGLGraphics.buildRectangle=function(a,c){var d=a.points,e=d[0],f=d[1],g=d[2],h=d[3];if(a.fill){var i=b.hex2rgb(a.fillColor),j=a.fillAlpha,k=i[0]*j,l=i[1]*j,m=i[2]*j,n=c.points,o=c.indices,p=n.length/6;n.push(e,f),n.push(k,l,m,j),n.push(e+g,f),n.push(k,l,m,j),n.push(e,f+h),n.push(k,l,m,j),n.push(e+g,f+h),n.push(k,l,m,j),o.push(p,p,p+1,p+2,p+3,p+3)}if(a.lineWidth){var q=a.points;a.points=[e,f,e+g,f,e+g,f+h,e,f+h,e,f],b.WebGLGraphics.buildLine(a,c),a.points=q}},b.WebGLGraphics.buildRoundedRectangle=function(a,c){var d=a.points,e=d[0],f=d[1],g=d[2],h=d[3],i=d[4],j=[];if(j.push(e,f+i),j=j.concat(b.WebGLGraphics.quadraticBezierCurve(e,f+h-i,e,f+h,e+i,f+h)),j=j.concat(b.WebGLGraphics.quadraticBezierCurve(e+g-i,f+h,e+g,f+h,e+g,f+h-i)),j=j.concat(b.WebGLGraphics.quadraticBezierCurve(e+g,f+i,e+g,f,e+g-i,f)),j=j.concat(b.WebGLGraphics.quadraticBezierCurve(e+i,f,e,f,e,f+i)),a.fill){var k=b.hex2rgb(a.fillColor),l=a.fillAlpha,m=k[0]*l,n=k[1]*l,o=k[2]*l,p=c.points,q=c.indices,r=p.length/6,s=b.PolyK.Triangulate(j),t=0;for(t=0;t<s.length;t+=3)q.push(s[t]+r),q.push(s[t]+r),q.push(s[t+1]+r),q.push(s[t+2]+r),q.push(s[t+2]+r);for(t=0;t<j.length;t++)p.push(j[t],j[++t],m,n,o,l)}if(a.lineWidth){var u=a.points;a.points=j,b.WebGLGraphics.buildLine(a,c),a.points=u}},b.WebGLGraphics.quadraticBezierCurve=function(a,b,c,d,e,f){function g(a,b,c){var d=b-a;return a+d*c}for(var h,i,j,k,l,m,n=20,o=[],p=0,q=0;n>=q;q++)p=q/n,h=g(a,c,p),i=g(b,d,p),j=g(c,e,p),k=g(d,f,p),l=g(h,j,p),m=g(i,k,p),o.push(l,m);return o},b.WebGLGraphics.buildCircle=function(a,c){var d=a.points,e=d[0],f=d[1],g=d[2],h=d[3],i=40,j=2*Math.PI/i,k=0;if(a.fill){var l=b.hex2rgb(a.fillColor),m=a.fillAlpha,n=l[0]*m,o=l[1]*m,p=l[2]*m,q=c.points,r=c.indices,s=q.length/6;for(r.push(s),k=0;i+1>k;k++)q.push(e,f,n,o,p,m),q.push(e+Math.sin(j*k)*g,f+Math.cos(j*k)*h,n,o,p,m),r.push(s++,s++);r.push(s-1)}if(a.lineWidth){var t=a.points;for(a.points=[],k=0;i+1>k;k++)a.points.push(e+Math.sin(j*k)*g,f+Math.cos(j*k)*h);b.WebGLGraphics.buildLine(a,c),a.points=t}},b.WebGLGraphics.buildLine=function(a,c){var d=0,e=a.points;if(0!==e.length){if(a.lineWidth%2)for(d=0;d<e.length;d++)e[d]+=.5;var f=new b.Point(e[0],e[1]),g=new b.Point(e[e.length-2],e[e.length-1]);if(f.x===g.x&&f.y===g.y){e=e.slice(),e.pop(),e.pop(),g=new b.Point(e[e.length-2],e[e.length-1]);var h=g.x+.5*(f.x-g.x),i=g.y+.5*(f.y-g.y);e.unshift(h,i),e.push(h,i)}var j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G=c.points,H=c.indices,I=e.length/2,J=e.length,K=G.length/6,L=a.lineWidth/2,M=b.hex2rgb(a.lineColor),N=a.lineAlpha,O=M[0]*N,P=M[1]*N,Q=M[2]*N;for(l=e[0],m=e[1],n=e[2],o=e[3],r=-(m-o),s=l-n,F=Math.sqrt(r*r+s*s),r/=F,s/=F,r*=L,s*=L,G.push(l-r,m-s,O,P,Q,N),G.push(l+r,m+s,O,P,Q,N),d=1;I-1>d;d++)l=e[2*(d-1)],m=e[2*(d-1)+1],n=e[2*d],o=e[2*d+1],p=e[2*(d+1)],q=e[2*(d+1)+1],r=-(m-o),s=l-n,F=Math.sqrt(r*r+s*s),r/=F,s/=F,r*=L,s*=L,t=-(o-q),u=n-p,F=Math.sqrt(t*t+u*u),t/=F,u/=F,t*=L,u*=L,x=-s+m-(-s+o),y=-r+n-(-r+l),z=(-r+l)*(-s+o)-(-r+n)*(-s+m),A=-u+q-(-u+o),B=-t+n-(-t+p),C=(-t+p)*(-u+o)-(-t+n)*(-u+q),D=x*B-A*y,Math.abs(D)<.1?(D+=10.1,G.push(n-r,o-s,O,P,Q,N),G.push(n+r,o+s,O,P,Q,N)):(j=(y*C-B*z)/D,k=(A*z-x*C)/D,E=(j-n)*(j-n)+(k-o)+(k-o),E>19600?(v=r-t,w=s-u,F=Math.sqrt(v*v+w*w),v/=F,w/=F,v*=L,w*=L,G.push(n-v,o-w),G.push(O,P,Q,N),G.push(n+v,o+w),G.push(O,P,Q,N),G.push(n-v,o-w),G.push(O,P,Q,N),J++):(G.push(j,k),G.push(O,P,Q,N),G.push(n-(j-n),o-(k-o)),G.push(O,P,Q,N)));for(l=e[2*(I-2)],m=e[2*(I-2)+1],n=e[2*(I-1)],o=e[2*(I-1)+1],r=-(m-o),s=l-n,F=Math.sqrt(r*r+s*s),r/=F,s/=F,r*=L,s*=L,G.push(n-r,o-s),G.push(O,P,Q,N),G.push(n+r,o+s),G.push(O,P,Q,N),H.push(K),d=0;J>d;d++)H.push(K++);H.push(K-1)}},b.WebGLGraphics.buildComplexPoly=function(a,c){var d=a.points.slice();if(!(d.length<6)){var e=c.indices;c.points=d,c.alpha=a.fillAlpha,c.color=b.hex2rgb(a.fillColor);for(var f,g,h=1/0,i=-1/0,j=1/0,k=-1/0,l=0;l<d.length;l+=2)f=d[l],g=d[l+1],h=h>f?f:h,i=f>i?f:i,j=j>g?g:j,k=g>k?g:k;d.push(h,j,i,j,i,k,h,k);var m=d.length/2;for(l=0;m>l;l++)e.push(l)}},b.WebGLGraphics.buildPoly=function(a,c){var d=a.points;if(!(d.length<6)){var e=c.points,f=c.indices,g=d.length/2,h=b.hex2rgb(a.fillColor),i=a.fillAlpha,j=h[0]*i,k=h[1]*i,l=h[2]*i,m=b.PolyK.Triangulate(d),n=e.length/6,o=0;for(o=0;o<m.length;o+=3)f.push(m[o]+n),f.push(m[o]+n),f.push(m[o+1]+n),f.push(m[o+2]+n),f.push(m[o+2]+n);for(o=0;g>o;o++)e.push(d[2*o],d[2*o+1],j,k,l,i)}},b.WebGLGraphics.graphicsDataPool=[],b.WebGLGraphicsData=function(a){this.gl=a,this.color=[0,0,0],this.points=[],this.indices=[],this.lastIndex=0,this.buffer=a.createBuffer(),this.indexBuffer=a.createBuffer(),this.mode=1,this.alpha=1,this.dirty=!0},b.WebGLGraphicsData.prototype.reset=function(){this.points=[],this.indices=[],this.lastIndex=0},b.WebGLGraphicsData.prototype.upload=function(){var a=this.gl;this.glPoints=new Float32Array(this.points),a.bindBuffer(a.ARRAY_BUFFER,this.buffer),a.bufferData(a.ARRAY_BUFFER,this.glPoints,a.STATIC_DRAW),this.glIndicies=new Uint16Array(this.indices),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,this.glIndicies,a.STATIC_DRAW),this.dirty=!1},b.glContexts=[],b.WebGLRenderer=function(a,c,d,e,f,g){b.defaultRenderer||(b.sayHello("webGL"),b.defaultRenderer=this),this.type=b.WEBGL_RENDERER,this.transparent=!!e,this.preserveDrawingBuffer=g,this.width=a||800,this.height=c||600,this.view=d||document.createElement("canvas"),this.view.width=this.width,this.view.height=this.height,this.contextLost=this.handleContextLost.bind(this),this.contextRestoredLost=this.handleContextRestored.bind(this),this.view.addEventListener("webglcontextlost",this.contextLost,!1),this.view.addEventListener("webglcontextrestored",this.contextRestoredLost,!1),this.options={alpha:this.transparent,antialias:!!f,premultipliedAlpha:!!e,stencil:!0,preserveDrawingBuffer:g};var h=null;if(["experimental-webgl","webgl"].forEach(function(a){try{h=h||this.view.getContext(a,this.options)}catch(b){}},this),!h)throw new Error("This browser does not support webGL. Try using the canvas renderer"+this);this.gl=h,this.glContextId=h.id=b.WebGLRenderer.glContextId++,b.glContexts[this.glContextId]=h,b.blendModesWebGL||(b.blendModesWebGL=[],b.blendModesWebGL[b.blendModes.NORMAL]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.ADD]=[h.SRC_ALPHA,h.DST_ALPHA],b.blendModesWebGL[b.blendModes.MULTIPLY]=[h.DST_COLOR,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.SCREEN]=[h.SRC_ALPHA,h.ONE],b.blendModesWebGL[b.blendModes.OVERLAY]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.DARKEN]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.LIGHTEN]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.COLOR_DODGE]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.COLOR_BURN]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.HARD_LIGHT]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.SOFT_LIGHT]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.DIFFERENCE]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.EXCLUSION]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.HUE]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.SATURATION]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.COLOR]=[h.ONE,h.ONE_MINUS_SRC_ALPHA],b.blendModesWebGL[b.blendModes.LUMINOSITY]=[h.ONE,h.ONE_MINUS_SRC_ALPHA]),this.projection=new b.Point,this.projection.x=this.width/2,this.projection.y=-this.height/2,this.offset=new b.Point(0,0),this.resize(this.width,this.height),this.contextLost=!1,this.shaderManager=new b.WebGLShaderManager(h),this.spriteBatch=new b.WebGLSpriteBatch(h),this.maskManager=new b.WebGLMaskManager(h),this.filterManager=new b.WebGLFilterManager(h,this.transparent),this.stencilManager=new b.WebGLStencilManager(h),this.blendModeManager=new b.WebGLBlendModeManager(h),this.renderSession={},this.renderSession.gl=this.gl,this.renderSession.drawCount=0,this.renderSession.shaderManager=this.shaderManager,this.renderSession.maskManager=this.maskManager,this.renderSession.filterManager=this.filterManager,this.renderSession.blendModeManager=this.blendModeManager,this.renderSession.spriteBatch=this.spriteBatch,this.renderSession.stencilManager=this.stencilManager,this.renderSession.renderer=this,h.useProgram(this.shaderManager.defaultShader.program),h.disable(h.DEPTH_TEST),h.disable(h.CULL_FACE),h.enable(h.BLEND),h.colorMask(!0,!0,!0,this.transparent)},b.WebGLRenderer.prototype.constructor=b.WebGLRenderer,b.WebGLRenderer.prototype.render=function(a){if(!this.contextLost){this.__stage!==a&&(a.interactive&&a.interactionManager.removeEvents(),this.__stage=a),b.WebGLRenderer.updateTextures(),a.updateTransform(),a._interactive&&(a._interactiveEventsAdded||(a._interactiveEventsAdded=!0,a.interactionManager.setTarget(this)));var c=this.gl;c.viewport(0,0,this.width,this.height),c.bindFramebuffer(c.FRAMEBUFFER,null),this.transparent?c.clearColor(0,0,0,0):c.clearColor(a.backgroundColorSplit[0],a.backgroundColorSplit[1],a.backgroundColorSplit[2],1),c.clear(c.COLOR_BUFFER_BIT),this.renderDisplayObject(a,this.projection),a.interactive?a._interactiveEventsAdded||(a._interactiveEventsAdded=!0,a.interactionManager.setTarget(this)):a._interactiveEventsAdded&&(a._interactiveEventsAdded=!1,a.interactionManager.setTarget(this))}},b.WebGLRenderer.prototype.renderDisplayObject=function(a,c,d){this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL),this.renderSession.drawCount=0,this.renderSession.currentBlendMode=9999,this.renderSession.projection=c,this.renderSession.offset=this.offset,this.spriteBatch.begin(this.renderSession),this.filterManager.begin(this.renderSession,d),a._renderWebGL(this.renderSession),this.spriteBatch.end()},b.WebGLRenderer.updateTextures=function(){var a=0;for(a=0;a<b.Texture.frameUpdates.length;a++)b.WebGLRenderer.updateTextureFrame(b.Texture.frameUpdates[a]);for(a=0;a<b.texturesToDestroy.length;a++)b.WebGLRenderer.destroyTexture(b.texturesToDestroy[a]);b.texturesToUpdate.length=0,b.texturesToDestroy.length=0,b.Texture.frameUpdates.length=0},b.WebGLRenderer.destroyTexture=function(a){for(var c=a._glTextures.length-1;c>=0;c--){var d=a._glTextures[c],e=b.glContexts[c];
e&&d&&e.deleteTexture(d)}a._glTextures.length=0},b.WebGLRenderer.updateTextureFrame=function(a){a._updateWebGLuvs()},b.WebGLRenderer.prototype.resize=function(a,b){this.width=a,this.height=b,this.view.width=a,this.view.height=b,this.gl.viewport(0,0,this.width,this.height),this.projection.x=this.width/2,this.projection.y=-this.height/2},b.createWebGLTexture=function(a,c){return a.hasLoaded&&(a._glTextures[c.id]=c.createTexture(),c.bindTexture(c.TEXTURE_2D,a._glTextures[c.id]),c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultipliedAlpha),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,a.source),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,a.scaleMode===b.scaleModes.LINEAR?c.LINEAR:c.NEAREST),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,a.scaleMode===b.scaleModes.LINEAR?c.LINEAR:c.NEAREST),a._powerOf2?(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.REPEAT),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.REPEAT)):(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE)),c.bindTexture(c.TEXTURE_2D,null),a._dirty[c.id]=!1),a._glTextures[c.id]},b.updateWebGLTexture=function(a,c){a._glTextures[c.id]&&(c.bindTexture(c.TEXTURE_2D,a._glTextures[c.id]),c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultipliedAlpha),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,a.source),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,a.scaleMode===b.scaleModes.LINEAR?c.LINEAR:c.NEAREST),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,a.scaleMode===b.scaleModes.LINEAR?c.LINEAR:c.NEAREST),a._powerOf2?(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.REPEAT),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.REPEAT)):(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE)),a._dirty[c.id]=!1)},b.WebGLRenderer.prototype.handleContextLost=function(a){a.preventDefault(),this.contextLost=!0},b.WebGLRenderer.prototype.handleContextRestored=function(){try{this.gl=this.view.getContext("experimental-webgl",this.options)}catch(a){try{this.gl=this.view.getContext("webgl",this.options)}catch(c){throw new Error(" This browser does not support webGL. Try using the canvas renderer"+this)}}var d=this.gl;d.id=b.WebGLRenderer.glContextId++,this.shaderManager.setContext(d),this.spriteBatch.setContext(d),this.primitiveBatch.setContext(d),this.maskManager.setContext(d),this.filterManager.setContext(d),this.renderSession.gl=this.gl,d.disable(d.DEPTH_TEST),d.disable(d.CULL_FACE),d.enable(d.BLEND),d.colorMask(!0,!0,!0,this.transparent),this.gl.viewport(0,0,this.width,this.height);for(var e in b.TextureCache){var f=b.TextureCache[e].baseTexture;f._glTextures=[]}this.contextLost=!1},b.WebGLRenderer.prototype.destroy=function(){this.view.removeEventListener("webglcontextlost",this.contextLost),this.view.removeEventListener("webglcontextrestored",this.contextRestoredLost),b.glContexts[this.glContextId]=null,this.projection=null,this.offset=null,this.shaderManager.destroy(),this.spriteBatch.destroy(),this.primitiveBatch.destroy(),this.maskManager.destroy(),this.filterManager.destroy(),this.shaderManager=null,this.spriteBatch=null,this.maskManager=null,this.filterManager=null,this.gl=null,this.renderSession=null},b.WebGLRenderer.glContextId=0,b.WebGLBlendModeManager=function(a){this.gl=a,this.currentBlendMode=99999},b.WebGLBlendModeManager.prototype.setBlendMode=function(a){if(this.currentBlendMode===a)return!1;this.currentBlendMode=a;var c=b.blendModesWebGL[this.currentBlendMode];return this.gl.blendFunc(c[0],c[1]),!0},b.WebGLBlendModeManager.prototype.destroy=function(){this.gl=null},b.WebGLMaskManager=function(a){this.maskStack=[],this.maskPosition=0,this.setContext(a),this.reverse=!1,this.count=0},b.WebGLMaskManager.prototype.setContext=function(a){this.gl=a},b.WebGLMaskManager.prototype.pushMask=function(a,c){var d=c.gl;a.dirty&&b.WebGLGraphics.updateGraphics(a,d),a._webGL[d.id].data.length&&c.stencilManager.pushStencil(a,a._webGL[d.id].data[0],c)},b.WebGLMaskManager.prototype.popMask=function(a,b){var c=this.gl;b.stencilManager.popStencil(a,a._webGL[c.id].data[0],b)},b.WebGLMaskManager.prototype.destroy=function(){this.maskStack=null,this.gl=null},b.WebGLStencilManager=function(a){this.stencilStack=[],this.setContext(a),this.reverse=!0,this.count=0},b.WebGLStencilManager.prototype.setContext=function(a){this.gl=a},b.WebGLStencilManager.prototype.pushStencil=function(a,b,c){var d=this.gl;this.bindGraphics(a,b,c),0===this.stencilStack.length&&(d.enable(d.STENCIL_TEST),d.clear(d.STENCIL_BUFFER_BIT),this.reverse=!0,this.count=0),this.stencilStack.push(b);var e=this.count;d.colorMask(!1,!1,!1,!1),d.stencilFunc(d.ALWAYS,0,255),d.stencilOp(d.KEEP,d.KEEP,d.INVERT),1===b.mode?(d.drawElements(d.TRIANGLE_FAN,b.indices.length-4,d.UNSIGNED_SHORT,0),this.reverse?(d.stencilFunc(d.EQUAL,255-e,255),d.stencilOp(d.KEEP,d.KEEP,d.DECR)):(d.stencilFunc(d.EQUAL,e,255),d.stencilOp(d.KEEP,d.KEEP,d.INCR)),d.drawElements(d.TRIANGLE_FAN,4,d.UNSIGNED_SHORT,2*(b.indices.length-4)),this.reverse?d.stencilFunc(d.EQUAL,255-(e+1),255):d.stencilFunc(d.EQUAL,e+1,255),this.reverse=!this.reverse):(this.reverse?(d.stencilFunc(d.EQUAL,e,255),d.stencilOp(d.KEEP,d.KEEP,d.INCR)):(d.stencilFunc(d.EQUAL,255-e,255),d.stencilOp(d.KEEP,d.KEEP,d.DECR)),d.drawElements(d.TRIANGLE_STRIP,b.indices.length,d.UNSIGNED_SHORT,0),this.reverse?d.stencilFunc(d.EQUAL,e+1,255):d.stencilFunc(d.EQUAL,255-(e+1),255)),d.colorMask(!0,!0,!0,!0),d.stencilOp(d.KEEP,d.KEEP,d.KEEP),this.count++},b.WebGLStencilManager.prototype.bindGraphics=function(a,c,d){this._currentGraphics=a;var e,f=this.gl,g=d.projection,h=d.offset;1===c.mode?(e=d.shaderManager.complexPrimativeShader,d.shaderManager.setShader(e),f.uniformMatrix3fv(e.translationMatrix,!1,a.worldTransform.toArray(!0)),f.uniform2f(e.projectionVector,g.x,-g.y),f.uniform2f(e.offsetVector,-h.x,-h.y),f.uniform3fv(e.tintColor,b.hex2rgb(a.tint)),f.uniform3fv(e.color,c.color),f.uniform1f(e.alpha,a.worldAlpha*c.alpha),f.bindBuffer(f.ARRAY_BUFFER,c.buffer),f.vertexAttribPointer(e.aVertexPosition,2,f.FLOAT,!1,8,0),f.bindBuffer(f.ELEMENT_ARRAY_BUFFER,c.indexBuffer)):(e=d.shaderManager.primitiveShader,d.shaderManager.setShader(e),f.uniformMatrix3fv(e.translationMatrix,!1,a.worldTransform.toArray(!0)),f.uniform2f(e.projectionVector,g.x,-g.y),f.uniform2f(e.offsetVector,-h.x,-h.y),f.uniform3fv(e.tintColor,b.hex2rgb(a.tint)),f.uniform1f(e.alpha,a.worldAlpha),f.bindBuffer(f.ARRAY_BUFFER,c.buffer),f.vertexAttribPointer(e.aVertexPosition,2,f.FLOAT,!1,24,0),f.vertexAttribPointer(e.colorAttribute,4,f.FLOAT,!1,24,8),f.bindBuffer(f.ELEMENT_ARRAY_BUFFER,c.indexBuffer))},b.WebGLStencilManager.prototype.popStencil=function(a,b,c){var d=this.gl;if(this.stencilStack.pop(),this.count--,0===this.stencilStack.length)d.disable(d.STENCIL_TEST);else{var e=this.count;this.bindGraphics(a,b,c),d.colorMask(!1,!1,!1,!1),1===b.mode?(this.reverse=!this.reverse,this.reverse?(d.stencilFunc(d.EQUAL,255-(e+1),255),d.stencilOp(d.KEEP,d.KEEP,d.INCR)):(d.stencilFunc(d.EQUAL,e+1,255),d.stencilOp(d.KEEP,d.KEEP,d.DECR)),d.drawElements(d.TRIANGLE_FAN,4,d.UNSIGNED_SHORT,2*(b.indices.length-4)),d.stencilFunc(d.ALWAYS,0,255),d.stencilOp(d.KEEP,d.KEEP,d.INVERT),d.drawElements(d.TRIANGLE_FAN,b.indices.length-4,d.UNSIGNED_SHORT,0),this.reverse?d.stencilFunc(d.EQUAL,e,255):d.stencilFunc(d.EQUAL,255-e,255)):(this.reverse?(d.stencilFunc(d.EQUAL,e+1,255),d.stencilOp(d.KEEP,d.KEEP,d.DECR)):(d.stencilFunc(d.EQUAL,255-(e+1),255),d.stencilOp(d.KEEP,d.KEEP,d.INCR)),d.drawElements(d.TRIANGLE_STRIP,b.indices.length,d.UNSIGNED_SHORT,0),this.reverse?d.stencilFunc(d.EQUAL,e,255):d.stencilFunc(d.EQUAL,255-e,255)),d.colorMask(!0,!0,!0,!0),d.stencilOp(d.KEEP,d.KEEP,d.KEEP)}},b.WebGLStencilManager.prototype.destroy=function(){this.maskStack=null,this.gl=null},b.WebGLShaderManager=function(a){this.maxAttibs=10,this.attribState=[],this.tempAttribState=[],this.shaderMap=[];for(var b=0;b<this.maxAttibs;b++)this.attribState[b]=!1;this.setContext(a)},b.WebGLShaderManager.prototype.setContext=function(a){this.gl=a,this.primitiveShader=new b.PrimitiveShader(a),this.complexPrimativeShader=new b.ComplexPrimitiveShader(a),this.defaultShader=new b.PixiShader(a),this.fastShader=new b.PixiFastShader(a),this.stripShader=new b.StripShader(a),this.setShader(this.defaultShader)},b.WebGLShaderManager.prototype.setAttribs=function(a){var b;for(b=0;b<this.tempAttribState.length;b++)this.tempAttribState[b]=!1;for(b=0;b<a.length;b++){var c=a[b];this.tempAttribState[c]=!0}var d=this.gl;for(b=0;b<this.attribState.length;b++)this.attribState[b]!==this.tempAttribState[b]&&(this.attribState[b]=this.tempAttribState[b],this.tempAttribState[b]?d.enableVertexAttribArray(b):d.disableVertexAttribArray(b))},b.WebGLShaderManager.prototype.setShader=function(a){return this._currentId===a._UID?!1:(this._currentId=a._UID,this.currentShader=a,this.gl.useProgram(a.program),this.setAttribs(a.attributes),!0)},b.WebGLShaderManager.prototype.destroy=function(){this.attribState=null,this.tempAttribState=null,this.primitiveShader.destroy(),this.defaultShader.destroy(),this.fastShader.destroy(),this.stripShader.destroy(),this.gl=null},b.WebGLSpriteBatch=function(a){this.vertSize=6,this.size=2e3;var b=4*this.size*this.vertSize,c=6*this.size;this.vertices=new Float32Array(b),this.indices=new Uint16Array(c),this.lastIndexCount=0;for(var d=0,e=0;c>d;d+=6,e+=4)this.indices[d+0]=e+0,this.indices[d+1]=e+1,this.indices[d+2]=e+2,this.indices[d+3]=e+0,this.indices[d+4]=e+2,this.indices[d+5]=e+3;this.drawing=!1,this.currentBatchSize=0,this.currentBaseTexture=null,this.setContext(a),this.dirty=!0,this.textures=[],this.blendModes=[]},b.WebGLSpriteBatch.prototype.setContext=function(a){this.gl=a,this.vertexBuffer=a.createBuffer(),this.indexBuffer=a.createBuffer(),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,this.indices,a.STATIC_DRAW),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bufferData(a.ARRAY_BUFFER,this.vertices,a.DYNAMIC_DRAW),this.currentBlendMode=99999},b.WebGLSpriteBatch.prototype.begin=function(a){this.renderSession=a,this.shader=this.renderSession.shaderManager.defaultShader,this.start()},b.WebGLSpriteBatch.prototype.end=function(){this.flush()},b.WebGLSpriteBatch.prototype.render=function(a){var b=a.texture;this.currentBatchSize>=this.size&&(this.flush(),this.currentBaseTexture=b.baseTexture);var c=b._uvs;if(c){var d,e,f,g,h=a.worldAlpha,i=a.tint,j=this.vertices,k=a.anchor.x,l=a.anchor.y;if(b.trim){var m=b.trim;e=m.x-k*m.width,d=e+b.crop.width,g=m.y-l*m.height,f=g+b.crop.height}else d=b.frame.width*(1-k),e=b.frame.width*-k,f=b.frame.height*(1-l),g=b.frame.height*-l;var n=4*this.currentBatchSize*this.vertSize,o=a.worldTransform,p=o.a,q=o.c,r=o.b,s=o.d,t=o.tx,u=o.ty;j[n++]=p*e+r*g+t,j[n++]=s*g+q*e+u,j[n++]=c.x0,j[n++]=c.y0,j[n++]=h,j[n++]=i,j[n++]=p*d+r*g+t,j[n++]=s*g+q*d+u,j[n++]=c.x1,j[n++]=c.y1,j[n++]=h,j[n++]=i,j[n++]=p*d+r*f+t,j[n++]=s*f+q*d+u,j[n++]=c.x2,j[n++]=c.y2,j[n++]=h,j[n++]=i,j[n++]=p*e+r*f+t,j[n++]=s*f+q*e+u,j[n++]=c.x3,j[n++]=c.y3,j[n++]=h,j[n++]=i,this.textures[this.currentBatchSize]=a.texture.baseTexture,this.blendModes[this.currentBatchSize]=a.blendMode,this.currentBatchSize++}},b.WebGLSpriteBatch.prototype.renderTilingSprite=function(a){var c=a.tilingTexture;this.currentBatchSize>=this.size&&(this.flush(),this.currentBaseTexture=c.baseTexture),a._uvs||(a._uvs=new b.TextureUvs);var d=a._uvs;a.tilePosition.x%=c.baseTexture.width*a.tileScaleOffset.x,a.tilePosition.y%=c.baseTexture.height*a.tileScaleOffset.y;var e=a.tilePosition.x/(c.baseTexture.width*a.tileScaleOffset.x),f=a.tilePosition.y/(c.baseTexture.height*a.tileScaleOffset.y),g=a.width/c.baseTexture.width/(a.tileScale.x*a.tileScaleOffset.x),h=a.height/c.baseTexture.height/(a.tileScale.y*a.tileScaleOffset.y);d.x0=0-e,d.y0=0-f,d.x1=1*g-e,d.y1=0-f,d.x2=1*g-e,d.y2=1*h-f,d.x3=0-e,d.y3=1*h-f;var i=a.worldAlpha,j=a.tint,k=this.vertices,l=a.width,m=a.height,n=a.anchor.x,o=a.anchor.y,p=l*(1-n),q=l*-n,r=m*(1-o),s=m*-o,t=4*this.currentBatchSize*this.vertSize,u=a.worldTransform,v=u.a,w=u.c,x=u.b,y=u.d,z=u.tx,A=u.ty;k[t++]=v*q+x*s+z,k[t++]=y*s+w*q+A,k[t++]=d.x0,k[t++]=d.y0,k[t++]=i,k[t++]=j,k[t++]=v*p+x*s+z,k[t++]=y*s+w*p+A,k[t++]=d.x1,k[t++]=d.y1,k[t++]=i,k[t++]=j,k[t++]=v*p+x*r+z,k[t++]=y*r+w*p+A,k[t++]=d.x2,k[t++]=d.y2,k[t++]=i,k[t++]=j,k[t++]=v*q+x*r+z,k[t++]=y*r+w*q+A,k[t++]=d.x3,k[t++]=d.y3,k[t++]=i,k[t++]=j,this.textures[this.currentBatchSize]=c.baseTexture,this.blendModes[this.currentBatchSize]=a.blendMode,this.currentBatchSize++},b.WebGLSpriteBatch.prototype.flush=function(){if(0!==this.currentBatchSize){var a=this.gl;if(this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader),this.dirty){this.dirty=!1,a.activeTexture(a.TEXTURE0),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer);var b=this.renderSession.projection;a.uniform2f(this.shader.projectionVector,b.x,b.y);var c=4*this.vertSize;a.vertexAttribPointer(this.shader.aVertexPosition,2,a.FLOAT,!1,c,0),a.vertexAttribPointer(this.shader.aTextureCoord,2,a.FLOAT,!1,c,8),a.vertexAttribPointer(this.shader.colorAttribute,2,a.FLOAT,!1,c,16)}if(this.currentBatchSize>.5*this.size)a.bufferSubData(a.ARRAY_BUFFER,0,this.vertices);else{var d=this.vertices.subarray(0,4*this.currentBatchSize*this.vertSize);a.bufferSubData(a.ARRAY_BUFFER,0,d)}for(var e,f,g=0,h=0,i=null,j=this.renderSession.blendModeManager.currentBlendMode,k=0,l=this.currentBatchSize;l>k;k++)e=this.textures[k],f=this.blendModes[k],(i!==e||j!==f)&&(this.renderBatch(i,g,h),h=k,g=0,i=e,j=f,this.renderSession.blendModeManager.setBlendMode(j)),g++;this.renderBatch(i,g,h),this.currentBatchSize=0}},b.WebGLSpriteBatch.prototype.renderBatch=function(a,c,d){if(0!==c){var e=this.gl;e.bindTexture(e.TEXTURE_2D,a._glTextures[e.id]||b.createWebGLTexture(a,e)),a._dirty[e.id]&&b.updateWebGLTexture(this.currentBaseTexture,e),e.drawElements(e.TRIANGLES,6*c,e.UNSIGNED_SHORT,6*d*2),this.renderSession.drawCount++}},b.WebGLSpriteBatch.prototype.stop=function(){this.flush()},b.WebGLSpriteBatch.prototype.start=function(){this.dirty=!0},b.WebGLSpriteBatch.prototype.destroy=function(){this.vertices=null,this.indices=null,this.gl.deleteBuffer(this.vertexBuffer),this.gl.deleteBuffer(this.indexBuffer),this.currentBaseTexture=null,this.gl=null},b.WebGLFastSpriteBatch=function(a){this.vertSize=10,this.maxSize=6e3,this.size=this.maxSize;var b=4*this.size*this.vertSize,c=6*this.maxSize;this.vertices=new Float32Array(b),this.indices=new Uint16Array(c),this.vertexBuffer=null,this.indexBuffer=null,this.lastIndexCount=0;for(var d=0,e=0;c>d;d+=6,e+=4)this.indices[d+0]=e+0,this.indices[d+1]=e+1,this.indices[d+2]=e+2,this.indices[d+3]=e+0,this.indices[d+4]=e+2,this.indices[d+5]=e+3;this.drawing=!1,this.currentBatchSize=0,this.currentBaseTexture=null,this.currentBlendMode=0,this.renderSession=null,this.shader=null,this.matrix=null,this.setContext(a)},b.WebGLFastSpriteBatch.prototype.setContext=function(a){this.gl=a,this.vertexBuffer=a.createBuffer(),this.indexBuffer=a.createBuffer(),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,this.indices,a.STATIC_DRAW),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bufferData(a.ARRAY_BUFFER,this.vertices,a.DYNAMIC_DRAW)},b.WebGLFastSpriteBatch.prototype.begin=function(a,b){this.renderSession=b,this.shader=this.renderSession.shaderManager.fastShader,this.matrix=a.worldTransform.toArray(!0),this.start()},b.WebGLFastSpriteBatch.prototype.end=function(){this.flush()},b.WebGLFastSpriteBatch.prototype.render=function(a){var b=a.children,c=b[0];if(c.texture._uvs){this.currentBaseTexture=c.texture.baseTexture,c.blendMode!==this.renderSession.blendModeManager.currentBlendMode&&(this.flush(),this.renderSession.blendModeManager.setBlendMode(c.blendMode));for(var d=0,e=b.length;e>d;d++)this.renderSprite(b[d]);this.flush()}},b.WebGLFastSpriteBatch.prototype.renderSprite=function(a){if(a.visible&&(a.texture.baseTexture===this.currentBaseTexture||(this.flush(),this.currentBaseTexture=a.texture.baseTexture,a.texture._uvs))){var b,c,d,e,f,g,h,i,j=this.vertices;if(b=a.texture._uvs,c=a.texture.frame.width,d=a.texture.frame.height,a.texture.trim){var k=a.texture.trim;f=k.x-a.anchor.x*k.width,e=f+a.texture.crop.width,h=k.y-a.anchor.y*k.height,g=h+a.texture.crop.height}else e=a.texture.frame.width*(1-a.anchor.x),f=a.texture.frame.width*-a.anchor.x,g=a.texture.frame.height*(1-a.anchor.y),h=a.texture.frame.height*-a.anchor.y;i=4*this.currentBatchSize*this.vertSize,j[i++]=f,j[i++]=h,j[i++]=a.position.x,j[i++]=a.position.y,j[i++]=a.scale.x,j[i++]=a.scale.y,j[i++]=a.rotation,j[i++]=b.x0,j[i++]=b.y1,j[i++]=a.alpha,j[i++]=e,j[i++]=h,j[i++]=a.position.x,j[i++]=a.position.y,j[i++]=a.scale.x,j[i++]=a.scale.y,j[i++]=a.rotation,j[i++]=b.x1,j[i++]=b.y1,j[i++]=a.alpha,j[i++]=e,j[i++]=g,j[i++]=a.position.x,j[i++]=a.position.y,j[i++]=a.scale.x,j[i++]=a.scale.y,j[i++]=a.rotation,j[i++]=b.x2,j[i++]=b.y2,j[i++]=a.alpha,j[i++]=f,j[i++]=g,j[i++]=a.position.x,j[i++]=a.position.y,j[i++]=a.scale.x,j[i++]=a.scale.y,j[i++]=a.rotation,j[i++]=b.x3,j[i++]=b.y3,j[i++]=a.alpha,this.currentBatchSize++,this.currentBatchSize>=this.size&&this.flush()}},b.WebGLFastSpriteBatch.prototype.flush=function(){if(0!==this.currentBatchSize){var a=this.gl;if(this.currentBaseTexture._glTextures[a.id]||b.createWebGLTexture(this.currentBaseTexture,a),a.bindTexture(a.TEXTURE_2D,this.currentBaseTexture._glTextures[a.id]),this.currentBatchSize>.5*this.size)a.bufferSubData(a.ARRAY_BUFFER,0,this.vertices);else{var c=this.vertices.subarray(0,4*this.currentBatchSize*this.vertSize);a.bufferSubData(a.ARRAY_BUFFER,0,c)}a.drawElements(a.TRIANGLES,6*this.currentBatchSize,a.UNSIGNED_SHORT,0),this.currentBatchSize=0,this.renderSession.drawCount++}},b.WebGLFastSpriteBatch.prototype.stop=function(){this.flush()},b.WebGLFastSpriteBatch.prototype.start=function(){var a=this.gl;a.activeTexture(a.TEXTURE0),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer);var b=this.renderSession.projection;a.uniform2f(this.shader.projectionVector,b.x,b.y),a.uniformMatrix3fv(this.shader.uMatrix,!1,this.matrix);var c=4*this.vertSize;a.vertexAttribPointer(this.shader.aVertexPosition,2,a.FLOAT,!1,c,0),a.vertexAttribPointer(this.shader.aPositionCoord,2,a.FLOAT,!1,c,8),a.vertexAttribPointer(this.shader.aScale,2,a.FLOAT,!1,c,16),a.vertexAttribPointer(this.shader.aRotation,1,a.FLOAT,!1,c,24),a.vertexAttribPointer(this.shader.aTextureCoord,2,a.FLOAT,!1,c,28),a.vertexAttribPointer(this.shader.colorAttribute,1,a.FLOAT,!1,c,36)},b.WebGLFilterManager=function(a,b){this.transparent=b,this.filterStack=[],this.offsetX=0,this.offsetY=0,this.setContext(a)},b.WebGLFilterManager.prototype.setContext=function(a){this.gl=a,this.texturePool=[],this.initShaderBuffers()},b.WebGLFilterManager.prototype.begin=function(a,b){this.renderSession=a,this.defaultShader=a.shaderManager.defaultShader;var c=this.renderSession.projection;this.width=2*c.x,this.height=2*-c.y,this.buffer=b},b.WebGLFilterManager.prototype.pushFilter=function(a){var c=this.gl,d=this.renderSession.projection,e=this.renderSession.offset;a._filterArea=a.target.filterArea||a.target.getBounds(),this.filterStack.push(a);var f=a.filterPasses[0];this.offsetX+=a._filterArea.x,this.offsetY+=a._filterArea.y;var g=this.texturePool.pop();g?g.resize(this.width,this.height):g=new b.FilterTexture(this.gl,this.width,this.height),c.bindTexture(c.TEXTURE_2D,g.texture);var h=a._filterArea,i=f.padding;h.x-=i,h.y-=i,h.width+=2*i,h.height+=2*i,h.x<0&&(h.x=0),h.width>this.width&&(h.width=this.width),h.y<0&&(h.y=0),h.height>this.height&&(h.height=this.height),c.bindFramebuffer(c.FRAMEBUFFER,g.frameBuffer),c.viewport(0,0,h.width,h.height),d.x=h.width/2,d.y=-h.height/2,e.x=-h.x,e.y=-h.y,this.renderSession.shaderManager.setShader(this.defaultShader),c.uniform2f(this.defaultShader.projectionVector,h.width/2,-h.height/2),c.uniform2f(this.defaultShader.offsetVector,-h.x,-h.y),c.colorMask(!0,!0,!0,!0),c.clearColor(0,0,0,0),c.clear(c.COLOR_BUFFER_BIT),a._glFilterTexture=g},b.WebGLFilterManager.prototype.popFilter=function(){var a=this.gl,c=this.filterStack.pop(),d=c._filterArea,e=c._glFilterTexture,f=this.renderSession.projection,g=this.renderSession.offset;if(c.filterPasses.length>1){a.viewport(0,0,d.width,d.height),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),this.vertexArray[0]=0,this.vertexArray[1]=d.height,this.vertexArray[2]=d.width,this.vertexArray[3]=d.height,this.vertexArray[4]=0,this.vertexArray[5]=0,this.vertexArray[6]=d.width,this.vertexArray[7]=0,a.bufferSubData(a.ARRAY_BUFFER,0,this.vertexArray),a.bindBuffer(a.ARRAY_BUFFER,this.uvBuffer),this.uvArray[2]=d.width/this.width,this.uvArray[5]=d.height/this.height,this.uvArray[6]=d.width/this.width,this.uvArray[7]=d.height/this.height,a.bufferSubData(a.ARRAY_BUFFER,0,this.uvArray);var h=e,i=this.texturePool.pop();i||(i=new b.FilterTexture(this.gl,this.width,this.height)),i.resize(this.width,this.height),a.bindFramebuffer(a.FRAMEBUFFER,i.frameBuffer),a.clear(a.COLOR_BUFFER_BIT),a.disable(a.BLEND);for(var j=0;j<c.filterPasses.length-1;j++){var k=c.filterPasses[j];a.bindFramebuffer(a.FRAMEBUFFER,i.frameBuffer),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,h.texture),this.applyFilterPass(k,d,d.width,d.height);var l=h;h=i,i=l}a.enable(a.BLEND),e=h,this.texturePool.push(i)}var m=c.filterPasses[c.filterPasses.length-1];this.offsetX-=d.x,this.offsetY-=d.y;var n=this.width,o=this.height,p=0,q=0,r=this.buffer;if(0===this.filterStack.length)a.colorMask(!0,!0,!0,!0);else{var s=this.filterStack[this.filterStack.length-1];d=s._filterArea,n=d.width,o=d.height,p=d.x,q=d.y,r=s._glFilterTexture.frameBuffer}f.x=n/2,f.y=-o/2,g.x=p,g.y=q,d=c._filterArea;var t=d.x-p,u=d.y-q;a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),this.vertexArray[0]=t,this.vertexArray[1]=u+d.height,this.vertexArray[2]=t+d.width,this.vertexArray[3]=u+d.height,this.vertexArray[4]=t,this.vertexArray[5]=u,this.vertexArray[6]=t+d.width,this.vertexArray[7]=u,a.bufferSubData(a.ARRAY_BUFFER,0,this.vertexArray),a.bindBuffer(a.ARRAY_BUFFER,this.uvBuffer),this.uvArray[2]=d.width/this.width,this.uvArray[5]=d.height/this.height,this.uvArray[6]=d.width/this.width,this.uvArray[7]=d.height/this.height,a.bufferSubData(a.ARRAY_BUFFER,0,this.uvArray),a.viewport(0,0,n,o),a.bindFramebuffer(a.FRAMEBUFFER,r),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,e.texture),this.applyFilterPass(m,d,n,o),this.renderSession.shaderManager.setShader(this.defaultShader),a.uniform2f(this.defaultShader.projectionVector,n/2,-o/2),a.uniform2f(this.defaultShader.offsetVector,-p,-q),this.texturePool.push(e),c._glFilterTexture=null},b.WebGLFilterManager.prototype.applyFilterPass=function(a,c,d,e){var f=this.gl,g=a.shaders[f.id];g||(g=new b.PixiShader(f),g.fragmentSrc=a.fragmentSrc,g.uniforms=a.uniforms,g.init(),a.shaders[f.id]=g),this.renderSession.shaderManager.setShader(g),f.uniform2f(g.projectionVector,d/2,-e/2),f.uniform2f(g.offsetVector,0,0),a.uniforms.dimensions&&(a.uniforms.dimensions.value[0]=this.width,a.uniforms.dimensions.value[1]=this.height,a.uniforms.dimensions.value[2]=this.vertexArray[0],a.uniforms.dimensions.value[3]=this.vertexArray[5]),g.syncUniforms(),f.bindBuffer(f.ARRAY_BUFFER,this.vertexBuffer),f.vertexAttribPointer(g.aVertexPosition,2,f.FLOAT,!1,0,0),f.bindBuffer(f.ARRAY_BUFFER,this.uvBuffer),f.vertexAttribPointer(g.aTextureCoord,2,f.FLOAT,!1,0,0),f.bindBuffer(f.ARRAY_BUFFER,this.colorBuffer),f.vertexAttribPointer(g.colorAttribute,2,f.FLOAT,!1,0,0),f.bindBuffer(f.ELEMENT_ARRAY_BUFFER,this.indexBuffer),f.drawElements(f.TRIANGLES,6,f.UNSIGNED_SHORT,0),this.renderSession.drawCount++},b.WebGLFilterManager.prototype.initShaderBuffers=function(){var a=this.gl;this.vertexBuffer=a.createBuffer(),this.uvBuffer=a.createBuffer(),this.colorBuffer=a.createBuffer(),this.indexBuffer=a.createBuffer(),this.vertexArray=new Float32Array([0,0,1,0,0,1,1,1]),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bufferData(a.ARRAY_BUFFER,this.vertexArray,a.STATIC_DRAW),this.uvArray=new Float32Array([0,0,1,0,0,1,1,1]),a.bindBuffer(a.ARRAY_BUFFER,this.uvBuffer),a.bufferData(a.ARRAY_BUFFER,this.uvArray,a.STATIC_DRAW),this.colorArray=new Float32Array([1,16777215,1,16777215,1,16777215,1,16777215]),a.bindBuffer(a.ARRAY_BUFFER,this.colorBuffer),a.bufferData(a.ARRAY_BUFFER,this.colorArray,a.STATIC_DRAW),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,new Uint16Array([0,1,2,1,3,2]),a.STATIC_DRAW)},b.WebGLFilterManager.prototype.destroy=function(){var a=this.gl;this.filterStack=null,this.offsetX=0,this.offsetY=0;for(var b=0;b<this.texturePool.length;b++)this.texturePool[b].destroy();this.texturePool=null,a.deleteBuffer(this.vertexBuffer),a.deleteBuffer(this.uvBuffer),a.deleteBuffer(this.colorBuffer),a.deleteBuffer(this.indexBuffer)},b.FilterTexture=function(a,c,d,e){this.gl=a,this.frameBuffer=a.createFramebuffer(),this.texture=a.createTexture(),e=e||b.scaleModes.DEFAULT,a.bindTexture(a.TEXTURE_2D,this.texture),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,e===b.scaleModes.LINEAR?a.LINEAR:a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,e===b.scaleModes.LINEAR?a.LINEAR:a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.bindFramebuffer(a.FRAMEBUFFER,this.framebuffer),a.bindFramebuffer(a.FRAMEBUFFER,this.frameBuffer),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,this.texture,0),this.renderBuffer=a.createRenderbuffer(),a.bindRenderbuffer(a.RENDERBUFFER,this.renderBuffer),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.RENDERBUFFER,this.renderBuffer),this.resize(c,d)},b.FilterTexture.prototype.clear=function(){var a=this.gl;a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT)},b.FilterTexture.prototype.resize=function(a,b){if(this.width!==a||this.height!==b){this.width=a,this.height=b;var c=this.gl;c.bindTexture(c.TEXTURE_2D,this.texture),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,a,b,0,c.RGBA,c.UNSIGNED_BYTE,null),c.bindRenderbuffer(c.RENDERBUFFER,this.renderBuffer),c.renderbufferStorage(c.RENDERBUFFER,c.DEPTH_STENCIL,a,b)}},b.FilterTexture.prototype.destroy=function(){var a=this.gl;a.deleteFramebuffer(this.frameBuffer),a.deleteTexture(this.texture),this.frameBuffer=null,this.texture=null},b.CanvasMaskManager=function(){},b.CanvasMaskManager.prototype.pushMask=function(a,c){c.save();var d=a.alpha,e=a.worldTransform;c.setTransform(e.a,e.c,e.b,e.d,e.tx,e.ty),b.CanvasGraphics.renderGraphicsMask(a,c),c.clip(),a.worldAlpha=d},b.CanvasMaskManager.prototype.popMask=function(a){a.restore()},b.CanvasTinter=function(){},b.CanvasTinter.getTintedTexture=function(a,c){var d=a.texture;c=b.CanvasTinter.roundColor(c);var e="#"+("00000"+(0|c).toString(16)).substr(-6);if(d.tintCache=d.tintCache||{},d.tintCache[e])return d.tintCache[e];var f=b.CanvasTinter.canvas||document.createElement("canvas");if(b.CanvasTinter.tintMethod(d,c,f),b.CanvasTinter.convertTintToImage){var g=new Image;g.src=f.toDataURL(),d.tintCache[e]=g}else d.tintCache[e]=f,b.CanvasTinter.canvas=null;return f},b.CanvasTinter.tintWithMultiply=function(a,b,c){var d=c.getContext("2d"),e=a.frame;c.width=e.width,c.height=e.height,d.fillStyle="#"+("00000"+(0|b).toString(16)).substr(-6),d.fillRect(0,0,e.width,e.height),d.globalCompositeOperation="multiply",d.drawImage(a.baseTexture.source,e.x,e.y,e.width,e.height,0,0,e.width,e.height),d.globalCompositeOperation="destination-atop",d.drawImage(a.baseTexture.source,e.x,e.y,e.width,e.height,0,0,e.width,e.height)},b.CanvasTinter.tintWithOverlay=function(a,b,c){var d=c.getContext("2d"),e=a.frame;c.width=e.width,c.height=e.height,d.globalCompositeOperation="copy",d.fillStyle="#"+("00000"+(0|b).toString(16)).substr(-6),d.fillRect(0,0,e.width,e.height),d.globalCompositeOperation="destination-atop",d.drawImage(a.baseTexture.source,e.x,e.y,e.width,e.height,0,0,e.width,e.height)},b.CanvasTinter.tintWithPerPixel=function(a,c,d){var e=d.getContext("2d"),f=a.frame;d.width=f.width,d.height=f.height,e.globalCompositeOperation="copy",e.drawImage(a.baseTexture.source,f.x,f.y,f.width,f.height,0,0,f.width,f.height);for(var g=b.hex2rgb(c),h=g[0],i=g[1],j=g[2],k=e.getImageData(0,0,f.width,f.height),l=k.data,m=0;m<l.length;m+=4)l[m+0]*=h,l[m+1]*=i,l[m+2]*=j;e.putImageData(k,0,0)},b.CanvasTinter.roundColor=function(a){var c=b.CanvasTinter.cacheStepsPerColorChannel,d=b.hex2rgb(a);return d[0]=Math.min(255,d[0]/c*c),d[1]=Math.min(255,d[1]/c*c),d[2]=Math.min(255,d[2]/c*c),b.rgb2hex(d)},b.CanvasTinter.cacheStepsPerColorChannel=8,b.CanvasTinter.convertTintToImage=!1,b.CanvasTinter.canUseMultiply=b.canUseNewCanvasBlendModes(),b.CanvasTinter.tintMethod=b.CanvasTinter.canUseMultiply?b.CanvasTinter.tintWithMultiply:b.CanvasTinter.tintWithPerPixel,b.CanvasRenderer=function(a,c,d,e){b.defaultRenderer||(b.sayHello("Canvas"),b.defaultRenderer=this),this.type=b.CANVAS_RENDERER,this.clearBeforeRender=!0,this.transparent=!!e,b.blendModesCanvas||(b.blendModesCanvas=[],b.canUseNewCanvasBlendModes()?(b.blendModesCanvas[b.blendModes.NORMAL]="source-over",b.blendModesCanvas[b.blendModes.ADD]="lighter",b.blendModesCanvas[b.blendModes.MULTIPLY]="multiply",b.blendModesCanvas[b.blendModes.SCREEN]="screen",b.blendModesCanvas[b.blendModes.OVERLAY]="overlay",b.blendModesCanvas[b.blendModes.DARKEN]="darken",b.blendModesCanvas[b.blendModes.LIGHTEN]="lighten",b.blendModesCanvas[b.blendModes.COLOR_DODGE]="color-dodge",b.blendModesCanvas[b.blendModes.COLOR_BURN]="color-burn",b.blendModesCanvas[b.blendModes.HARD_LIGHT]="hard-light",b.blendModesCanvas[b.blendModes.SOFT_LIGHT]="soft-light",b.blendModesCanvas[b.blendModes.DIFFERENCE]="difference",b.blendModesCanvas[b.blendModes.EXCLUSION]="exclusion",b.blendModesCanvas[b.blendModes.HUE]="hue",b.blendModesCanvas[b.blendModes.SATURATION]="saturation",b.blendModesCanvas[b.blendModes.COLOR]="color",b.blendModesCanvas[b.blendModes.LUMINOSITY]="luminosity"):(b.blendModesCanvas[b.blendModes.NORMAL]="source-over",b.blendModesCanvas[b.blendModes.ADD]="lighter",b.blendModesCanvas[b.blendModes.MULTIPLY]="source-over",b.blendModesCanvas[b.blendModes.SCREEN]="source-over",b.blendModesCanvas[b.blendModes.OVERLAY]="source-over",b.blendModesCanvas[b.blendModes.DARKEN]="source-over",b.blendModesCanvas[b.blendModes.LIGHTEN]="source-over",b.blendModesCanvas[b.blendModes.COLOR_DODGE]="source-over",b.blendModesCanvas[b.blendModes.COLOR_BURN]="source-over",b.blendModesCanvas[b.blendModes.HARD_LIGHT]="source-over",b.blendModesCanvas[b.blendModes.SOFT_LIGHT]="source-over",b.blendModesCanvas[b.blendModes.DIFFERENCE]="source-over",b.blendModesCanvas[b.blendModes.EXCLUSION]="source-over",b.blendModesCanvas[b.blendModes.HUE]="source-over",b.blendModesCanvas[b.blendModes.SATURATION]="source-over",b.blendModesCanvas[b.blendModes.COLOR]="source-over",b.blendModesCanvas[b.blendModes.LUMINOSITY]="source-over")),this.width=a||800,this.height=c||600,this.view=d||document.createElement("canvas"),this.context=this.view.getContext("2d",{alpha:this.transparent}),this.refresh=!0,this.view.width=this.width,this.view.height=this.height,this.count=0,this.maskManager=new b.CanvasMaskManager,this.renderSession={context:this.context,maskManager:this.maskManager,scaleMode:null,smoothProperty:null,roundPixels:!1},"imageSmoothingEnabled"in this.context?this.renderSession.smoothProperty="imageSmoothingEnabled":"webkitImageSmoothingEnabled"in this.context?this.renderSession.smoothProperty="webkitImageSmoothingEnabled":"mozImageSmoothingEnabled"in this.context?this.renderSession.smoothProperty="mozImageSmoothingEnabled":"oImageSmoothingEnabled"in this.context&&(this.renderSession.smoothProperty="oImageSmoothingEnabled")},b.CanvasRenderer.prototype.constructor=b.CanvasRenderer,b.CanvasRenderer.prototype.render=function(a){b.texturesToUpdate.length=0,b.texturesToDestroy.length=0,a.updateTransform(),this.context.setTransform(1,0,0,1,0,0),this.context.globalAlpha=1,this.context.globalCompositeOperation=b.blendModesCanvas[b.blendModes.NORMAL],navigator.isCocoonJS&&this.view.screencanvas&&(this.context.fillStyle="black",this.context.clear()),!this.transparent&&this.clearBeforeRender?(this.context.fillStyle=a.backgroundColorString,this.context.fillRect(0,0,this.width,this.height)):this.transparent&&this.clearBeforeRender&&this.context.clearRect(0,0,this.width,this.height),this.renderDisplayObject(a),a.interactive&&(a._interactiveEventsAdded||(a._interactiveEventsAdded=!0,a.interactionManager.setTarget(this))),b.Texture.frameUpdates.length>0&&(b.Texture.frameUpdates.length=0)
},b.CanvasRenderer.prototype.resize=function(a,b){this.width=a,this.height=b,this.view.width=a,this.view.height=b},b.CanvasRenderer.prototype.renderDisplayObject=function(a,b){this.renderSession.context=b||this.context,a._renderCanvas(this.renderSession)},b.CanvasRenderer.prototype.renderStripFlat=function(a){var b=this.context,c=a.verticies,d=c.length/2;this.count++,b.beginPath();for(var e=1;d-2>e;e++){var f=2*e,g=c[f],h=c[f+2],i=c[f+4],j=c[f+1],k=c[f+3],l=c[f+5];b.moveTo(g,j),b.lineTo(h,k),b.lineTo(i,l)}b.fillStyle="#FF0000",b.fill(),b.closePath()},b.CanvasRenderer.prototype.renderStrip=function(a){var b=this.context,c=a.verticies,d=a.uvs,e=c.length/2;this.count++;for(var f=1;e-2>f;f++){var g=2*f,h=c[g],i=c[g+2],j=c[g+4],k=c[g+1],l=c[g+3],m=c[g+5],n=d[g]*a.texture.width,o=d[g+2]*a.texture.width,p=d[g+4]*a.texture.width,q=d[g+1]*a.texture.height,r=d[g+3]*a.texture.height,s=d[g+5]*a.texture.height;b.save(),b.beginPath(),b.moveTo(h,k),b.lineTo(i,l),b.lineTo(j,m),b.closePath(),b.clip();var t=n*r+q*p+o*s-r*p-q*o-n*s,u=h*r+q*j+i*s-r*j-q*i-h*s,v=n*i+h*p+o*j-i*p-h*o-n*j,w=n*r*j+q*i*p+h*o*s-h*r*p-q*o*j-n*i*s,x=k*r+q*m+l*s-r*m-q*l-k*s,y=n*l+k*p+o*m-l*p-k*o-n*m,z=n*r*m+q*l*p+k*o*s-k*r*p-q*o*m-n*l*s;b.transform(u/t,x/t,v/t,y/t,w/t,z/t),b.drawImage(a.texture.baseTexture.source,0,0),b.restore()}},b.CanvasBuffer=function(a,b){this.width=a,this.height=b,this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.canvas.width=a,this.canvas.height=b},b.CanvasBuffer.prototype.clear=function(){this.context.clearRect(0,0,this.width,this.height)},b.CanvasBuffer.prototype.resize=function(a,b){this.width=this.canvas.width=a,this.height=this.canvas.height=b},b.CanvasGraphics=function(){},b.CanvasGraphics.renderGraphics=function(a,c){for(var d=a.worldAlpha,e="",f=0;f<a.graphicsData.length;f++){var g=a.graphicsData[f],h=g.points;if(c.strokeStyle=e="#"+("00000"+(0|g.lineColor).toString(16)).substr(-6),c.lineWidth=g.lineWidth,g.type===b.Graphics.POLY){c.beginPath(),c.moveTo(h[0],h[1]);for(var i=1;i<h.length/2;i++)c.lineTo(h[2*i],h[2*i+1]);h[0]===h[h.length-2]&&h[1]===h[h.length-1]&&c.closePath(),g.fill&&(c.globalAlpha=g.fillAlpha*d,c.fillStyle=e="#"+("00000"+(0|g.fillColor).toString(16)).substr(-6),c.fill()),g.lineWidth&&(c.globalAlpha=g.lineAlpha*d,c.stroke())}else if(g.type===b.Graphics.RECT)(g.fillColor||0===g.fillColor)&&(c.globalAlpha=g.fillAlpha*d,c.fillStyle=e="#"+("00000"+(0|g.fillColor).toString(16)).substr(-6),c.fillRect(h[0],h[1],h[2],h[3])),g.lineWidth&&(c.globalAlpha=g.lineAlpha*d,c.strokeRect(h[0],h[1],h[2],h[3]));else if(g.type===b.Graphics.CIRC)c.beginPath(),c.arc(h[0],h[1],h[2],0,2*Math.PI),c.closePath(),g.fill&&(c.globalAlpha=g.fillAlpha*d,c.fillStyle=e="#"+("00000"+(0|g.fillColor).toString(16)).substr(-6),c.fill()),g.lineWidth&&(c.globalAlpha=g.lineAlpha*d,c.stroke());else if(g.type===b.Graphics.ELIP){var j=g.points,k=2*j[2],l=2*j[3],m=j[0]-k/2,n=j[1]-l/2;c.beginPath();var o=.5522848,p=k/2*o,q=l/2*o,r=m+k,s=n+l,t=m+k/2,u=n+l/2;c.moveTo(m,u),c.bezierCurveTo(m,u-q,t-p,n,t,n),c.bezierCurveTo(t+p,n,r,u-q,r,u),c.bezierCurveTo(r,u+q,t+p,s,t,s),c.bezierCurveTo(t-p,s,m,u+q,m,u),c.closePath(),g.fill&&(c.globalAlpha=g.fillAlpha*d,c.fillStyle=e="#"+("00000"+(0|g.fillColor).toString(16)).substr(-6),c.fill()),g.lineWidth&&(c.globalAlpha=g.lineAlpha*d,c.stroke())}else if(g.type===b.Graphics.RREC){var v=h[0],w=h[1],x=h[2],y=h[3],z=h[4],A=Math.min(x,y)/2|0;z=z>A?A:z,c.beginPath(),c.moveTo(v,w+z),c.lineTo(v,w+y-z),c.quadraticCurveTo(v,w+y,v+z,w+y),c.lineTo(v+x-z,w+y),c.quadraticCurveTo(v+x,w+y,v+x,w+y-z),c.lineTo(v+x,w+z),c.quadraticCurveTo(v+x,w,v+x-z,w),c.lineTo(v+z,w),c.quadraticCurveTo(v,w,v,w+z),c.closePath(),(g.fillColor||0===g.fillColor)&&(c.globalAlpha=g.fillAlpha*d,c.fillStyle=e="#"+("00000"+(0|g.fillColor).toString(16)).substr(-6),c.fill()),g.lineWidth&&(c.globalAlpha=g.lineAlpha*d,c.stroke())}}},b.CanvasGraphics.renderGraphicsMask=function(a,c){var d=a.graphicsData.length;if(0!==d){d>1&&(d=1,window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object"));for(var e=0;1>e;e++){var f=a.graphicsData[e],g=f.points;if(f.type===b.Graphics.POLY){c.beginPath(),c.moveTo(g[0],g[1]);for(var h=1;h<g.length/2;h++)c.lineTo(g[2*h],g[2*h+1]);g[0]===g[g.length-2]&&g[1]===g[g.length-1]&&c.closePath()}else if(f.type===b.Graphics.RECT)c.beginPath(),c.rect(g[0],g[1],g[2],g[3]),c.closePath();else if(f.type===b.Graphics.CIRC)c.beginPath(),c.arc(g[0],g[1],g[2],0,2*Math.PI),c.closePath();else if(f.type===b.Graphics.ELIP){var i=f.points,j=2*i[2],k=2*i[3],l=i[0]-j/2,m=i[1]-k/2;c.beginPath();var n=.5522848,o=j/2*n,p=k/2*n,q=l+j,r=m+k,s=l+j/2,t=m+k/2;c.moveTo(l,t),c.bezierCurveTo(l,t-p,s-o,m,s,m),c.bezierCurveTo(s+o,m,q,t-p,q,t),c.bezierCurveTo(q,t+p,s+o,r,s,r),c.bezierCurveTo(s-o,r,l,t+p,l,t),c.closePath()}else if(f.type===b.Graphics.RREC){var u=g[0],v=g[1],w=g[2],x=g[3],y=g[4],z=Math.min(w,x)/2|0;y=y>z?z:y,c.beginPath(),c.moveTo(u,v+y),c.lineTo(u,v+x-y),c.quadraticCurveTo(u,v+x,u+y,v+x),c.lineTo(u+w-y,v+x),c.quadraticCurveTo(u+w,v+x,u+w,v+x-y),c.lineTo(u+w,v+y),c.quadraticCurveTo(u+w,v,u+w-y,v),c.lineTo(u+y,v),c.quadraticCurveTo(u,v,u,v+y),c.closePath()}}}},b.Graphics=function(){b.DisplayObjectContainer.call(this),this.renderable=!0,this.fillAlpha=1,this.lineWidth=0,this.lineColor="black",this.graphicsData=[],this.tint=16777215,this.blendMode=b.blendModes.NORMAL,this.currentPath={points:[]},this._webGL=[],this.isMask=!1,this.bounds=null,this.boundsPadding=10,this.dirty=!0},b.Graphics.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Graphics.prototype.constructor=b.Graphics,Object.defineProperty(b.Graphics.prototype,"cacheAsBitmap",{get:function(){return this._cacheAsBitmap},set:function(a){this._cacheAsBitmap=a,this._cacheAsBitmap?this._generateCachedSprite():(this.destroyCachedSprite(),this.dirty=!0)}}),b.Graphics.prototype.lineStyle=function(a,c,d){return this.currentPath.points.length||this.graphicsData.pop(),this.lineWidth=a||0,this.lineColor=c||0,this.lineAlpha=arguments.length<3?1:d,this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[],type:b.Graphics.POLY},this.graphicsData.push(this.currentPath),this},b.Graphics.prototype.moveTo=function(a,c){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath=this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[],type:b.Graphics.POLY},this.currentPath.points.push(a,c),this.graphicsData.push(this.currentPath),this},b.Graphics.prototype.lineTo=function(a,b){return this.currentPath.points.push(a,b),this.dirty=!0,this},b.Graphics.prototype.quadraticCurveTo=function(a,b,c,d){0===this.currentPath.points.length&&this.moveTo(0,0);var e,f,g=20,h=this.currentPath.points;0===h.length&&this.moveTo(0,0);for(var i=h[h.length-2],j=h[h.length-1],k=0,l=1;g>=l;l++)k=l/g,e=i+(a-i)*k,f=j+(b-j)*k,h.push(e+(a+(c-a)*k-e)*k,f+(b+(d-b)*k-f)*k);return this.dirty=!0,this},b.Graphics.prototype.bezierCurveTo=function(a,b,c,d,e,f){0===this.currentPath.points.length&&this.moveTo(0,0);for(var g,h,i,j,k,l=20,m=this.currentPath.points,n=m[m.length-2],o=m[m.length-1],p=0,q=1;l>q;q++)p=q/l,g=1-p,h=g*g,i=h*g,j=p*p,k=j*p,m.push(i*n+3*h*p*a+3*g*j*c+k*e,i*o+3*h*p*b+3*g*j*d+k*f);return this.dirty=!0,this},b.Graphics.prototype.arcTo=function(a,b,c,d,e){0===this.currentPath.points.length&&this.moveTo(a,b);var f=this.currentPath.points,g=f[f.length-2],h=f[f.length-1],i=h-b,j=g-a,k=d-b,l=c-a,m=Math.abs(i*l-j*k);if(1e-8>m||0===e)f.push(a,b);else{var n=i*i+j*j,o=k*k+l*l,p=i*k+j*l,q=e*Math.sqrt(n)/m,r=e*Math.sqrt(o)/m,s=q*p/n,t=r*p/o,u=q*l+r*j,v=q*k+r*i,w=j*(r+s),x=i*(r+s),y=l*(q+t),z=k*(q+t),A=Math.atan2(x-v,w-u),B=Math.atan2(z-v,y-u);this.arc(u+a,v+b,e,A,B,j*k>l*i)}return this.dirty=!0,this},b.Graphics.prototype.arc=function(a,b,c,d,e,f){var g=a+Math.cos(d)*c,h=b+Math.sin(d)*c,i=this.currentPath.points;if((0!==i.length&&i[i.length-2]!==g||i[i.length-1]!==h)&&(this.moveTo(g,h),i=this.currentPath.points),d===e)return this;!f&&d>=e?e+=2*Math.PI:f&&e>=d&&(d+=2*Math.PI);var j=f?-1*(d-e):e-d,k=Math.abs(j)/(2*Math.PI)*40;if(0===j)return this;for(var l=j/(2*k),m=2*l,n=Math.cos(l),o=Math.sin(l),p=k-1,q=p%1/p,r=0;p>=r;r++){var s=r+q*r,t=l+d+m*s,u=Math.cos(t),v=-Math.sin(t);i.push((n*u+o*v)*c+a,(n*-v+o*u)*c+b)}return this.dirty=!0,this},b.Graphics.prototype.drawPath=function(a){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath=this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[],type:b.Graphics.POLY},this.graphicsData.push(this.currentPath),this.currentPath.points=this.currentPath.points.concat(a),this.dirty=!0,this},b.Graphics.prototype.beginFill=function(a,b){return this.filling=!0,this.fillColor=a||0,this.fillAlpha=arguments.length<2?1:b,this},b.Graphics.prototype.endFill=function(){return this.filling=!1,this.fillColor=null,this.fillAlpha=1,this},b.Graphics.prototype.drawRect=function(a,c,d,e){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[a,c,d,e],type:b.Graphics.RECT},this.graphicsData.push(this.currentPath),this.dirty=!0,this},b.Graphics.prototype.drawRoundedRect=function(a,c,d,e,f){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[a,c,d,e,f],type:b.Graphics.RREC},this.graphicsData.push(this.currentPath),this.dirty=!0,this},b.Graphics.prototype.drawCircle=function(a,c,d){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[a,c,d,d],type:b.Graphics.CIRC},this.graphicsData.push(this.currentPath),this.dirty=!0,this},b.Graphics.prototype.drawEllipse=function(a,c,d,e){return this.currentPath.points.length||this.graphicsData.pop(),this.currentPath={lineWidth:this.lineWidth,lineColor:this.lineColor,lineAlpha:this.lineAlpha,fillColor:this.fillColor,fillAlpha:this.fillAlpha,fill:this.filling,points:[a,c,d,e],type:b.Graphics.ELIP},this.graphicsData.push(this.currentPath),this.dirty=!0,this},b.Graphics.prototype.clear=function(){return this.lineWidth=0,this.filling=!1,this.dirty=!0,this.clearDirty=!0,this.graphicsData=[],this.bounds=null,this},b.Graphics.prototype.generateTexture=function(){var a=this.getBounds(),c=new b.CanvasBuffer(a.width,a.height),d=b.Texture.fromCanvas(c.canvas);return c.context.translate(-a.x,-a.y),b.CanvasGraphics.renderGraphics(this,c.context),d},b.Graphics.prototype._renderWebGL=function(a){if(this.visible!==!1&&0!==this.alpha&&this.isMask!==!0){if(this._cacheAsBitmap)return this.dirty&&(this._generateCachedSprite(),b.updateWebGLTexture(this._cachedSprite.texture.baseTexture,a.gl),this.dirty=!1),this._cachedSprite.alpha=this.alpha,void b.Sprite.prototype._renderWebGL.call(this._cachedSprite,a);if(a.spriteBatch.stop(),a.blendModeManager.setBlendMode(this.blendMode),this._mask&&a.maskManager.pushMask(this._mask,a),this._filters&&a.filterManager.pushFilter(this._filterBlock),this.blendMode!==a.spriteBatch.currentBlendMode){a.spriteBatch.currentBlendMode=this.blendMode;var c=b.blendModesWebGL[a.spriteBatch.currentBlendMode];a.spriteBatch.gl.blendFunc(c[0],c[1])}if(b.WebGLGraphics.renderGraphics(this,a),this.children.length){a.spriteBatch.start();for(var d=0,e=this.children.length;e>d;d++)this.children[d]._renderWebGL(a);a.spriteBatch.stop()}this._filters&&a.filterManager.popFilter(),this._mask&&a.maskManager.popMask(this.mask,a),a.drawCount++,a.spriteBatch.start()}},b.Graphics.prototype._renderCanvas=function(a){if(this.visible!==!1&&0!==this.alpha&&this.isMask!==!0){var c=a.context,d=this.worldTransform;this.blendMode!==a.currentBlendMode&&(a.currentBlendMode=this.blendMode,c.globalCompositeOperation=b.blendModesCanvas[a.currentBlendMode]),this._mask&&a.maskManager.pushMask(this._mask,a.context),c.setTransform(d.a,d.c,d.b,d.d,d.tx,d.ty),b.CanvasGraphics.renderGraphics(this,c);for(var e=0,f=this.children.length;f>e;e++)this.children[e]._renderCanvas(a);this._mask&&a.maskManager.popMask(a.context)}},b.Graphics.prototype.getBounds=function(a){this.bounds||this.updateBounds();var b=this.bounds.x,c=this.bounds.width+this.bounds.x,d=this.bounds.y,e=this.bounds.height+this.bounds.y,f=a||this.worldTransform,g=f.a,h=f.c,i=f.b,j=f.d,k=f.tx,l=f.ty,m=g*c+i*e+k,n=j*e+h*c+l,o=g*b+i*e+k,p=j*e+h*b+l,q=g*b+i*d+k,r=j*d+h*b+l,s=g*c+i*d+k,t=j*d+h*c+l,u=m,v=n,w=m,x=n;w=w>o?o:w,w=w>q?q:w,w=w>s?s:w,x=x>p?p:x,x=x>r?r:x,x=x>t?t:x,u=o>u?o:u,u=q>u?q:u,u=s>u?s:u,v=p>v?p:v,v=r>v?r:v,v=t>v?t:v;var y=this._bounds;return y.x=w,y.width=u-w,y.y=x,y.height=v-x,y},b.Graphics.prototype.updateBounds=function(){for(var a,c,d,e,f,g=1/0,h=-1/0,i=1/0,j=-1/0,k=0;k<this.graphicsData.length;k++){var l=this.graphicsData[k],m=l.type,n=l.lineWidth;if(a=l.points,m===b.Graphics.RECT)c=a[0]-n/2,d=a[1]-n/2,e=a[2]+n,f=a[3]+n,g=g>c?c:g,h=c+e>h?c+e:h,i=i>d?c:i,j=d+f>j?d+f:j;else if(m===b.Graphics.CIRC||m===b.Graphics.ELIP)c=a[0],d=a[1],e=a[2]+n/2,f=a[3]+n/2,g=g>c-e?c-e:g,h=c+e>h?c+e:h,i=i>d-f?d-f:i,j=d+f>j?d+f:j;else for(var o=0;o<a.length;o+=2)c=a[o],d=a[o+1],g=g>c-n?c-n:g,h=c+n>h?c+n:h,i=i>d-n?d-n:i,j=d+n>j?d+n:j}var p=this.boundsPadding;this.bounds=new b.Rectangle(g-p,i-p,h-g+2*p,j-i+2*p)},b.Graphics.prototype._generateCachedSprite=function(){var a=this.getLocalBounds();if(this._cachedSprite)this._cachedSprite.buffer.resize(a.width,a.height);else{var c=new b.CanvasBuffer(a.width,a.height),d=b.Texture.fromCanvas(c.canvas);this._cachedSprite=new b.Sprite(d),this._cachedSprite.buffer=c,this._cachedSprite.worldTransform=this.worldTransform}this._cachedSprite.anchor.x=-(a.x/a.width),this._cachedSprite.anchor.y=-(a.y/a.height),this._cachedSprite.buffer.context.translate(-a.x,-a.y),b.CanvasGraphics.renderGraphics(this,this._cachedSprite.buffer.context),this._cachedSprite.alpha=this.alpha},b.Graphics.prototype.destroyCachedSprite=function(){this._cachedSprite.texture.destroy(!0),this._cachedSprite=null},b.Graphics.POLY=0,b.Graphics.RECT=1,b.Graphics.CIRC=2,b.Graphics.ELIP=3,b.Graphics.RREC=4,b.Strip=function(a){b.DisplayObjectContainer.call(this),this.texture=a,this.uvs=new b.Float32Array([0,1,1,1,1,0,0,1]),this.verticies=new b.Float32Array([0,0,100,0,100,100,0,100]),this.colors=new b.Float32Array([1,1,1,1]),this.indices=new b.Uint16Array([0,1,2,3]),this.dirty=!0},b.Strip.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Strip.prototype.constructor=b.Strip,b.Strip.prototype._renderWebGL=function(a){!this.visible||this.alpha<=0||(a.spriteBatch.stop(),this._vertexBuffer||this._initWebGL(a),a.shaderManager.setShader(a.shaderManager.stripShader),this._renderStrip(a),a.spriteBatch.start())},b.Strip.prototype._initWebGL=function(a){var b=a.gl;this._vertexBuffer=b.createBuffer(),this._indexBuffer=b.createBuffer(),this._uvBuffer=b.createBuffer(),this._colorBuffer=b.createBuffer(),b.bindBuffer(b.ARRAY_BUFFER,this._vertexBuffer),b.bufferData(b.ARRAY_BUFFER,this.verticies,b.DYNAMIC_DRAW),b.bindBuffer(b.ARRAY_BUFFER,this._uvBuffer),b.bufferData(b.ARRAY_BUFFER,this.uvs,b.STATIC_DRAW),b.bindBuffer(b.ARRAY_BUFFER,this._colorBuffer),b.bufferData(b.ARRAY_BUFFER,this.colors,b.STATIC_DRAW),b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,this._indexBuffer),b.bufferData(b.ELEMENT_ARRAY_BUFFER,this.indices,b.STATIC_DRAW)},b.Strip.prototype._renderStrip=function(a){var c=a.gl,d=a.projection,e=a.offset,f=a.shaderManager.stripShader;c.blendFunc(c.ONE,c.ONE_MINUS_SRC_ALPHA),c.uniformMatrix3fv(f.translationMatrix,!1,this.worldTransform.toArray(!0)),c.uniform2f(f.projectionVector,d.x,-d.y),c.uniform2f(f.offsetVector,-e.x,-e.y),c.uniform1f(f.alpha,1),this.dirty?(this.dirty=!1,c.bindBuffer(c.ARRAY_BUFFER,this._vertexBuffer),c.bufferData(c.ARRAY_BUFFER,this.verticies,c.STATIC_DRAW),c.vertexAttribPointer(f.aVertexPosition,2,c.FLOAT,!1,0,0),c.bindBuffer(c.ARRAY_BUFFER,this._uvBuffer),c.bufferData(c.ARRAY_BUFFER,this.uvs,c.STATIC_DRAW),c.vertexAttribPointer(f.aTextureCoord,2,c.FLOAT,!1,0,0),c.activeTexture(c.TEXTURE0),c.bindTexture(c.TEXTURE_2D,this.texture.baseTexture._glTextures[c.id]||b.createWebGLTexture(this.texture.baseTexture,c)),c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,this._indexBuffer),c.bufferData(c.ELEMENT_ARRAY_BUFFER,this.indices,c.STATIC_DRAW)):(c.bindBuffer(c.ARRAY_BUFFER,this._vertexBuffer),c.bufferSubData(c.ARRAY_BUFFER,0,this.verticies),c.vertexAttribPointer(f.aVertexPosition,2,c.FLOAT,!1,0,0),c.bindBuffer(c.ARRAY_BUFFER,this._uvBuffer),c.vertexAttribPointer(f.aTextureCoord,2,c.FLOAT,!1,0,0),c.activeTexture(c.TEXTURE0),c.bindTexture(c.TEXTURE_2D,this.texture.baseTexture._glTextures[c.id]||b.createWebGLTexture(this.texture.baseTexture,c)),c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,this._indexBuffer)),c.drawElements(c.TRIANGLE_STRIP,this.indices.length,c.UNSIGNED_SHORT,0)},b.Strip.prototype._renderCanvas=function(a){var b=a.context,c=this.worldTransform;a.roundPixels?b.setTransform(c.a,c.c,c.b,c.d,0|c.tx,0|c.ty):b.setTransform(c.a,c.c,c.b,c.d,c.tx,c.ty);var d=this,e=d.verticies,f=d.uvs,g=e.length/2;this.count++;for(var h=0;g-2>h;h++){var i=2*h,j=e[i],k=e[i+2],l=e[i+4],m=e[i+1],n=e[i+3],o=e[i+5],p=(j+k+l)/3,q=(m+n+o)/3,r=j-p,s=m-q,t=Math.sqrt(r*r+s*s);j=p+r/t*(t+3),m=q+s/t*(t+3),r=k-p,s=n-q,t=Math.sqrt(r*r+s*s),k=p+r/t*(t+3),n=q+s/t*(t+3),r=l-p,s=o-q,t=Math.sqrt(r*r+s*s),l=p+r/t*(t+3),o=q+s/t*(t+3);var u=f[i]*d.texture.width,v=f[i+2]*d.texture.width,w=f[i+4]*d.texture.width,x=f[i+1]*d.texture.height,y=f[i+3]*d.texture.height,z=f[i+5]*d.texture.height;b.save(),b.beginPath(),b.moveTo(j,m),b.lineTo(k,n),b.lineTo(l,o),b.closePath(),b.clip();var A=u*y+x*w+v*z-y*w-x*v-u*z,B=j*y+x*l+k*z-y*l-x*k-j*z,C=u*k+j*w+v*l-k*w-j*v-u*l,D=u*y*l+x*k*w+j*v*z-j*y*w-x*v*l-u*k*z,E=m*y+x*o+n*z-y*o-x*n-m*z,F=u*n+m*w+v*o-n*w-m*v-u*o,G=u*y*o+x*n*w+m*v*z-m*y*w-x*v*o-u*n*z;b.transform(B/A,E/A,C/A,F/A,D/A,G/A),b.drawImage(d.texture.baseTexture.source,0,0),b.restore()}},b.Strip.prototype.onTextureUpdate=function(){this.updateFrame=!0},b.Rope=function(a,c){b.Strip.call(this,a),this.points=c,this.verticies=new b.Float32Array(4*c.length),this.uvs=new b.Float32Array(4*c.length),this.colors=new b.Float32Array(2*c.length),this.indices=new b.Uint16Array(2*c.length),this.refresh()},b.Rope.prototype=Object.create(b.Strip.prototype),b.Rope.prototype.constructor=b.Rope,b.Rope.prototype.refresh=function(){var a=this.points;if(!(a.length<1)){var b=this.uvs,c=a[0],d=this.indices,e=this.colors;this.count-=.2,b[0]=0,b[1]=0,b[2]=0,b[3]=1,e[0]=1,e[1]=1,d[0]=0,d[1]=1;for(var f,g,h,i=a.length,j=1;i>j;j++)f=a[j],g=4*j,h=j/(i-1),j%2?(b[g]=h,b[g+1]=0,b[g+2]=h,b[g+3]=1):(b[g]=h,b[g+1]=0,b[g+2]=h,b[g+3]=1),g=2*j,e[g]=1,e[g+1]=1,g=2*j,d[g]=g,d[g+1]=g+1,c=f}},b.Rope.prototype.updateTransform=function(){var a=this.points;if(!(a.length<1)){var c,d=a[0],e={x:0,y:0};this.count-=.2;for(var f,g,h,i,j,k=this.verticies,l=a.length,m=0;l>m;m++)f=a[m],g=4*m,c=m<a.length-1?a[m+1]:f,e.y=-(c.x-d.x),e.x=c.y-d.y,h=10*(1-m/(l-1)),h>1&&(h=1),i=Math.sqrt(e.x*e.x+e.y*e.y),j=this.texture.height/2,e.x/=i,e.y/=i,e.x*=j,e.y*=j,k[g]=f.x+e.x,k[g+1]=f.y+e.y,k[g+2]=f.x-e.x,k[g+3]=f.y-e.y,d=f;b.DisplayObjectContainer.prototype.updateTransform.call(this)}},b.Rope.prototype.setTexture=function(a){this.texture=a},b.TilingSprite=function(a,c,d){b.Sprite.call(this,a),this._width=c||100,this._height=d||100,this.tileScale=new b.Point(1,1),this.tileScaleOffset=new b.Point(1,1),this.tilePosition=new b.Point(0,0),this.renderable=!0,this.tint=16777215,this.blendMode=b.blendModes.NORMAL},b.TilingSprite.prototype=Object.create(b.Sprite.prototype),b.TilingSprite.prototype.constructor=b.TilingSprite,Object.defineProperty(b.TilingSprite.prototype,"width",{get:function(){return this._width},set:function(a){this._width=a}}),Object.defineProperty(b.TilingSprite.prototype,"height",{get:function(){return this._height},set:function(a){this._height=a}}),b.TilingSprite.prototype.setTexture=function(a){this.texture!==a&&(this.texture=a,this.refreshTexture=!0,this.cachedTint=16777215)},b.TilingSprite.prototype._renderWebGL=function(a){if(this.visible!==!1&&0!==this.alpha){var c,d;for(this._mask&&(a.spriteBatch.stop(),a.maskManager.pushMask(this.mask,a),a.spriteBatch.start()),this._filters&&(a.spriteBatch.flush(),a.filterManager.pushFilter(this._filterBlock)),!this.tilingTexture||this.refreshTexture?(this.generateTilingTexture(!0),this.tilingTexture&&this.tilingTexture.needsUpdate&&(b.updateWebGLTexture(this.tilingTexture.baseTexture,a.gl),this.tilingTexture.needsUpdate=!1)):a.spriteBatch.renderTilingSprite(this),c=0,d=this.children.length;d>c;c++)this.children[c]._renderWebGL(a);a.spriteBatch.stop(),this._filters&&a.filterManager.popFilter(),this._mask&&a.maskManager.popMask(a),a.spriteBatch.start()}},b.TilingSprite.prototype._renderCanvas=function(a){if(this.visible!==!1&&0!==this.alpha){var c=a.context;this._mask&&a.maskManager.pushMask(this._mask,c),c.globalAlpha=this.worldAlpha;var d,e,f=this.worldTransform;if(c.setTransform(f.a,f.c,f.b,f.d,f.tx,f.ty),!this.__tilePattern||this.refreshTexture){if(this.generateTilingTexture(!1),!this.tilingTexture)return;this.__tilePattern=c.createPattern(this.tilingTexture.baseTexture.source,"repeat")}this.blendMode!==a.currentBlendMode&&(a.currentBlendMode=this.blendMode,c.globalCompositeOperation=b.blendModesCanvas[a.currentBlendMode]);var g=this.tilePosition,h=this.tileScale;for(g.x%=this.tilingTexture.baseTexture.width,g.y%=this.tilingTexture.baseTexture.height,c.scale(h.x,h.y),c.translate(g.x,g.y),c.fillStyle=this.__tilePattern,c.fillRect(-g.x+this.anchor.x*-this._width,-g.y+this.anchor.y*-this._height,this._width/h.x,this._height/h.y),c.scale(1/h.x,1/h.y),c.translate(-g.x,-g.y),this._mask&&a.maskManager.popMask(a.context),d=0,e=this.children.length;e>d;d++)this.children[d]._renderCanvas(a)}},b.TilingSprite.prototype.getBounds=function(){var a=this._width,b=this._height,c=a*(1-this.anchor.x),d=a*-this.anchor.x,e=b*(1-this.anchor.y),f=b*-this.anchor.y,g=this.worldTransform,h=g.a,i=g.c,j=g.b,k=g.d,l=g.tx,m=g.ty,n=h*d+j*f+l,o=k*f+i*d+m,p=h*c+j*f+l,q=k*f+i*c+m,r=h*c+j*e+l,s=k*e+i*c+m,t=h*d+j*e+l,u=k*e+i*d+m,v=-1/0,w=-1/0,x=1/0,y=1/0;x=x>n?n:x,x=x>p?p:x,x=x>r?r:x,x=x>t?t:x,y=y>o?o:y,y=y>q?q:y,y=y>s?s:y,y=y>u?u:y,v=n>v?n:v,v=p>v?p:v,v=r>v?r:v,v=t>v?t:v,w=o>w?o:w,w=q>w?q:w,w=s>w?s:w,w=u>w?u:w;var z=this._bounds;return z.x=x,z.width=v-x,z.y=y,z.height=w-y,this._currentBounds=z,z},b.TilingSprite.prototype.onTextureUpdate=function(){},b.TilingSprite.prototype.generateTilingTexture=function(a){if(this.texture.baseTexture.hasLoaded){var c,d,e=this.texture,f=e.frame,g=f.width!==e.baseTexture.width||f.height!==e.baseTexture.height,h=!1;if(a?(c=b.getNextPowerOfTwo(f.width),d=b.getNextPowerOfTwo(f.height),(f.width!==c||f.height!==d)&&(h=!0)):g&&(c=f.width,d=f.height,h=!0),h){var i;this.tilingTexture&&this.tilingTexture.isTiling?(i=this.tilingTexture.canvasBuffer,i.resize(c,d),this.tilingTexture.baseTexture.width=c,this.tilingTexture.baseTexture.height=d,this.tilingTexture.needsUpdate=!0):(i=new b.CanvasBuffer(c,d),this.tilingTexture=b.Texture.fromCanvas(i.canvas),this.tilingTexture.canvasBuffer=i,this.tilingTexture.isTiling=!0),i.context.drawImage(e.baseTexture.source,e.crop.x,e.crop.y,e.crop.width,e.crop.height,0,0,c,d),this.tileScaleOffset.x=f.width/c,this.tileScaleOffset.y=f.height/d}else this.tilingTexture&&this.tilingTexture.isTiling&&this.tilingTexture.destroy(!0),this.tileScaleOffset.x=1,this.tileScaleOffset.y=1,this.tilingTexture=e;this.refreshTexture=!1,this.tilingTexture.baseTexture._powerOf2=!0}};var f={};f.BoneData=function(a,b){this.name=a,this.parent=b},f.BoneData.prototype={length:0,x:0,y:0,rotation:0,scaleX:1,scaleY:1},f.SlotData=function(a,b){this.name=a,this.boneData=b},f.SlotData.prototype={r:1,g:1,b:1,a:1,attachmentName:null},f.Bone=function(a,b){this.data=a,this.parent=b,this.setToSetupPose()},f.Bone.yDown=!1,f.Bone.prototype={x:0,y:0,rotation:0,scaleX:1,scaleY:1,m00:0,m01:0,worldX:0,m10:0,m11:0,worldY:0,worldRotation:0,worldScaleX:1,worldScaleY:1,updateWorldTransform:function(a,b){var c=this.parent;null!=c?(this.worldX=this.x*c.m00+this.y*c.m01+c.worldX,this.worldY=this.x*c.m10+this.y*c.m11+c.worldY,this.worldScaleX=c.worldScaleX*this.scaleX,this.worldScaleY=c.worldScaleY*this.scaleY,this.worldRotation=c.worldRotation+this.rotation):(this.worldX=this.x,this.worldY=this.y,this.worldScaleX=this.scaleX,this.worldScaleY=this.scaleY,this.worldRotation=this.rotation);var d=this.worldRotation*Math.PI/180,e=Math.cos(d),g=Math.sin(d);this.m00=e*this.worldScaleX,this.m10=g*this.worldScaleX,this.m01=-g*this.worldScaleY,this.m11=e*this.worldScaleY,a&&(this.m00=-this.m00,this.m01=-this.m01),b&&(this.m10=-this.m10,this.m11=-this.m11),f.Bone.yDown&&(this.m10=-this.m10,this.m11=-this.m11)},setToSetupPose:function(){var a=this.data;this.x=a.x,this.y=a.y,this.rotation=a.rotation,this.scaleX=a.scaleX,this.scaleY=a.scaleY}},f.Slot=function(a,b,c){this.data=a,this.skeleton=b,this.bone=c,this.setToSetupPose()},f.Slot.prototype={r:1,g:1,b:1,a:1,_attachmentTime:0,attachment:null,setAttachment:function(a){this.attachment=a,this._attachmentTime=this.skeleton.time},setAttachmentTime:function(a){this._attachmentTime=this.skeleton.time-a},getAttachmentTime:function(){return this.skeleton.time-this._attachmentTime},setToSetupPose:function(){var a=this.data;this.r=a.r,this.g=a.g,this.b=a.b,this.a=a.a;for(var b=this.skeleton.data.slots,c=0,d=b.length;d>c;c++)if(b[c]==a){this.setAttachment(a.attachmentName?this.skeleton.getAttachmentBySlotIndex(c,a.attachmentName):null);break}}},f.Skin=function(a){this.name=a,this.attachments={}},f.Skin.prototype={addAttachment:function(a,b,c){this.attachments[a+":"+b]=c},getAttachment:function(a,b){return this.attachments[a+":"+b]},_attachAll:function(a,b){for(var c in b.attachments){var d=c.indexOf(":"),e=parseInt(c.substring(0,d),10),f=c.substring(d+1),g=a.slots[e];if(g.attachment&&g.attachment.name==f){var h=this.getAttachment(e,f);h&&g.setAttachment(h)}}}},f.Animation=function(a,b,c){this.name=a,this.timelines=b,this.duration=c},f.Animation.prototype={apply:function(a,b,c){c&&this.duration&&(b%=this.duration);for(var d=this.timelines,e=0,f=d.length;f>e;e++)d[e].apply(a,b,1)},mix:function(a,b,c,d){c&&this.duration&&(b%=this.duration);for(var e=this.timelines,f=0,g=e.length;g>f;f++)e[f].apply(a,b,d)}},f.binarySearch=function(a,b,c){var d=0,e=Math.floor(a.length/c)-2;if(!e)return c;for(var f=e>>>1;;){if(a[(f+1)*c]<=b?d=f+1:e=f,d==e)return(d+1)*c;f=d+e>>>1}},f.linearSearch=function(a,b,c){for(var d=0,e=a.length-c;e>=d;d+=c)if(a[d]>b)return d;return-1},f.Curves=function(a){this.curves=[],this.curves.length=6*(a-1)},f.Curves.prototype={setLinear:function(a){this.curves[6*a]=0},setStepped:function(a){this.curves[6*a]=-1},setCurve:function(a,b,c,d,e){var f=.1,g=f*f,h=g*f,i=3*f,j=3*g,k=6*g,l=6*h,m=2*-b+d,n=2*-c+e,o=3*(b-d)+1,p=3*(c-e)+1,q=6*a,r=this.curves;r[q]=b*i+m*j+o*h,r[q+1]=c*i+n*j+p*h,r[q+2]=m*k+o*l,r[q+3]=n*k+p*l,r[q+4]=o*l,r[q+5]=p*l},getCurvePercent:function(a,b){b=0>b?0:b>1?1:b;var c=6*a,d=this.curves,e=d[c];if(!e)return b;if(-1==e)return 0;for(var f=d[c+1],g=d[c+2],h=d[c+3],i=d[c+4],j=d[c+5],k=e,l=f,m=8;;){if(k>=b){var n=k-e,o=l-f;return o+(l-o)*(b-n)/(k-n)}if(!m)break;m--,e+=g,f+=h,g+=i,h+=j,k+=e,l+=f}return l+(1-l)*(b-k)/(1-k)}},f.RotateTimeline=function(a){this.curves=new f.Curves(a),this.frames=[],this.frames.length=2*a},f.RotateTimeline.prototype={boneIndex:0,getFrameCount:function(){return this.frames.length/2},setFrame:function(a,b,c){a*=2,this.frames[a]=b,this.frames[a+1]=c},apply:function(a,b,c){var d,e=this.frames;if(!(b<e[0])){var g=a.bones[this.boneIndex];if(b>=e[e.length-2]){for(d=g.data.rotation+e[e.length-1]-g.rotation;d>180;)d-=360;for(;-180>d;)d+=360;return void(g.rotation+=d*c)}var h=f.binarySearch(e,b,2),i=e[h-1],j=e[h],k=1-(b-j)/(e[h-2]-j);for(k=this.curves.getCurvePercent(h/2-1,k),d=e[h+1]-i;d>180;)d-=360;for(;-180>d;)d+=360;for(d=g.data.rotation+(i+d*k)-g.rotation;d>180;)d-=360;for(;-180>d;)d+=360;g.rotation+=d*c}}},f.TranslateTimeline=function(a){this.curves=new f.Curves(a),this.frames=[],this.frames.length=3*a},f.TranslateTimeline.prototype={boneIndex:0,getFrameCount:function(){return this.frames.length/3},setFrame:function(a,b,c,d){a*=3,this.frames[a]=b,this.frames[a+1]=c,this.frames[a+2]=d},apply:function(a,b,c){var d=this.frames;if(!(b<d[0])){var e=a.bones[this.boneIndex];if(b>=d[d.length-3])return e.x+=(e.data.x+d[d.length-2]-e.x)*c,void(e.y+=(e.data.y+d[d.length-1]-e.y)*c);var g=f.binarySearch(d,b,3),h=d[g-2],i=d[g-1],j=d[g],k=1-(b-j)/(d[g+-3]-j);k=this.curves.getCurvePercent(g/3-1,k),e.x+=(e.data.x+h+(d[g+1]-h)*k-e.x)*c,e.y+=(e.data.y+i+(d[g+2]-i)*k-e.y)*c}}},f.ScaleTimeline=function(a){this.curves=new f.Curves(a),this.frames=[],this.frames.length=3*a},f.ScaleTimeline.prototype={boneIndex:0,getFrameCount:function(){return this.frames.length/3},setFrame:function(a,b,c,d){a*=3,this.frames[a]=b,this.frames[a+1]=c,this.frames[a+2]=d},apply:function(a,b,c){var d=this.frames;if(!(b<d[0])){var e=a.bones[this.boneIndex];if(b>=d[d.length-3])return e.scaleX+=(e.data.scaleX-1+d[d.length-2]-e.scaleX)*c,void(e.scaleY+=(e.data.scaleY-1+d[d.length-1]-e.scaleY)*c);var g=f.binarySearch(d,b,3),h=d[g-2],i=d[g-1],j=d[g],k=1-(b-j)/(d[g+-3]-j);k=this.curves.getCurvePercent(g/3-1,k),e.scaleX+=(e.data.scaleX-1+h+(d[g+1]-h)*k-e.scaleX)*c,e.scaleY+=(e.data.scaleY-1+i+(d[g+2]-i)*k-e.scaleY)*c}}},f.ColorTimeline=function(a){this.curves=new f.Curves(a),this.frames=[],this.frames.length=5*a},f.ColorTimeline.prototype={slotIndex:0,getFrameCount:function(){return this.frames.length/5},setFrame:function(a,b,c,d,e,f){a*=5,this.frames[a]=b,this.frames[a+1]=c,this.frames[a+2]=d,this.frames[a+3]=e,this.frames[a+4]=f},apply:function(a,b,c){var d=this.frames;if(!(b<d[0])){var e=a.slots[this.slotIndex];if(b>=d[d.length-5]){var g=d.length-1;return e.r=d[g-3],e.g=d[g-2],e.b=d[g-1],void(e.a=d[g])}var h=f.binarySearch(d,b,5),i=d[h-4],j=d[h-3],k=d[h-2],l=d[h-1],m=d[h],n=1-(b-m)/(d[h-5]-m);n=this.curves.getCurvePercent(h/5-1,n);var o=i+(d[h+1]-i)*n,p=j+(d[h+2]-j)*n,q=k+(d[h+3]-k)*n,r=l+(d[h+4]-l)*n;1>c?(e.r+=(o-e.r)*c,e.g+=(p-e.g)*c,e.b+=(q-e.b)*c,e.a+=(r-e.a)*c):(e.r=o,e.g=p,e.b=q,e.a=r)}}},f.AttachmentTimeline=function(a){this.curves=new f.Curves(a),this.frames=[],this.frames.length=a,this.attachmentNames=[],this.attachmentNames.length=a},f.AttachmentTimeline.prototype={slotIndex:0,getFrameCount:function(){return this.frames.length},setFrame:function(a,b,c){this.frames[a]=b,this.attachmentNames[a]=c},apply:function(a,b){var c=this.frames;if(!(b<c[0])){var d;d=b>=c[c.length-1]?c.length-1:f.binarySearch(c,b,1)-1;var e=this.attachmentNames[d];a.slots[this.slotIndex].setAttachment(e?a.getAttachmentBySlotIndex(this.slotIndex,e):null)}}},f.SkeletonData=function(){this.bones=[],this.slots=[],this.skins=[],this.animations=[]},f.SkeletonData.prototype={defaultSkin:null,findBone:function(a){for(var b=this.bones,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},findBoneIndex:function(a){for(var b=this.bones,c=0,d=b.length;d>c;c++)if(b[c].name==a)return c;return-1},findSlot:function(a){for(var b=this.slots,c=0,d=b.length;d>c;c++)if(b[c].name==a)return slot[c];return null},findSlotIndex:function(a){for(var b=this.slots,c=0,d=b.length;d>c;c++)if(b[c].name==a)return c;return-1},findSkin:function(a){for(var b=this.skins,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},findAnimation:function(a){for(var b=this.animations,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null}},f.Skeleton=function(a){this.data=a,this.bones=[];
for(var b=0,c=a.bones.length;c>b;b++){var d=a.bones[b],e=d.parent?this.bones[a.bones.indexOf(d.parent)]:null;this.bones.push(new f.Bone(d,e))}for(this.slots=[],this.drawOrder=[],b=0,c=a.slots.length;c>b;b++){var g=a.slots[b],h=this.bones[a.bones.indexOf(g.boneData)],i=new f.Slot(g,this,h);this.slots.push(i),this.drawOrder.push(i)}},f.Skeleton.prototype={x:0,y:0,skin:null,r:1,g:1,b:1,a:1,time:0,flipX:!1,flipY:!1,updateWorldTransform:function(){for(var a=this.flipX,b=this.flipY,c=this.bones,d=0,e=c.length;e>d;d++)c[d].updateWorldTransform(a,b)},setToSetupPose:function(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()},setBonesToSetupPose:function(){for(var a=this.bones,b=0,c=a.length;c>b;b++)a[b].setToSetupPose()},setSlotsToSetupPose:function(){for(var a=this.slots,b=0,c=a.length;c>b;b++)a[b].setToSetupPose(b)},getRootBone:function(){return this.bones.length?this.bones[0]:null},findBone:function(a){for(var b=this.bones,c=0,d=b.length;d>c;c++)if(b[c].data.name==a)return b[c];return null},findBoneIndex:function(a){for(var b=this.bones,c=0,d=b.length;d>c;c++)if(b[c].data.name==a)return c;return-1},findSlot:function(a){for(var b=this.slots,c=0,d=b.length;d>c;c++)if(b[c].data.name==a)return b[c];return null},findSlotIndex:function(a){for(var b=this.slots,c=0,d=b.length;d>c;c++)if(b[c].data.name==a)return c;return-1},setSkinByName:function(a){var b=this.data.findSkin(a);if(!b)throw"Skin not found: "+a;this.setSkin(b)},setSkin:function(a){this.skin&&a&&a._attachAll(this,this.skin),this.skin=a},getAttachmentBySlotName:function(a,b){return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a),b)},getAttachmentBySlotIndex:function(a,b){if(this.skin){var c=this.skin.getAttachment(a,b);if(c)return c}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(a,b):null},setAttachment:function(a,b){for(var c=this.slots,d=0,e=c.size;e>d;d++){var f=c[d];if(f.data.name==a){var g=null;if(b&&(g=this.getAttachment(d,b),null==g))throw"Attachment not found: "+b+", for slot: "+a;return void f.setAttachment(g)}}throw"Slot not found: "+a},update:function(a){time+=a}},f.AttachmentType={region:0},f.RegionAttachment=function(){this.offset=[],this.offset.length=8,this.uvs=[],this.uvs.length=8},f.RegionAttachment.prototype={x:0,y:0,rotation:0,scaleX:1,scaleY:1,width:0,height:0,rendererObject:null,regionOffsetX:0,regionOffsetY:0,regionWidth:0,regionHeight:0,regionOriginalWidth:0,regionOriginalHeight:0,setUVs:function(a,b,c,d,e){var f=this.uvs;e?(f[2]=a,f[3]=d,f[4]=a,f[5]=b,f[6]=c,f[7]=b,f[0]=c,f[1]=d):(f[0]=a,f[1]=d,f[2]=a,f[3]=b,f[4]=c,f[5]=b,f[6]=c,f[7]=d)},updateOffset:function(){var a=this.width/this.regionOriginalWidth*this.scaleX,b=this.height/this.regionOriginalHeight*this.scaleY,c=-this.width/2*this.scaleX+this.regionOffsetX*a,d=-this.height/2*this.scaleY+this.regionOffsetY*b,e=c+this.regionWidth*a,f=d+this.regionHeight*b,g=this.rotation*Math.PI/180,h=Math.cos(g),i=Math.sin(g),j=c*h+this.x,k=c*i,l=d*h+this.y,m=d*i,n=e*h+this.x,o=e*i,p=f*h+this.y,q=f*i,r=this.offset;r[0]=j-m,r[1]=l+k,r[2]=j-q,r[3]=p+k,r[4]=n-q,r[5]=p+o,r[6]=n-m,r[7]=l+o},computeVertices:function(a,b,c,d){a+=c.worldX,b+=c.worldY;var e=c.m00,f=c.m01,g=c.m10,h=c.m11,i=this.offset;d[0]=i[0]*e+i[1]*f+a,d[1]=i[0]*g+i[1]*h+b,d[2]=i[2]*e+i[3]*f+a,d[3]=i[2]*g+i[3]*h+b,d[4]=i[4]*e+i[5]*f+a,d[5]=i[4]*g+i[5]*h+b,d[6]=i[6]*e+i[7]*f+a,d[7]=i[6]*g+i[7]*h+b}},f.AnimationStateData=function(a){this.skeletonData=a,this.animationToMixTime={}},f.AnimationStateData.prototype={defaultMix:0,setMixByName:function(a,b,c){var d=this.skeletonData.findAnimation(a);if(!d)throw"Animation not found: "+a;var e=this.skeletonData.findAnimation(b);if(!e)throw"Animation not found: "+b;this.setMix(d,e,c)},setMix:function(a,b,c){this.animationToMixTime[a.name+":"+b.name]=c},getMix:function(a,b){var c=this.animationToMixTime[a.name+":"+b.name];return c?c:this.defaultMix}},f.AnimationState=function(a){this.data=a,this.queue=[]},f.AnimationState.prototype={animationSpeed:1,current:null,previous:null,currentTime:0,previousTime:0,currentLoop:!1,previousLoop:!1,mixTime:0,mixDuration:0,update:function(a){if(this.currentTime+=a*this.animationSpeed,this.previousTime+=a,this.mixTime+=a,this.queue.length>0){var b=this.queue[0];this.currentTime>=b.delay&&(this._setAnimation(b.animation,b.loop),this.queue.shift())}},apply:function(a){if(this.current)if(this.previous){this.previous.apply(a,this.previousTime,this.previousLoop);var b=this.mixTime/this.mixDuration;b>=1&&(b=1,this.previous=null),this.current.mix(a,this.currentTime,this.currentLoop,b)}else this.current.apply(a,this.currentTime,this.currentLoop)},clearAnimation:function(){this.previous=null,this.current=null,this.queue.length=0},_setAnimation:function(a,b){this.previous=null,a&&this.current&&(this.mixDuration=this.data.getMix(this.current,a),this.mixDuration>0&&(this.mixTime=0,this.previous=this.current,this.previousTime=this.currentTime,this.previousLoop=this.currentLoop)),this.current=a,this.currentLoop=b,this.currentTime=0},setAnimationByName:function(a,b){var c=this.data.skeletonData.findAnimation(a);if(!c)throw"Animation not found: "+a;this.setAnimation(c,b)},setAnimation:function(a,b){this.queue.length=0,this._setAnimation(a,b)},addAnimationByName:function(a,b,c){var d=this.data.skeletonData.findAnimation(a);if(!d)throw"Animation not found: "+a;this.addAnimation(d,b,c)},addAnimation:function(a,b,c){var d={};if(d.animation=a,d.loop=b,!c||0>=c){var e=this.queue.length?this.queue[this.queue.length-1].animation:this.current;c=null!=e?e.duration-this.data.getMix(e,a)+(c||0):0}d.delay=c,this.queue.push(d)},isComplete:function(){return!this.current||this.currentTime>=this.current.duration}},f.SkeletonJson=function(a){this.attachmentLoader=a},f.SkeletonJson.prototype={scale:1,readSkeletonData:function(a){for(var b,c=new f.SkeletonData,d=a.bones,e=0,g=d.length;g>e;e++){var h=d[e],i=null;if(h.parent&&(i=c.findBone(h.parent),!i))throw"Parent bone not found: "+h.parent;b=new f.BoneData(h.name,i),b.length=(h.length||0)*this.scale,b.x=(h.x||0)*this.scale,b.y=(h.y||0)*this.scale,b.rotation=h.rotation||0,b.scaleX=h.scaleX||1,b.scaleY=h.scaleY||1,c.bones.push(b)}var j=a.slots;for(e=0,g=j.length;g>e;e++){var k=j[e];if(b=c.findBone(k.bone),!b)throw"Slot bone not found: "+k.bone;var l=new f.SlotData(k.name,b),m=k.color;m&&(l.r=f.SkeletonJson.toColor(m,0),l.g=f.SkeletonJson.toColor(m,1),l.b=f.SkeletonJson.toColor(m,2),l.a=f.SkeletonJson.toColor(m,3)),l.attachmentName=k.attachment,c.slots.push(l)}var n=a.skins;for(var o in n)if(n.hasOwnProperty(o)){var p=n[o],q=new f.Skin(o);for(var r in p)if(p.hasOwnProperty(r)){var s=c.findSlotIndex(r),t=p[r];for(var u in t)if(t.hasOwnProperty(u)){var v=this.readAttachment(q,u,t[u]);null!=v&&q.addAttachment(s,u,v)}}c.skins.push(q),"default"==q.name&&(c.defaultSkin=q)}var w=a.animations;for(var x in w)w.hasOwnProperty(x)&&this.readAnimation(x,w[x],c);return c},readAttachment:function(a,b,c){b=c.name||b;var d=f.AttachmentType[c.type||"region"];if(d==f.AttachmentType.region){var e=new f.RegionAttachment;return e.x=(c.x||0)*this.scale,e.y=(c.y||0)*this.scale,e.scaleX=c.scaleX||1,e.scaleY=c.scaleY||1,e.rotation=c.rotation||0,e.width=(c.width||32)*this.scale,e.height=(c.height||32)*this.scale,e.updateOffset(),e.rendererObject={},e.rendererObject.name=b,e.rendererObject.scale={},e.rendererObject.scale.x=e.scaleX,e.rendererObject.scale.y=e.scaleY,e.rendererObject.rotation=-e.rotation*Math.PI/180,e}throw"Unknown attachment type: "+d},readAnimation:function(a,b,c){var d,e,g,h,i,j,k,l=[],m=0,n=b.bones;for(var o in n)if(n.hasOwnProperty(o)){var p=c.findBoneIndex(o);if(-1==p)throw"Bone not found: "+o;var q=n[o];for(g in q)if(q.hasOwnProperty(g))if(i=q[g],"rotate"==g){for(e=new f.RotateTimeline(i.length),e.boneIndex=p,d=0,j=0,k=i.length;k>j;j++)h=i[j],e.setFrame(d,h.time,h.angle),f.SkeletonJson.readCurve(e,d,h),d++;l.push(e),m=Math.max(m,e.frames[2*e.getFrameCount()-2])}else{if("translate"!=g&&"scale"!=g)throw"Invalid timeline type for a bone: "+g+" ("+o+")";var r=1;for("scale"==g?e=new f.ScaleTimeline(i.length):(e=new f.TranslateTimeline(i.length),r=this.scale),e.boneIndex=p,d=0,j=0,k=i.length;k>j;j++){h=i[j];var s=(h.x||0)*r,t=(h.y||0)*r;e.setFrame(d,h.time,s,t),f.SkeletonJson.readCurve(e,d,h),d++}l.push(e),m=Math.max(m,e.frames[3*e.getFrameCount()-3])}}var u=b.slots;for(var v in u)if(u.hasOwnProperty(v)){var w=u[v],x=c.findSlotIndex(v);for(g in w)if(w.hasOwnProperty(g))if(i=w[g],"color"==g){for(e=new f.ColorTimeline(i.length),e.slotIndex=x,d=0,j=0,k=i.length;k>j;j++){h=i[j];var y=h.color,z=f.SkeletonJson.toColor(y,0),A=f.SkeletonJson.toColor(y,1),B=f.SkeletonJson.toColor(y,2),C=f.SkeletonJson.toColor(y,3);e.setFrame(d,h.time,z,A,B,C),f.SkeletonJson.readCurve(e,d,h),d++}l.push(e),m=Math.max(m,e.frames[5*e.getFrameCount()-5])}else{if("attachment"!=g)throw"Invalid timeline type for a slot: "+g+" ("+v+")";for(e=new f.AttachmentTimeline(i.length),e.slotIndex=x,d=0,j=0,k=i.length;k>j;j++)h=i[j],e.setFrame(d++,h.time,h.name);l.push(e),m=Math.max(m,e.frames[e.getFrameCount()-1])}}c.animations.push(new f.Animation(a,l,m))}},f.SkeletonJson.readCurve=function(a,b,c){var d=c.curve;d&&("stepped"==d?a.curves.setStepped(b):d instanceof Array&&a.curves.setCurve(b,d[0],d[1],d[2],d[3]))},f.SkeletonJson.toColor=function(a,b){if(8!=a.length)throw"Color hexidecimal length must be 8, recieved: "+a;return parseInt(a.substr(2*b,2),16)/255},f.Atlas=function(a,b){this.textureLoader=b,this.pages=[],this.regions=[];var c=new f.AtlasReader(a),d=[];d.length=4;for(var e=null;;){var g=c.readLine();if(null==g)break;if(g=c.trim(g),g.length)if(e){var h=new f.AtlasRegion;h.name=g,h.page=e,h.rotate="true"==c.readValue(),c.readTuple(d);var i=parseInt(d[0],10),j=parseInt(d[1],10);c.readTuple(d);var k=parseInt(d[0],10),l=parseInt(d[1],10);h.u=i/e.width,h.v=j/e.height,h.rotate?(h.u2=(i+l)/e.width,h.v2=(j+k)/e.height):(h.u2=(i+k)/e.width,h.v2=(j+l)/e.height),h.x=i,h.y=j,h.width=Math.abs(k),h.height=Math.abs(l),4==c.readTuple(d)&&(h.splits=[parseInt(d[0],10),parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10)],4==c.readTuple(d)&&(h.pads=[parseInt(d[0],10),parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10)],c.readTuple(d))),h.originalWidth=parseInt(d[0],10),h.originalHeight=parseInt(d[1],10),c.readTuple(d),h.offsetX=parseInt(d[0],10),h.offsetY=parseInt(d[1],10),h.index=parseInt(c.readValue(),10),this.regions.push(h)}else{e=new f.AtlasPage,e.name=g,e.format=f.Atlas.Format[c.readValue()],c.readTuple(d),e.minFilter=f.Atlas.TextureFilter[d[0]],e.magFilter=f.Atlas.TextureFilter[d[1]];var m=c.readValue();e.uWrap=f.Atlas.TextureWrap.clampToEdge,e.vWrap=f.Atlas.TextureWrap.clampToEdge,"x"==m?e.uWrap=f.Atlas.TextureWrap.repeat:"y"==m?e.vWrap=f.Atlas.TextureWrap.repeat:"xy"==m&&(e.uWrap=e.vWrap=f.Atlas.TextureWrap.repeat),b.load(e,g),this.pages.push(e)}else e=null}},f.Atlas.prototype={findRegion:function(a){for(var b=this.regions,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},dispose:function(){for(var a=this.pages,b=0,c=a.length;c>b;b++)this.textureLoader.unload(a[b].rendererObject)},updateUVs:function(a){for(var b=this.regions,c=0,d=b.length;d>c;c++){var e=b[c];e.page==a&&(e.u=e.x/a.width,e.v=e.y/a.height,e.rotate?(e.u2=(e.x+e.height)/a.width,e.v2=(e.y+e.width)/a.height):(e.u2=(e.x+e.width)/a.width,e.v2=(e.y+e.height)/a.height))}}},f.Atlas.Format={alpha:0,intensity:1,luminanceAlpha:2,rgb565:3,rgba4444:4,rgb888:5,rgba8888:6},f.Atlas.TextureFilter={nearest:0,linear:1,mipMap:2,mipMapNearestNearest:3,mipMapLinearNearest:4,mipMapNearestLinear:5,mipMapLinearLinear:6},f.Atlas.TextureWrap={mirroredRepeat:0,clampToEdge:1,repeat:2},f.AtlasPage=function(){},f.AtlasPage.prototype={name:null,format:null,minFilter:null,magFilter:null,uWrap:null,vWrap:null,rendererObject:null,width:0,height:0},f.AtlasRegion=function(){},f.AtlasRegion.prototype={page:null,name:null,x:0,y:0,width:0,height:0,u:0,v:0,u2:0,v2:0,offsetX:0,offsetY:0,originalWidth:0,originalHeight:0,index:0,rotate:!1,splits:null,pads:null},f.AtlasReader=function(a){this.lines=a.split(/\r\n|\r|\n/)},f.AtlasReader.prototype={index:0,trim:function(a){return a.replace(/^\s+|\s+$/g,"")},readLine:function(){return this.index>=this.lines.length?null:this.lines[this.index++]},readValue:function(){var a=this.readLine(),b=a.indexOf(":");if(-1==b)throw"Invalid line: "+a;return this.trim(a.substring(b+1))},readTuple:function(a){var b=this.readLine(),c=b.indexOf(":");if(-1==c)throw"Invalid line: "+b;for(var d=0,e=c+1;3>d;d++){var f=b.indexOf(",",e);if(-1==f){if(!d)throw"Invalid line: "+b;break}a[d]=this.trim(b.substr(e,f-e)),e=f+1}return a[d]=this.trim(b.substring(e)),d+1}},f.AtlasAttachmentLoader=function(a){this.atlas=a},f.AtlasAttachmentLoader.prototype={newAttachment:function(a,b,c){switch(b){case f.AttachmentType.region:var d=this.atlas.findRegion(c);if(!d)throw"Region not found in atlas: "+c+" ("+b+")";var e=new f.RegionAttachment(c);return e.rendererObject=d,e.setUVs(d.u,d.v,d.u2,d.v2,d.rotate),e.regionOffsetX=d.offsetX,e.regionOffsetY=d.offsetY,e.regionWidth=d.width,e.regionHeight=d.height,e.regionOriginalWidth=d.originalWidth,e.regionOriginalHeight=d.originalHeight,e}throw"Unknown attachment type: "+b}},f.Bone.yDown=!0,b.AnimCache={},b.Spine=function(a){if(b.DisplayObjectContainer.call(this),this.spineData=b.AnimCache[a],!this.spineData)throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: "+a);this.skeleton=new f.Skeleton(this.spineData),this.skeleton.updateWorldTransform(),this.stateData=new f.AnimationStateData(this.spineData),this.state=new f.AnimationState(this.stateData),this.slotContainers=[];for(var c=0,d=this.skeleton.drawOrder.length;d>c;c++){var e=this.skeleton.drawOrder[c],g=e.attachment,h=new b.DisplayObjectContainer;if(this.slotContainers.push(h),this.addChild(h),g instanceof f.RegionAttachment){var i=g.rendererObject.name,j=this.createSprite(e,g.rendererObject);e.currentSprite=j,e.currentSpriteName=i,h.addChild(j)}}},b.Spine.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Spine.prototype.constructor=b.Spine,b.Spine.prototype.updateTransform=function(){this.lastTime=this.lastTime||Date.now();var a=.001*(Date.now()-this.lastTime);this.lastTime=Date.now(),this.state.update(a),this.state.apply(this.skeleton),this.skeleton.updateWorldTransform();for(var c=this.skeleton.drawOrder,d=0,e=c.length;e>d;d++){var g=c[d],h=g.attachment,i=this.slotContainers[d];if(h instanceof f.RegionAttachment){if(h.rendererObject&&(!g.currentSpriteName||g.currentSpriteName!=h.name)){var j=h.rendererObject.name;if(void 0!==g.currentSprite&&(g.currentSprite.visible=!1),g.sprites=g.sprites||{},void 0!==g.sprites[j])g.sprites[j].visible=!0;else{var k=this.createSprite(g,h.rendererObject);i.addChild(k)}g.currentSprite=g.sprites[j],g.currentSpriteName=j}i.visible=!0;var l=g.bone;i.position.x=l.worldX+h.x*l.m00+h.y*l.m01,i.position.y=l.worldY+h.x*l.m10+h.y*l.m11,i.scale.x=l.worldScaleX,i.scale.y=l.worldScaleY,i.rotation=-(g.bone.worldRotation*Math.PI/180),i.alpha=g.a,g.currentSprite.tint=b.rgb2hex([g.r,g.g,g.b])}else i.visible=!1}b.DisplayObjectContainer.prototype.updateTransform.call(this)},b.Spine.prototype.createSprite=function(a,c){var d=b.TextureCache[c.name]?c.name:c.name+".png",e=new b.Sprite(b.Texture.fromFrame(d));return e.scale=c.scale,e.rotation=c.rotation,e.anchor.x=e.anchor.y=.5,a.sprites=a.sprites||{},a.sprites[c.name]=e,e},b.BaseTextureCache={},b.texturesToUpdate=[],b.texturesToDestroy=[],b.BaseTextureCacheIdGenerator=0,b.BaseTexture=function(a,c){if(b.EventTarget.call(this),this.width=100,this.height=100,this.scaleMode=c||b.scaleModes.DEFAULT,this.hasLoaded=!1,this.source=a,this.id=b.BaseTextureCacheIdGenerator++,this.premultipliedAlpha=!0,this._glTextures=[],this._dirty=[],a){if((this.source.complete||this.source.getContext)&&this.source.width&&this.source.height)this.hasLoaded=!0,this.width=this.source.width,this.height=this.source.height,b.texturesToUpdate.push(this);else{var d=this;this.source.onload=function(){d.hasLoaded=!0,d.width=d.source.width,d.height=d.source.height;for(var a=0;a<d._glTextures.length;a++)d._dirty[a]=!0;d.dispatchEvent({type:"loaded",content:d})},this.source.onerror=function(){d.dispatchEvent({type:"error",content:d})}}this.imageUrl=null,this._powerOf2=!1}},b.BaseTexture.prototype.constructor=b.BaseTexture,b.BaseTexture.prototype.destroy=function(){this.imageUrl?(delete b.BaseTextureCache[this.imageUrl],delete b.TextureCache[this.imageUrl],this.imageUrl=null,this.source.src=null):this.source&&this.source._pixiId&&delete b.BaseTextureCache[this.source._pixiId],this.source=null,b.texturesToDestroy.push(this)},b.BaseTexture.prototype.updateSourceImage=function(a){this.hasLoaded=!1,this.source.src=null,this.source.src=a},b.BaseTexture.fromImage=function(a,c,d){var e=b.BaseTextureCache[a];if(void 0===c&&-1===a.indexOf("data:")&&(c=!0),!e){var f=new Image;c&&(f.crossOrigin=""),f.src=a,e=new b.BaseTexture(f,d),e.imageUrl=a,b.BaseTextureCache[a]=e}return e},b.BaseTexture.fromCanvas=function(a,c){a._pixiId||(a._pixiId="canvas_"+b.TextureCacheIdGenerator++);var d=b.BaseTextureCache[a._pixiId];return d||(d=new b.BaseTexture(a,c),b.BaseTextureCache[a._pixiId]=d),d},b.TextureCache={},b.FrameCache={},b.TextureCacheIdGenerator=0,b.Texture=function(a,c){if(b.EventTarget.call(this),this.noFrame=!1,c||(this.noFrame=!0,c=new b.Rectangle(0,0,1,1)),a instanceof b.Texture&&(a=a.baseTexture),this.baseTexture=a,this.frame=c,this.trim=null,this.valid=!1,this.scope=this,this._uvs=null,this.width=0,this.height=0,this.crop=new b.Rectangle(0,0,1,1),a.hasLoaded)this.noFrame&&(c=new b.Rectangle(0,0,a.width,a.height)),this.setFrame(c);else{var d=this;a.addEventListener("loaded",function(){d.onBaseTextureLoaded()})}},b.Texture.prototype.constructor=b.Texture,b.Texture.prototype.onBaseTextureLoaded=function(){var a=this.baseTexture;a.removeEventListener("loaded",this.onLoaded),this.noFrame&&(this.frame=new b.Rectangle(0,0,a.width,a.height)),this.setFrame(this.frame),this.scope.dispatchEvent({type:"update",content:this})},b.Texture.prototype.destroy=function(a){a&&this.baseTexture.destroy(),this.valid=!1},b.Texture.prototype.setFrame=function(a){if(this.noFrame=!1,this.frame=a,this.width=a.width,this.height=a.height,this.crop.x=a.x,this.crop.y=a.y,this.crop.width=a.width,this.crop.height=a.height,!this.trim&&(a.x+a.width>this.baseTexture.width||a.y+a.height>this.baseTexture.height))throw new Error("Texture Error: frame does not fit inside the base Texture dimensions "+this);this.valid=a&&a.width&&a.height&&this.baseTexture.source&&this.baseTexture.hasLoaded,this.trim&&(this.width=this.trim.width,this.height=this.trim.height,this.frame.width=this.trim.width,this.frame.height=this.trim.height),this.valid&&b.Texture.frameUpdates.push(this)},b.Texture.prototype._updateWebGLuvs=function(){this._uvs||(this._uvs=new b.TextureUvs);var a=this.crop,c=this.baseTexture.width,d=this.baseTexture.height;this._uvs.x0=a.x/c,this._uvs.y0=a.y/d,this._uvs.x1=(a.x+a.width)/c,this._uvs.y1=a.y/d,this._uvs.x2=(a.x+a.width)/c,this._uvs.y2=(a.y+a.height)/d,this._uvs.x3=a.x/c,this._uvs.y3=(a.y+a.height)/d},b.Texture.fromImage=function(a,c,d){var e=b.TextureCache[a];return e||(e=new b.Texture(b.BaseTexture.fromImage(a,c,d)),b.TextureCache[a]=e),e},b.Texture.fromFrame=function(a){var c=b.TextureCache[a];if(!c)throw new Error('The frameId "'+a+'" does not exist in the texture cache ');return c},b.Texture.fromCanvas=function(a,c){var d=b.BaseTexture.fromCanvas(a,c);return new b.Texture(d)},b.Texture.addTextureToCache=function(a,c){b.TextureCache[c]=a},b.Texture.removeTextureFromCache=function(a){var c=b.TextureCache[a];return delete b.TextureCache[a],delete b.BaseTextureCache[a],c},b.Texture.frameUpdates=[],b.TextureUvs=function(){this.x0=0,this.y0=0,this.x1=0,this.y1=0,this.x2=0,this.y2=0,this.x3=0,this.y3=0},b.RenderTexture=function(a,c,d,e){if(b.EventTarget.call(this),this.width=a||100,this.height=c||100,this.frame=new b.Rectangle(0,0,this.width,this.height),this.crop=new b.Rectangle(0,0,this.width,this.height),this.baseTexture=new b.BaseTexture,this.baseTexture.width=this.width,this.baseTexture.height=this.height,this.baseTexture._glTextures=[],this.baseTexture.scaleMode=e||b.scaleModes.DEFAULT,this.baseTexture.hasLoaded=!0,this.renderer=d||b.defaultRenderer,this.renderer.type===b.WEBGL_RENDERER){var f=this.renderer.gl;this.textureBuffer=new b.FilterTexture(f,this.width,this.height,this.baseTexture.scaleMode),this.baseTexture._glTextures[f.id]=this.textureBuffer.texture,this.render=this.renderWebGL,this.projection=new b.Point(this.width/2,-this.height/2)}else this.render=this.renderCanvas,this.textureBuffer=new b.CanvasBuffer(this.width,this.height),this.baseTexture.source=this.textureBuffer.canvas;this.valid=!0,b.Texture.frameUpdates.push(this)},b.RenderTexture.prototype=Object.create(b.Texture.prototype),b.RenderTexture.prototype.constructor=b.RenderTexture,b.RenderTexture.prototype.resize=function(a,c,d){(a!==this.width||c!==this.height)&&(this.width=this.frame.width=this.crop.width=a,this.height=this.frame.height=this.crop.height=c,d&&(this.baseTexture.width=this.width,this.baseTexture.height=this.height),this.renderer.type===b.WEBGL_RENDERER&&(this.projection.x=this.width/2,this.projection.y=-this.height/2),this.textureBuffer.resize(this.width,this.height))},b.RenderTexture.prototype.clear=function(){this.renderer.type===b.WEBGL_RENDERER&&this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER,this.textureBuffer.frameBuffer),this.textureBuffer.clear()},b.RenderTexture.prototype.renderWebGL=function(a,c,d){var e=this.renderer.gl;e.colorMask(!0,!0,!0,!0),e.viewport(0,0,this.width,this.height),e.bindFramebuffer(e.FRAMEBUFFER,this.textureBuffer.frameBuffer),d&&this.textureBuffer.clear();var f=a.children,g=a.worldTransform;a.worldTransform=b.RenderTexture.tempMatrix,a.worldTransform.d=-1,a.worldTransform.ty=-2*this.projection.y,c&&(a.worldTransform.tx=c.x,a.worldTransform.ty-=c.y);for(var h=0,i=f.length;i>h;h++)f[h].updateTransform();b.WebGLRenderer.updateTextures(),this.renderer.spriteBatch.dirty=!0,this.renderer.renderDisplayObject(a,this.projection,this.textureBuffer.frameBuffer),a.worldTransform=g,this.renderer.spriteBatch.dirty=!0},b.RenderTexture.prototype.renderCanvas=function(a,c,d){var e=a.children,f=a.worldTransform;a.worldTransform=b.RenderTexture.tempMatrix,c?(a.worldTransform.tx=c.x,a.worldTransform.ty=c.y):(a.worldTransform.tx=0,a.worldTransform.ty=0);for(var g=0,h=e.length;h>g;g++)e[g].updateTransform();d&&this.textureBuffer.clear();var i=this.textureBuffer.context;this.renderer.renderDisplayObject(a,i),i.setTransform(1,0,0,1,0,0),a.worldTransform=f},b.RenderTexture.tempMatrix=new b.Matrix,b.AssetLoader=function(a,c){b.EventTarget.call(this),this.assetURLs=a,this.crossorigin=c,this.loadersByType={jpg:b.ImageLoader,jpeg:b.ImageLoader,png:b.ImageLoader,gif:b.ImageLoader,webp:b.ImageLoader,json:b.JsonLoader,atlas:b.AtlasLoader,anim:b.SpineLoader,xml:b.BitmapFontLoader,fnt:b.BitmapFontLoader}},b.AssetLoader.prototype.constructor=b.AssetLoader,b.AssetLoader.prototype._getDataType=function(a){var b="data:",c=a.slice(0,b.length).toLowerCase();if(c===b){var d=a.slice(b.length),e=d.indexOf(",");if(-1===e)return null;var f=d.slice(0,e).split(";")[0];return f&&"text/plain"!==f.toLowerCase()?f.split("/").pop().toLowerCase():"txt"}return null},b.AssetLoader.prototype.load=function(){function a(a){b.onAssetLoaded(a.content)}var b=this;this.loadCount=this.assetURLs.length;for(var c=0;c<this.assetURLs.length;c++){var d=this.assetURLs[c],e=this._getDataType(d);e||(e=d.split("?").shift().split(".").pop().toLowerCase());var f=this.loadersByType[e];if(!f)throw new Error(e+" is an unsupported file type");var g=new f(d,this.crossorigin);g.addEventListener("loaded",a),g.load()}},b.AssetLoader.prototype.onAssetLoaded=function(a){this.loadCount--,this.dispatchEvent({type:"onProgress",content:this,loader:a}),this.onProgress&&this.onProgress(a),this.loadCount||(this.dispatchEvent({type:"onComplete",content:this}),this.onComplete&&this.onComplete())},b.JsonLoader=function(a,c){b.EventTarget.call(this),this.url=a,this.crossorigin=c,this.baseUrl=a.replace(/[^\/]*$/,""),this.loaded=!1},b.JsonLoader.prototype.constructor=b.JsonLoader,b.JsonLoader.prototype.load=function(){var a=this;window.XDomainRequest&&a.crossorigin?(this.ajaxRequest=new window.XDomainRequest,this.ajaxRequest.timeout=3e3,this.ajaxRequest.onerror=function(){a.onError()},this.ajaxRequest.ontimeout=function(){a.onError()},this.ajaxRequest.onprogress=function(){}):this.ajaxRequest=window.XMLHttpRequest?new window.XMLHttpRequest:new window.ActiveXObject("Microsoft.XMLHTTP"),this.ajaxRequest.onload=function(){a.onJSONLoaded()},this.ajaxRequest.open("GET",this.url,!0),this.ajaxRequest.send()},b.JsonLoader.prototype.onJSONLoaded=function(){if(!this.ajaxRequest.responseText||"NOT FOUND"===this.ajaxRequest.responseText)return void this.onError();if(this.json=JSON.parse(this.ajaxRequest.responseText),this.json.frames){var a=this,c=this.baseUrl+this.json.meta.image,d=new b.ImageLoader(c,this.crossorigin),e=this.json.frames;this.texture=d.texture.baseTexture,d.addEventListener("loaded",function(){a.onLoaded()});for(var g in e){var h=e[g].frame;if(h&&(b.TextureCache[g]=new b.Texture(this.texture,{x:h.x,y:h.y,width:h.w,height:h.h}),b.TextureCache[g].crop=new b.Rectangle(h.x,h.y,h.w,h.h),e[g].trimmed)){var i=e[g].sourceSize,j=e[g].spriteSourceSize;b.TextureCache[g].trim=new b.Rectangle(j.x,j.y,i.w,i.h)}}d.load()}else if(this.json.bones){var k=new f.SkeletonJson,l=k.readSkeletonData(this.json);b.AnimCache[this.url]=l,this.onLoaded()}else this.onLoaded()},b.JsonLoader.prototype.onLoaded=function(){this.loaded=!0,this.dispatchEvent({type:"loaded",content:this})},b.JsonLoader.prototype.onError=function(){this.dispatchEvent({type:"error",content:this})},b.AtlasLoader=function(a,c){b.EventTarget.call(this),this.url=a,this.baseUrl=a.replace(/[^\/]*$/,""),this.crossorigin=c,this.loaded=!1},b.AtlasLoader.constructor=b.AtlasLoader,b.AtlasLoader.prototype.load=function(){this.ajaxRequest=new b.AjaxRequest,this.ajaxRequest.onreadystatechange=this.onAtlasLoaded.bind(this),this.ajaxRequest.open("GET",this.url,!0),this.ajaxRequest.overrideMimeType&&this.ajaxRequest.overrideMimeType("application/json"),this.ajaxRequest.send(null)},b.AtlasLoader.prototype.onAtlasLoaded=function(){if(4===this.ajaxRequest.readyState)if(200===this.ajaxRequest.status||-1===window.location.href.indexOf("http")){this.atlas={meta:{image:[]},frames:[]};var a=this.ajaxRequest.responseText.split(/\r?\n/),c=-3,d=0,e=null,f=!1,g=0,h=0,i=this.onLoaded.bind(this);for(g=0;g<a.length;g++)if(a[g]=a[g].replace(/^\s+|\s+$/g,""),""===a[g]&&(f=g+1),a[g].length>0){if(f===g)this.atlas.meta.image.push(a[g]),d=this.atlas.meta.image.length-1,this.atlas.frames.push({}),c=-3;else if(c>0)if(c%7===1)null!=e&&(this.atlas.frames[d][e.name]=e),e={name:a[g],frame:{}};else{var j=a[g].split(" ");if(c%7===3)e.frame.x=Number(j[1].replace(",","")),e.frame.y=Number(j[2]);else if(c%7===4)e.frame.w=Number(j[1].replace(",","")),e.frame.h=Number(j[2]);else if(c%7===5){var k={x:0,y:0,w:Number(j[1].replace(",","")),h:Number(j[2])};k.w>e.frame.w||k.h>e.frame.h?(e.trimmed=!0,e.realSize=k):e.trimmed=!1}}c++}if(null!=e&&(this.atlas.frames[d][e.name]=e),this.atlas.meta.image.length>0){for(this.images=[],h=0;h<this.atlas.meta.image.length;h++){var l=this.baseUrl+this.atlas.meta.image[h],m=this.atlas.frames[h];this.images.push(new b.ImageLoader(l,this.crossorigin));for(g in m){var n=m[g].frame;n&&(b.TextureCache[g]=new b.Texture(this.images[h].texture.baseTexture,{x:n.x,y:n.y,width:n.w,height:n.h}),m[g].trimmed&&(b.TextureCache[g].realSize=m[g].realSize,b.TextureCache[g].trim.x=0,b.TextureCache[g].trim.y=0))}}for(this.currentImageId=0,h=0;h<this.images.length;h++)this.images[h].addEventListener("loaded",i);this.images[this.currentImageId].load()}else this.onLoaded()}else this.onError()},b.AtlasLoader.prototype.onLoaded=function(){this.images.length-1>this.currentImageId?(this.currentImageId++,this.images[this.currentImageId].load()):(this.loaded=!0,this.dispatchEvent({type:"loaded",content:this}))},b.AtlasLoader.prototype.onError=function(){this.dispatchEvent({type:"error",content:this})},b.SpriteSheetLoader=function(a,c){b.EventTarget.call(this),this.url=a,this.crossorigin=c,this.baseUrl=a.replace(/[^\/]*$/,""),this.texture=null,this.frames={}},b.SpriteSheetLoader.prototype.constructor=b.SpriteSheetLoader,b.SpriteSheetLoader.prototype.load=function(){var a=this,c=new b.JsonLoader(this.url,this.crossorigin);c.addEventListener("loaded",function(b){a.json=b.content.json,a.onLoaded()}),c.load()},b.SpriteSheetLoader.prototype.onLoaded=function(){this.dispatchEvent({type:"loaded",content:this})},b.ImageLoader=function(a,c){b.EventTarget.call(this),this.texture=b.Texture.fromImage(a,c),this.frames=[]},b.ImageLoader.prototype.constructor=b.ImageLoader,b.ImageLoader.prototype.load=function(){if(this.texture.baseTexture.hasLoaded)this.onLoaded();else{var a=this;this.texture.baseTexture.addEventListener("loaded",function(){a.onLoaded()})}},b.ImageLoader.prototype.onLoaded=function(){this.dispatchEvent({type:"loaded",content:this})},b.ImageLoader.prototype.loadFramedSpriteSheet=function(a,c,d){this.frames=[];for(var e=Math.floor(this.texture.width/a),f=Math.floor(this.texture.height/c),g=0,h=0;f>h;h++)for(var i=0;e>i;i++,g++){var j=new b.Texture(this.texture,{x:i*a,y:h*c,width:a,height:c});this.frames.push(j),d&&(b.TextureCache[d+"-"+g]=j)}if(this.texture.baseTexture.hasLoaded)this.onLoaded();else{var k=this;this.texture.baseTexture.addEventListener("loaded",function(){k.onLoaded()})}},b.BitmapFontLoader=function(a,c){b.EventTarget.call(this),this.url=a,this.crossorigin=c,this.baseUrl=a.replace(/[^\/]*$/,""),this.texture=null},b.BitmapFontLoader.prototype.constructor=b.BitmapFontLoader,b.BitmapFontLoader.prototype.load=function(){this.ajaxRequest=new b.AjaxRequest;var a=this;this.ajaxRequest.onreadystatechange=function(){a.onXMLLoaded()},this.ajaxRequest.open("GET",this.url,!0),this.ajaxRequest.overrideMimeType&&this.ajaxRequest.overrideMimeType("application/xml"),this.ajaxRequest.send(null)},b.BitmapFontLoader.prototype.onXMLLoaded=function(){if(4===this.ajaxRequest.readyState&&(200===this.ajaxRequest.status||-1===window.location.protocol.indexOf("http"))){var a=this.ajaxRequest.responseXML;if(!a||/MSIE 9/i.test(navigator.userAgent)||navigator.isCocoonJS)if("function"==typeof window.DOMParser){var c=new DOMParser;a=c.parseFromString(this.ajaxRequest.responseText,"text/xml")}else{var d=document.createElement("div");d.innerHTML=this.ajaxRequest.responseText,a=d}var e=this.baseUrl+a.getElementsByTagName("page")[0].getAttribute("file"),f=new b.ImageLoader(e,this.crossorigin);this.texture=f.texture.baseTexture;var g={},h=a.getElementsByTagName("info")[0],i=a.getElementsByTagName("common")[0];g.font=h.getAttribute("face"),g.size=parseInt(h.getAttribute("size"),10),g.lineHeight=parseInt(i.getAttribute("lineHeight"),10),g.chars={};for(var j=a.getElementsByTagName("char"),k=0;k<j.length;k++){var l=parseInt(j[k].getAttribute("id"),10),m=new b.Rectangle(parseInt(j[k].getAttribute("x"),10),parseInt(j[k].getAttribute("y"),10),parseInt(j[k].getAttribute("width"),10),parseInt(j[k].getAttribute("height"),10));g.chars[l]={xOffset:parseInt(j[k].getAttribute("xoffset"),10),yOffset:parseInt(j[k].getAttribute("yoffset"),10),xAdvance:parseInt(j[k].getAttribute("xadvance"),10),kerning:{},texture:b.TextureCache[l]=new b.Texture(this.texture,m)}}var n=a.getElementsByTagName("kerning");for(k=0;k<n.length;k++){var o=parseInt(n[k].getAttribute("first"),10),p=parseInt(n[k].getAttribute("second"),10),q=parseInt(n[k].getAttribute("amount"),10);g.chars[p].kerning[o]=q}b.BitmapText.fonts[g.font]=g;var r=this;f.addEventListener("loaded",function(){r.onLoaded()}),f.load()}},b.BitmapFontLoader.prototype.onLoaded=function(){this.dispatchEvent({type:"loaded",content:this})},b.SpineLoader=function(a,c){b.EventTarget.call(this),this.url=a,this.crossorigin=c,this.loaded=!1},b.SpineLoader.prototype.constructor=b.SpineLoader,b.SpineLoader.prototype.load=function(){var a=this,c=new b.JsonLoader(this.url,this.crossorigin);
c.addEventListener("loaded",function(b){a.json=b.content.json,a.onLoaded()}),c.load()},b.SpineLoader.prototype.onLoaded=function(){this.loaded=!0,this.dispatchEvent({type:"loaded",content:this})},b.AbstractFilter=function(a,b){this.passes=[this],this.shaders=[],this.dirty=!0,this.padding=0,this.uniforms=b||{},this.fragmentSrc=a||[]},b.AlphaMaskFilter=function(a){b.AbstractFilter.call(this),this.passes=[this],a.baseTexture._powerOf2=!0,this.uniforms={mask:{type:"sampler2D",value:a},mapDimensions:{type:"2f",value:{x:1,y:5112}},dimensions:{type:"4fv",value:[0,0,0,0]}},a.baseTexture.hasLoaded?(this.uniforms.mask.value.x=a.width,this.uniforms.mask.value.y=a.height):(this.boundLoadedFunction=this.onTextureLoaded.bind(this),a.baseTexture.on("loaded",this.boundLoadedFunction)),this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform sampler2D mask;","uniform sampler2D uSampler;","uniform vec2 offset;","uniform vec4 dimensions;","uniform vec2 mapDimensions;","void main(void) {","   vec2 mapCords = vTextureCoord.xy;","   mapCords += (dimensions.zw + offset)/ dimensions.xy ;","   mapCords.y *= -1.0;","   mapCords.y += 1.0;","   mapCords *= dimensions.xy / mapDimensions;","   vec4 original =  texture2D(uSampler, vTextureCoord);","   float maskAlpha =  texture2D(mask, mapCords).r;","   original *= maskAlpha;","   gl_FragColor =  original;","}"]},b.AlphaMaskFilter.prototype=Object.create(b.AbstractFilter.prototype),b.AlphaMaskFilter.prototype.constructor=b.AlphaMaskFilter,b.AlphaMaskFilter.prototype.onTextureLoaded=function(){this.uniforms.mapDimensions.value.x=this.uniforms.mask.value.width,this.uniforms.mapDimensions.value.y=this.uniforms.mask.value.height,this.uniforms.mask.value.baseTexture.off("loaded",this.boundLoadedFunction)},Object.defineProperty(b.AlphaMaskFilter.prototype,"map",{get:function(){return this.uniforms.mask.value},set:function(a){this.uniforms.mask.value=a}}),b.ColorMatrixFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={matrix:{type:"mat4",value:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float invert;","uniform mat4 matrix;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;","}"]},b.ColorMatrixFilter.prototype=Object.create(b.AbstractFilter.prototype),b.ColorMatrixFilter.prototype.constructor=b.ColorMatrixFilter,Object.defineProperty(b.ColorMatrixFilter.prototype,"matrix",{get:function(){return this.uniforms.matrix.value},set:function(a){this.uniforms.matrix.value=a}}),b.GrayFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={gray:{type:"1f",value:1}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform sampler2D uSampler;","uniform float gray;","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord);","   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);","}"]},b.GrayFilter.prototype=Object.create(b.AbstractFilter.prototype),b.GrayFilter.prototype.constructor=b.GrayFilter,Object.defineProperty(b.GrayFilter.prototype,"gray",{get:function(){return this.uniforms.gray.value},set:function(a){this.uniforms.gray.value=a}}),b.DisplacementFilter=function(a){b.AbstractFilter.call(this),this.passes=[this],a.baseTexture._powerOf2=!0,this.uniforms={displacementMap:{type:"sampler2D",value:a},scale:{type:"2f",value:{x:30,y:30}},offset:{type:"2f",value:{x:0,y:0}},mapDimensions:{type:"2f",value:{x:1,y:5112}},dimensions:{type:"4fv",value:[0,0,0,0]}},a.baseTexture.hasLoaded?(this.uniforms.mapDimensions.value.x=a.width,this.uniforms.mapDimensions.value.y=a.height):(this.boundLoadedFunction=this.onTextureLoaded.bind(this),a.baseTexture.on("loaded",this.boundLoadedFunction)),this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform sampler2D displacementMap;","uniform sampler2D uSampler;","uniform vec2 scale;","uniform vec2 offset;","uniform vec4 dimensions;","uniform vec2 mapDimensions;","void main(void) {","   vec2 mapCords = vTextureCoord.xy;","   mapCords += (dimensions.zw + offset)/ dimensions.xy ;","   mapCords.y *= -1.0;","   mapCords.y += 1.0;","   vec2 matSample = texture2D(displacementMap, mapCords).xy;","   matSample -= 0.5;","   matSample *= scale;","   matSample /= mapDimensions;","   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));","   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);","   vec2 cord = vTextureCoord;","}"]},b.DisplacementFilter.prototype=Object.create(b.AbstractFilter.prototype),b.DisplacementFilter.prototype.constructor=b.DisplacementFilter,b.DisplacementFilter.prototype.onTextureLoaded=function(){this.uniforms.mapDimensions.value.x=this.uniforms.displacementMap.value.width,this.uniforms.mapDimensions.value.y=this.uniforms.displacementMap.value.height,this.uniforms.displacementMap.value.baseTexture.off("loaded",this.boundLoadedFunction)},Object.defineProperty(b.DisplacementFilter.prototype,"map",{get:function(){return this.uniforms.displacementMap.value},set:function(a){this.uniforms.displacementMap.value=a}}),Object.defineProperty(b.DisplacementFilter.prototype,"scale",{get:function(){return this.uniforms.scale.value},set:function(a){this.uniforms.scale.value=a}}),Object.defineProperty(b.DisplacementFilter.prototype,"offset",{get:function(){return this.uniforms.offset.value},set:function(a){this.uniforms.offset.value=a}}),b.PixelateFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={invert:{type:"1f",value:0},dimensions:{type:"4fv",value:new Float32Array([1e4,100,10,10])},pixelSize:{type:"2f",value:{x:10,y:10}}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform vec2 testDim;","uniform vec4 dimensions;","uniform vec2 pixelSize;","uniform sampler2D uSampler;","void main(void) {","   vec2 coord = vTextureCoord;","   vec2 size = dimensions.xy/pixelSize;","   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;","   gl_FragColor = texture2D(uSampler, color);","}"]},b.PixelateFilter.prototype=Object.create(b.AbstractFilter.prototype),b.PixelateFilter.prototype.constructor=b.PixelateFilter,Object.defineProperty(b.PixelateFilter.prototype,"size",{get:function(){return this.uniforms.pixelSize.value},set:function(a){this.dirty=!0,this.uniforms.pixelSize.value=a}}),b.BlurXFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={blur:{type:"1f",value:1/512}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float blur;","uniform sampler2D uSampler;","void main(void) {","   vec4 sum = vec4(0.0);","   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;","   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;","   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;","   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;","   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;","   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;","   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;","   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;","   gl_FragColor = sum;","}"]},b.BlurXFilter.prototype=Object.create(b.AbstractFilter.prototype),b.BlurXFilter.prototype.constructor=b.BlurXFilter,Object.defineProperty(b.BlurXFilter.prototype,"blur",{get:function(){return this.uniforms.blur.value/(1/7e3)},set:function(a){this.dirty=!0,this.uniforms.blur.value=1/7e3*a}}),b.BlurYFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={blur:{type:"1f",value:1/512}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float blur;","uniform sampler2D uSampler;","void main(void) {","   vec4 sum = vec4(0.0);","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;","   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;","   gl_FragColor = sum;","}"]},b.BlurYFilter.prototype=Object.create(b.AbstractFilter.prototype),b.BlurYFilter.prototype.constructor=b.BlurYFilter,Object.defineProperty(b.BlurYFilter.prototype,"blur",{get:function(){return this.uniforms.blur.value/(1/7e3)},set:function(a){this.uniforms.blur.value=1/7e3*a}}),b.BlurFilter=function(){this.blurXFilter=new b.BlurXFilter,this.blurYFilter=new b.BlurYFilter,this.passes=[this.blurXFilter,this.blurYFilter]},Object.defineProperty(b.BlurFilter.prototype,"blur",{get:function(){return this.blurXFilter.blur},set:function(a){this.blurXFilter.blur=this.blurYFilter.blur=a}}),Object.defineProperty(b.BlurFilter.prototype,"blurX",{get:function(){return this.blurXFilter.blur},set:function(a){this.blurXFilter.blur=a}}),Object.defineProperty(b.BlurFilter.prototype,"blurY",{get:function(){return this.blurYFilter.blur},set:function(a){this.blurYFilter.blur=a}}),b.InvertFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={invert:{type:"1f",value:1}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float invert;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord);","   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);","}"]},b.InvertFilter.prototype=Object.create(b.AbstractFilter.prototype),b.InvertFilter.prototype.constructor=b.InvertFilter,Object.defineProperty(b.InvertFilter.prototype,"invert",{get:function(){return this.uniforms.invert.value},set:function(a){this.uniforms.invert.value=a}}),b.SepiaFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={sepia:{type:"1f",value:1}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float sepia;","uniform sampler2D uSampler;","const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);","void main(void) {","   gl_FragColor = texture2D(uSampler, vTextureCoord);","   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);","}"]},b.SepiaFilter.prototype=Object.create(b.AbstractFilter.prototype),b.SepiaFilter.prototype.constructor=b.SepiaFilter,Object.defineProperty(b.SepiaFilter.prototype,"sepia",{get:function(){return this.uniforms.sepia.value},set:function(a){this.uniforms.sepia.value=a}}),b.TwistFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={radius:{type:"1f",value:.5},angle:{type:"1f",value:5},offset:{type:"2f",value:{x:.5,y:.5}}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform vec4 dimensions;","uniform sampler2D uSampler;","uniform float radius;","uniform float angle;","uniform vec2 offset;","void main(void) {","   vec2 coord = vTextureCoord - offset;","   float distance = length(coord);","   if (distance < radius) {","       float ratio = (radius - distance) / radius;","       float angleMod = ratio * ratio * angle;","       float s = sin(angleMod);","       float c = cos(angleMod);","       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);","   }","   gl_FragColor = texture2D(uSampler, coord+offset);","}"]},b.TwistFilter.prototype=Object.create(b.AbstractFilter.prototype),b.TwistFilter.prototype.constructor=b.TwistFilter,Object.defineProperty(b.TwistFilter.prototype,"offset",{get:function(){return this.uniforms.offset.value},set:function(a){this.dirty=!0,this.uniforms.offset.value=a}}),Object.defineProperty(b.TwistFilter.prototype,"radius",{get:function(){return this.uniforms.radius.value},set:function(a){this.dirty=!0,this.uniforms.radius.value=a}}),Object.defineProperty(b.TwistFilter.prototype,"angle",{get:function(){return this.uniforms.angle.value},set:function(a){this.dirty=!0,this.uniforms.angle.value=a}}),b.ColorStepFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={step:{type:"1f",value:5}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform sampler2D uSampler;","uniform float step;","void main(void) {","   vec4 color = texture2D(uSampler, vTextureCoord);","   color = floor(color * step) / step;","   gl_FragColor = color;","}"]},b.ColorStepFilter.prototype=Object.create(b.AbstractFilter.prototype),b.ColorStepFilter.prototype.constructor=b.ColorStepFilter,Object.defineProperty(b.ColorStepFilter.prototype,"step",{get:function(){return this.uniforms.step.value},set:function(a){this.uniforms.step.value=a}}),b.DotScreenFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={scale:{type:"1f",value:1},angle:{type:"1f",value:5},dimensions:{type:"4fv",value:[0,0,0,0]}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform vec4 dimensions;","uniform sampler2D uSampler;","uniform float angle;","uniform float scale;","float pattern() {","   float s = sin(angle), c = cos(angle);","   vec2 tex = vTextureCoord * dimensions.xy;","   vec2 point = vec2(","       c * tex.x - s * tex.y,","       s * tex.x + c * tex.y","   ) * scale;","   return (sin(point.x) * sin(point.y)) * 4.0;","}","void main() {","   vec4 color = texture2D(uSampler, vTextureCoord);","   float average = (color.r + color.g + color.b) / 3.0;","   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);","}"]},b.DotScreenFilter.prototype=Object.create(b.AbstractFilter.prototype),b.DotScreenFilter.prototype.constructor=b.DotScreenFilter,Object.defineProperty(b.DotScreenFilter.prototype,"scale",{get:function(){return this.uniforms.scale.value},set:function(a){this.dirty=!0,this.uniforms.scale.value=a}}),Object.defineProperty(b.DotScreenFilter.prototype,"angle",{get:function(){return this.uniforms.angle.value},set:function(a){this.dirty=!0,this.uniforms.angle.value=a}}),b.CrossHatchFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={blur:{type:"1f",value:1/512}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform float blur;","uniform sampler2D uSampler;","void main(void) {","    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);","    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);","    if (lum < 1.00) {","        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {","            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","        }","    }","    if (lum < 0.75) {","        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {","            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","        }","    }","    if (lum < 0.50) {","        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {","            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","        }","    }","    if (lum < 0.3) {","        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {","            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","        }","    }","}"]},b.CrossHatchFilter.prototype=Object.create(b.AbstractFilter.prototype),b.CrossHatchFilter.prototype.constructor=b.BlurYFilter,Object.defineProperty(b.CrossHatchFilter.prototype,"blur",{get:function(){return this.uniforms.blur.value/(1/7e3)},set:function(a){this.uniforms.blur.value=1/7e3*a}}),b.RGBSplitFilter=function(){b.AbstractFilter.call(this),this.passes=[this],this.uniforms={red:{type:"2f",value:{x:20,y:20}},green:{type:"2f",value:{x:-20,y:20}},blue:{type:"2f",value:{x:20,y:-20}},dimensions:{type:"4fv",value:[0,0,0,0]}},this.fragmentSrc=["precision mediump float;","varying vec2 vTextureCoord;","varying vec4 vColor;","uniform vec2 red;","uniform vec2 green;","uniform vec2 blue;","uniform vec4 dimensions;","uniform sampler2D uSampler;","void main(void) {","   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;","   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;","   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;","   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;","}"]},b.RGBSplitFilter.prototype=Object.create(b.AbstractFilter.prototype),b.RGBSplitFilter.prototype.constructor=b.RGBSplitFilter,Object.defineProperty(b.RGBSplitFilter.prototype,"angle",{get:function(){return this.uniforms.blur.value/(1/7e3)},set:function(a){this.uniforms.blur.value=1/7e3*a}}),"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=b),exports.PIXI=b):"undefined"!=typeof define&&define.amd?define(b):a.PIXI=b}).call(this);;var PixiRenderingSystem = TLRenderingSystem.extend({
	classId: 'PixiRenderingSystem',
	systemId: 'rendering',

	init: function(supersystem, data) {
		TLRenderingSystem.prototype.init.call(this, supersystem, data);
	},

	loadSpriteSheets: function(spriteSheets) {
		var self = this;
		var loader = new PIXI.AssetLoader(spriteSheets);
		loader.onComplete = function() {
			self.emit('texturesLoaded');
		};

		loader.load();
	},

	loadTextures: function(textureMap) {
		_.forIn(textureMap, function(imageUrl, id) {
			var texture = PIXI.Texture.fromImage(imageUrl);
			PIXI.Texture.addTextureToCache(texture, id);
		});
	},

	update: function() {
		this._renderer.render(this._stage);
	},

	stage: function() {
		return this._stage;
	},

	/**
	 * Sets the canvas element that will be used as the front-buffer.
	 * @param elem The canvas element.
	 * @param autoSize If set to true, the engine will automatically size
	 * the canvas to the width and height of the window upon window resize.
	 */
	canvas: function (elem, autoSize) {
		if (elem !== undefined) {
			if (!this._canvas) {
				// Setup front-buffer canvas element
				this._canvas = elem;

				this._devicePixelRatio = 1; //window.devicePixelRatio || 1;

				// Add some event listeners even if autosize is off
				window.addEventListener('resize', this._resizeEvent.bind(this));

				// Fire the resize event for the first time
				// which sets up initial canvas dimensions
				this._resizeEvent();
				ige._headless = false;

				// Ask the input component to setup any listeners it has
				ige.input.setupListeners(this._canvas);
			}
		}

		return this._canvas;
	},

	_frontBufferSetup: function (autoSize, dontScale) {
		this._stage = new PIXI.Stage(0x000000);
		this._scaleContainer = new PIXI.DisplayObjectContainer();

		PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR;

		var scale = 1; //window.devicePixelRatio; //TODO: Scaling for retina display does not work properly with Pixi

		//this._renderer = PIXI.autoDetectRenderer(window.innerWidth * scale, window.innerHeight * scale, null, true, true);
		this._renderer = new PIXI.CanvasRenderer(window.innerWidth * scale, window.innerHeight * scale, null, false, true);
		this._renderer.view.width = window.innerWidth + 'px';
		this._renderer.view.height = window.innerHeight + 'px';

		this._scaleContainer.scale.x = this._scaleContainer.scale.y = scale;
		this._stage.addChild(this._scaleContainer);

		this._renderer.view.id = 'igeFrontBuffer';

		this.canvas(this._renderer.view, autoSize);

		document.body.appendChild(this._renderer.view);
	},

	/**
	 * Handles the screen resize event.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		var canvasBoundingRect;

		if (this._autoSize) {
			var newWidth = window.innerWidth,
				newHeight = window.innerHeight,
				arr = ige._children,
				arrCount = arr.length;

			// Only update canvas dimensions if it exists
			if (this._canvas) {
				// Check if we can get the position of the canvas
				canvasBoundingRect = this._canvasPosition();

				// Adjust the newWidth and newHeight by the canvas offset
				newWidth -= parseInt(canvasBoundingRect.left);
				newHeight -= parseInt(canvasBoundingRect.top);

				// Make sure we can divide the new width and height by 2...
				// otherwise minus 1 so we get an even number so that we
				// negate the blur effect of sub-pixel rendering
				if (newWidth % 2) { newWidth--; }
				if (newHeight % 2) { newHeight--; }

				this._canvas.width = newWidth * this._devicePixelRatio;
				this._canvas.height = newHeight * this._devicePixelRatio;

				if (this._devicePixelRatio !== 1) {
					this._canvas.style.width = newWidth + 'px';
					this._canvas.style.height = newHeight + 'px';

					// Scale the canvas context to account for the change
					// TODO: Figure out how to scale PIXI Stage
					//this._scaleContainer.scale.x = this._scaleContainer.scale.y = this._devicePixelRatio;
					//this._ctx.scale(this._deviceFinalDrawRatio, this._deviceFinalDrawRatio);
				}
			}

			ige._bounds2d = new IgePoint3d(newWidth, newHeight, 0);

			// Loop any mounted children and check if
			// they should also get resized
			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		} else {
			if (this._canvas) {
				ige._bounds2d = new IgePoint3d(this._canvas.width, this._canvas.height, 0);
			}
		}

		ige._resized = true;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = PixiRenderingSystem; };var PixiRenderableComponent = TLRenderableComponent.extend({
	classId: 'PixiRenderableComponent',
	componentId: 'renderable',

	_addedChildren: undefined,

	init: function(entity, data) {
		TLRenderableComponent.prototype.init.call(this, entity, data);
		if (ige.isServer) {
			return;
		}

		// If no data and no custom display object function is provided, the default is to create an empty container.
		this._displayObject = data && data.createDisplayObject ? data.createDisplayObject() : this.defaultDisplayObject();
		this._displayObject._entity = entity;
		this._addedChildren = false;

		this._entity.on('mounted', this.mounted.bind(this));
		this._entity.on('unMounted', this.unMounted.bind(this));
		this._entity.on('depthSet', this.depthSortParent.bind(this));
	},

	defaultDisplayObject: function() {
		var object = new PIXI.DisplayObjectContainer();
		object.position.x = object.position.y = 0;
		return object;
	},

	displayObject: function(createDisplayObject) {
		if (createDisplayObject) {
			this._displayObject = createDisplayObject();
			return this;
		}

		return this._displayObject;
	},

	cacheDirty: function(dirty) {
		if (dirty !== undefined) {
			this._cacheDirty = true;
			// NOTE: I have no idea why this number works and numbers smaller than it don't. Just
			// go with it. It reduces update time from 70ms to less than 15ms in most cases.
			this._numUpdatesUntilCacheUpdate = 3;

			// If caching is not enabled, then don't reset the cache dirty flag.
			if (!this._compositeCache) {
				this._cacheDirty = false;
			}
			return this;
		}
		return this._cacheDirty;
	},

	compositeCache: function(val) {
		if (val !== undefined) {
			this._compositeCache = val;
			this.cacheDirty(true);
			return this;
		}

		return this._compositeCache;
	},

	mounted: function(parent) {
		if (parent === ige) {
			ige.pixiRendering.stage().addChild(this._displayObject);
		}
		else {
			parent.renderable.displayObject().addChild(this._displayObject);
		}

		this.depthSortParent();
		this.update();
	},

	unMounted: function() {
		this._displayObject.parent.removeChild(this._displayObject);
	},

	depthSortParent: function() {
		// Sort entities by depth
		var parent = this.displayObject().parent;
		if (parent && parent._entity) {
			//console.log('Sorting: ' + parent._entity.classId());
			parent.children.sort(function (a, b) {
				var layerIndex = a._entity._layer - b._entity._layer;
				if (layerIndex === 0) {
					// On same layer so sort by depth
					return a._entity._depth - b._entity._depth;
				}
				else {
					// Not on same layer so sort by layer
					return layerIndex;
				}
			});
		}
	},

	update: function() {
		//console.log('PixiRenderableComponent#update: ' + this._entity.classId());
		if (!this._displayObject) {
			console.log('PixiRenderableComponent#update: no display object to update.');
			return;
		}

		this._displayObject.visible = !this._hidden && this._entity._inView && this._entity._alive
			&& !this._entity._newBorn && !this._entity._streamJustCreated;

		this._displayObject.position.x = this._entity.translate().x() + this._anchor.x;
		//console.log('PixiRenderableComponent#update: position.x=' + this._displayObject.position.x);

		this._displayObject.position.y = this._entity.translate().y() + this._anchor.y;
		//console.log('PixiRenderableComponent#update: position.y=' + this._displayObject.position.y);

		this._displayObject.rotation = this._entity.rotate().z();

		this._displayObject.alpha = this._opacity;

		if (this._cacheDirty) {
			this._numUpdatesUntilCacheUpdate--;

			if (this._numUpdatesUntilCacheUpdate === 0) {
				this._displayObject.cacheAsBitmap = false;
				this._displayObject.cacheAsBitmap = true;
				this._cacheDirty = false;
			}
		}
	},

	addChild: function(child) {
		if (!this._displayObject || !child) {
			return;
		}
		this._displayObject.addChild(child);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = PixiRenderableComponent; };var PixiViewportRenderableComponent = PixiRenderableComponent.extend({
	classId: 'PixiViewportRenderableComponent',
	componentId: 'renderable',

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
		if (ige.isServer) {
			return;
		}

		if (this._entity instanceof IgeViewport) {
			ige.rendering._scaleContainer.addChild(this._displayObject);
		}

		this._entity.on('sceneSet', this.sceneSet.bind(this));
	},

	sceneSet: function(scene) {
		// If we already have a scene child, remove it! Viewports can only have one scene.
		if (this._displayObject.children.length > 0) {
			this._displayObject.removeChildAt(0);
		}
		this._displayObject.addChild(scene.renderable.displayObject());
	},

	mounted: function() {

	},

	update: function() {
		this._displayObject.scale.x = this._entity.camera._localMatrix.matrix[0];
		this._displayObject.scale.y = this._entity.camera._localMatrix.matrix[4];

		// TODO: Reference _localMatrix rather than _localMatrix once the position data has been put back into the entity.
		this._displayObject.position.x = this._entity.camera._localMatrix.matrix[2] + ige.rendering._canvas.width / 2;
		this._displayObject.position.y = this._entity.camera._localMatrix.matrix[5] + ige.rendering._canvas.height / 2;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = PixiViewportRenderableComponent; };/**
 * Adds client/server time sync capabilities to the network system.
 * This handles calculating the time difference between the clock
 * on the server and the clock on connected clients.
 */
var IgeTimeSyncExtension = {
	/**
	 * Gets / sets the number of milliseconds between client/server
	 * clock sync events. The shorter the time, the more accurate the
	 * client simulation will be but the more network traffic you
	 * will transceive. Default value of ten seconds (10000) is usually
	 * enough to provide very accurate results without over-using the
	 * bandwidth.
	 * @param val
	 * @return {*}
	 */
	timeSyncInterval: function (val) {
		if (val !== undefined) {
			this._timeSyncInterval = val;
			return this._entity;
		}

		return this._timeSyncInterval;
	},

	
	
	_sendTimeSync: function (data, clientId) {
		if (!data) {
			data = ige._currentTime;
		}

		// Send the time sync command
		this.send('_igeNetTimeSync', data, clientId);
	},

	/**
	 * Converts a timestamp on the client to approx. time
	 * on the server using the difference in client/server
	 * clocks and the network latency between this client
	 * and the server.
	 * @param {Number} time The client timestamp (usually
	 * the result of new Date().getTime() or
	 * ige.currentTime()).
	 */
	timeToServerTime: function (time) {
		if (time !== undefined) {
			return time + this._latency;
		}

		return this._latency;
	},

	_onTimeSync: function (data, clientId) {
		var localTime = Math.floor(ige._currentTime),
			sendTime,
			roundTrip,
			direction;

		if (ige.isClient) {
			sendTime = parseInt(data, 10);

			this._latency = localTime - sendTime;

			/*if (localTime < sendTime) {
				direction = 'behind';
			} else if (localTime > sendTime) {
				direction = 'in front of';
			} else {
				direction = 'same as';
			}

			this.log('Time sync, client clock ' + (localTime - sendTime) + 'ms ' + direction + ' server, send timestamp: ' + sendTime + ', local timestamp: ' + localTime);*/

			// Send a response with out current clock time to the server
			this._sendTimeSync([data, localTime]);
		}
		
		
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTimeSyncExtension; };/**
 * Adds stream capabilities to the network system.
 */
var IgeStreamComponent = IgeEventingClass.extend({
	classId: 'IgeStreamComponent',
	componentId: 'stream',
	/**
	 * True if component's behavior is running every engineStep
	 * @type {Boolean}
	 * @memberof IgeStreamComponent
	 * @private
	 * @instance
	 */
	_active: undefined,

	/**
	 * @constructor
	 * @param entity
	 * @param options
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		var self = this;
		
		// Set the stream data section designator character
		this._sectionDesignator = '';

		

		if (ige.isClient) {
			// Define the network stream command
			this._entity.define('_igeStreamCreate', function () { self._onStreamCreate.apply(self, arguments); });
			this._entity.define('_igeStreamDestroy', function () { self._onStreamDestroy.apply(self, arguments); });
			this._entity.define('_igeStreamData', function () { self._onStreamData.apply(self, arguments); });
			this._entity.define('_igeStreamCommands', function () {self._onStreamCommands.apply(self, arguments); });
			this._entity.define('_igeStreamTime', function () { self._onStreamTime.apply(self, arguments); });
			this._entity.define('_entityInvalid', function () { self._onEntityInvalid.apply(self, arguments); });
		}

		// Set some defaults
		this._renderLatency = 100;
		this._streamInterval = 50;
	},

	/**
	 * Gets /Sets the amount of milliseconds in the past that the renderer will
	 * show updates from the stream. This allows us to interpolate from a previous
	 * position to the next position in the stream update. Updates come in and
	 * are already in the past when they are received so we need to set this
	 * latency value to something greater than the highest level of acceptable
	 * network latency. Usually this is a value between 100 and 200ms. If your
	 * game requires much tighter latency you will have to reduce the number of
	 * players / network updates / data size in order to compensate. A value of
	 * 100 in this call is the standard that most triple-A FPS games accept as
	 * normal render latency and should be OK for your game.
	 *
	 * @param latency
	 */
	renderLatency: function (latency) {
		if (latency !== undefined) {
			this._renderLatency = latency;
			return this._entity;
		}

		return this._renderLatency;
	},

	

	/**
	 * Handles receiving the start time of the stream data.
	 * @param data
	 * @private
	 */
	_onStreamTime: function (data) {
		this._streamDataTime = data;
	},

	_onStreamCreate: function (data) {
		var classId = data[0],
			entityId = data[1],
			parentId = data[2],
			transformData = data[3],
			createData = data[4],
			parent = ige.$(parentId),
			classConstructor,
			entity;

		// Check the required class exists
		if (parent) {
			// Check that the entity doesn't already exist
			if (!ige.$(entityId)) {
				classConstructor = igeClassStore[classId];

				if (classConstructor) {
					// The entity does not currently exist so create it!
					entity = new classConstructor(createData)
						.id(entityId)
						.mount(parent);
					
					entity.streamSectionData('transform', transformData, true);

					// Set the just created flag which will stop the renderer
					// from handling this entity until after the first stream
					// data has been received for it
					entity._streamJustCreated = true;
					
					if (entity._streamEmitCreated) {
						entity.emit('streamCreated');
					}

					// Since we just created an entity through receiving stream
					// data, inform any interested listeners
					this.emit('entityCreated', entity);
				} else {
					ige.network.stop();
					ige.stop();

					this.log('Network stream cannot create entity with class ' + classId + ' because the class has not been defined! The engine will now stop.', 'error');
				}
			}
		} else {
			this.log('Cannot properly handle network streamed entity with id ' + entityId + ' because it\'s parent with id ' + parentId + ' does not exist on the scenegraph!', 'warning');
		}
	},

	_onStreamDestroy: function (data) {
		var entity = ige.$(data[1]),
			self = this;
		
		if (entity) {
			// Calculate how much time we have left before the entity
			// should be removed from the simulation given the render
			// latency setting and the current time
			var destroyDelta = ige.network.stream._renderLatency + (ige._currentTime - data[0]);
			
			if (destroyDelta > 0) {
				// Give the entity a lifespan to destroy it in x ms
				entity.lifeSpan(destroyDelta, function () {
					self.emit('entityDestroyed', entity);
				});
			} else {
				// Destroy immediately
				self.emit('entityDestroyed', entity);
				entity.destroy();
			}
		}
	},

	/**
	 * Called when the client receives data from the stream system.
	 * Handles decoding the data and calling the relevant entity
	 * _onStreamData() methods.
	 * @param data
	 * @private
	 */
	_onStreamData: function (data) {
		// Read the packet data into variables
		var entityId,
			entity,
			sectionArr,
			sectionDataArr = data.split(ige.network.stream._sectionDesignator),
			sectionDataCount = sectionDataArr.length,
			sectionIndex,
			justCreated;

		// We know the first bit of data will always be the
		// target entity's ID
		entityId = sectionDataArr.shift();

		// Check if the entity with this ID currently exists
		entity = ige.$(entityId);

		if (entity) {
			// Hold the entity's just created flag
			justCreated = entity._streamJustCreated;

			// We have received an onStreamData from the server. This means the
			// server has determined that this entity should be visible to the
			// player. So, mark this streamed entity as valid so we display it
			//  to the player.
			entity.streamEntityValid(true);

			// Get the entity stream section array
			sectionArr = entity._streamSections;

			// Now loop the data sections array and compile the rest of the
			// data string from the data section return data
			for (sectionIndex = 0; sectionIndex < sectionArr.length; sectionIndex++) {
				// Tell the entity to handle this section's data
				entity.streamSectionData(sectionArr[sectionIndex], sectionDataArr[sectionIndex], justCreated);
			}

			var privateSectionArr = entity._streamPrivateSections;

			if (privateSectionArr) {
				for (var privateSectionIndex = 0;
					 privateSectionIndex < privateSectionArr.length; privateSectionIndex++)
				{
					entity.streamSectionData(privateSectionArr[privateSectionIndex].id,
						sectionDataArr[sectionArr.length + privateSectionIndex], justCreated);
				}
			}

			// Now that the entity has had it's first bit of data
			// reset the just created flag
			delete entity._streamJustCreated;
		} else {
			this.log('+++ Stream: Data received for unknown entity (' + entityId +')');
		}
	},

	/**
	 * Called when the client receives batched commands from the stream system.
	 * Emits the batched commands to the IGE network component, which calls
	 * the correct registered function.
	 * @param data Data received from the server
	 * @private
	 */
	_onStreamCommands: function (data) {
		for (var i = 0; i < data.length; i++) {
			var command = data[i];
			ige.network._io.emit('message', [command]);
		}
	},

	/**
	 * Called when the client receives onEntityInvalid from the server, which
	 * means the server has determined this entity should be hidden from the
	 * player. The server will not stream updates to this client any longer,
	 * so it is important that the entity is hidden client side to prevent
	 * players from being confused by "dead" entities on screen.
	 * @param data Data received from the server
	 * @private
	 */
	_onEntityInvalid: function (data) {
		var entity = ige.$(data);
		if (entity !== undefined) {
			entity.streamEntityValid(false);
		}
	}

});


if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeStreamComponent; }
;// Our namespace
var NetIo = {};

/**
 * Define the debug options object.
 * @type {Object}
 * @private
 */
NetIo._debug = {
	_enabled: true,
	_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
	_level: ['log', 'warning', 'error'],
	_stacks: false,
	_throwErrors: true,
	_trace: {
		setup: false,
		enabled: false,
		match: ''
	},
	enabled: function (val) {
		if (val !== undefined) {
			this._enabled = val;
			return this;
		}

		return this._enabled;
	}
};

/**
 * Define the class system.
 * @type {*}
 */
NetIo.Class = IgeClass;

NetIo.EventingClass = IgeEventingClass;

NetIo.Client = NetIo.EventingClass.extend({
	classId: 'NetIo.Client',

	init: function (url, options) {
		this.log('Net.io client starting...');
		this._options = options || {};
		this._socket = null;
		this._state = 0;
		this._debug = false;
		this._connectionAttempts = 0;

		// Set some default options
		if (this._options.connectionRetry === undefined) { this._options.connectionRetry = true; }
		if (this._options.connectionRetryMax === undefined) { this._options.connectionRetryMax = 10; }
		if (this._options.reconnect === undefined) { this._options.reconnect = true; }

		// If we were passed a url, connect to it
		if (url !== undefined) {
			this.connect(url);
		}
	},

	/**
	 * Gets / sets the debug flag. If set to true, net.io
	 * will output debug data about every network event as
	 * it occurs to the console.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this;
		}

		return this._debug;
	},

	connect: function (url) {
		this.log('Connecting to server at ' + url);
		var self = this;

		// Set the state to connecting
		this._state = 1;

		// Replace http:// with ws://
		url = url.replace('http://', 'ws://');

		// Create new websocket to the url
		this._socket = new WebSocket(url);

		// Setup event listeners
		this._socket.onopen = function () { self._onOpen.apply(self, arguments); };
		this._socket.onmessage = function () { self._onData.apply(self, arguments); };
		this._socket.onclose = function () { self._onClose.apply(self, arguments); };
		this._socket.onerror = function () { self._onError.apply(self, arguments); };
	},

	disconnect: function (reason) {
		this._socket.close(1000, reason);
	},

	send: function (data) {
		this._socket.send(this._encode(data));
	},

	_onOpen: function () {
		this._state = 2;
	},

	_onData: function (data) {
		// Decode packet and emit message event
		var packet = this._decode(data.data);

		// Output debug if required
		if (this._debug) {
			console.log('Incoming data (event, decoded data):', data, packet);
		}

		if (packet._netioCmd) {
			// The packet is a netio command
			switch (packet._netioCmd) {
				case 'id':
					// Store the new id in the socket
					this.id = packet.data;

					// Now we have an id, set the state to connected
					this._state = 3;

					// Emit the connect event
					this.emit('connect', this.id);
					break;

				case 'close':
					// The server told us our connection has been closed
					// so store the reason the server gave us!
					this._disconnectReason = packet.data;
					break;
			}
		} else {
			// The packet is normal data
			this.emit('message', [packet]);
		}
	},

	_onClose: function (code, reason, wasClean) {
		// If we are already connected and have an id...
		if (this._state === 3) {
			this._state = 0;
			this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code:code});
		}

		// If we are connected but have no id...
		if (this._state === 2) {
			this._state = 0;
			this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code:code});
		}

		// If we were trying to connect...
		if (this._state === 1) {
			this._state = 0;
			this.emit('error', {reason: 'Cannot establish connection, is server running?'});
		}

		// Remove the last disconnect reason
		delete this._disconnectReason;
	},

	_onError: function () {
		this.log('An error occurred with the net.io socket!', 'error', arguments);
		this.emit('error', arguments);
	},

	_encode: function (data) {
		return JSON.stringify(data);
	},

	_decode: function (data) {
		return JSON.parse(data);
	}
});;/**
 * The client-side net.io component. Handles all client-side
 * networking systems.
 */
var IgeNetIoClient = {
	version: '1.0.0',
	_initDone: false,
	_idCounter: 0,
	_requests: {},
	_state: 0,

	/**
	 * Gets the current socket id.
	 * @returns {String} The id of the socket connection to the server.
	 */
	id: function () {
		return this._id || '';
	},
	
	/**
	 * Starts the network for the client.
	 * @param {*} url The game server URL.
	 * @param {Function=} callback A callback method to call once the
	 * network has started.
	 */
	start: function (url, callback) {
		if (this._state === 3) {
			// We're already connected
			if (typeof(callback) === 'function') {
				callback();
			}
		} else {
			var self = this;

			self._startCallback = callback;

			if (typeof(url) !== 'undefined') {
				this._url = url;
			}

			this.log('Connecting to net.io server at "' + this._url + '"...');

			if (typeof(WebSocket) !== 'undefined') {
				this._io = new NetIo.Client(url);
				self._state = 1; // Connecting

				// Define connect listener
				this._io.on('connect', function (clientId) {
					self._state = 2; // Connected
					self._id = clientId;
					self._onConnectToServer.apply(self, arguments);
				});

				// Define message listener
				this._io.on('message', function (data) {
					if (!self._initDone) {
						var i, commandCount = 0;

						// Check if the data is an init packet
						if (data.cmd === 'init') {
							// Set flag to show we've now received an init command
							self._initDone = true;
							self._state = 3; // Connected and init done

							// Setup the network commands storage
							self._networkCommandsLookup = data.ncmds;

							// Fill the reverse lookup on the commands
							for (i in self._networkCommandsLookup) {
								if (self._networkCommandsLookup.hasOwnProperty(i)) {
									self._networkCommandsIndex[self._networkCommandsLookup[i]] = i;
									commandCount++;
								}
							}

							// Setup default commands
							self.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
							self.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
							self.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });

							self.log('Received network command list with count: ' + commandCount);

							// Setup time scale and current time
							ige.timeScale(parseFloat(data.ts));
							ige._currentTime = parseInt(data.ct);

							// Now fire the start() callback
							if (typeof(self._startCallback) === 'function') {
								self._startCallback();
								delete self._startCallback;
							}
						}
					} else {
						self._onMessageFromServer.apply(self, arguments);
					}
				});

				// Define disconnect listener
				this._io.on('disconnect', function () {
					self._state = 0; // Disconnected
					self._onDisconnectFromServer.apply(self, arguments);
				});

				// Define error listener
				this._io.on('error', function() {
					ige.emit('ige network error');
					self._onError.apply(self, arguments);
				});
			}
		}
	},

	stop: function () {
		// Check we are connected
		if (self._state === 3) {
			this._io.disconnect('Client requested disconnect');
		}
	},

	/**
	 * Gets / sets a network command and callback. When a network command
	 * is received by the client, the callback set up for that command will
	 * automatically be called and passed the data from the incoming network
	 * packet.
	 * @param {String} commandName The name of the command to define.
	 * @param {Function} callback A function to call when the defined network
	 * command is received by the network.
	 * @return {*}
	 */
	define: function (commandName, callback) {
		if (commandName !== undefined && callback !== undefined) {
			// Check if this command has been defined by the server
			if (this._networkCommandsLookup[commandName] !== undefined) {
				this._networkCommands[commandName] = callback;
			} else {
				this.log('Cannot define network command "' + commandName + '" because it does not exist on the server. Please edit your server code and define the network command there before trying to define it on the client!', 'error');
			}

			return this._entity;
		} else {
			this.log('Cannot define network command either the commandName or callback parameters were undefined!', 'error');
		}
	},

	/**
	 * Sends a network message with the given command name
	 * and data.
	 * @param commandName
	 * @param data
	 */
	send: function (commandName, data) {
		var commandIndex = this._networkCommandsLookup[commandName],
			ciEncoded;

		if (commandIndex !== undefined) {
			if (this.debug()) {
				console.log('Sending "' + commandName + '" (index ' + commandIndex + ') with data:', data);
				this._debugCounter++;
			}
			ciEncoded = String.fromCharCode(commandIndex);
			this._io.send([ciEncoded, data]);
		} else {
			this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
		}
	},

	/**
	 * Sends a network request. This is different from a standard
	 * call to send() because the recipient code will be able to
	 * respond by calling ige.network.response(). When the response
	 * is received, the callback method that was passed in the
	 * callback parameter will be fired with the response data.
	 * @param {String} commandName
	 * @param {Object} data
	 * @param {Function} callback
	 */
	request: function (commandName, data, callback) {
		// Build the request object
		var req = {
			id: this.newIdHex(),
			cmd: commandName,
			data: data,
			callback: callback,
			timestamp: new Date().getTime()
		};

		// Store the request object
		this._requests[req.id] = req;

		// Send the network request packet
		this.send(
			'_igeRequest',
			{
				id: req.id,
				cmd: commandName,
				data: req.data
			}
		);
	},

	/**
	 * Sends a response to a network request.
	 * @param {String} requestId
	 * @param {Object} data
	 */
	response: function (requestId, data) {
		// Grab the original request object
		var req = this._requests[requestId];

		if (req) {
			// Send the network response packet
			this.send(
				'_igeResponse',
				{
					id: requestId,
					cmd: req.commandName,
					data: data
				}
			);

			// Remove the request as we've now responded!
			delete this._requests[requestId];
		}
	},

	/**
	 * Generates a new 16-character hexadecimal unique ID
	 * @return {String}
	 */
	newIdHex: function () {
		this._idCounter++;
		return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
	},

	_onRequest: function (data) {
		// The message is a network request so fire
		// the command event with the request id and
		// the request data
		this._requests[data.id] = data;

		if (this.debug()) {
			console.log('onRequest', data);
			this._debugCounter++;
		}

		if (this._networkCommands[data.cmd]) {
			this._networkCommands[data.cmd](data.id, data.data);
		}

		this.emit(data.cmd, [data.id, data.data]);
	},

	_onResponse: function (data) {
		var id,
			req;
		
		// The message is a network response
		// to a request we sent earlier
		id = data.id;

		// Get the original request object from
		// the request id
		req = this._requests[id];

		if (this.debug()) {
			console.log('onResponse', data);
			this._debugCounter++;
		}

		if (req) {
			// Fire the request callback!
			req.callback(req.cmd, data.data);

			// Delete the request from memory
			delete this._requests[id];
		}
	},

	/**
	 * Called when the network connects to the server.
	 * @private
	 */
	_onConnectToServer: function () {
		this.log('Connected to server!');
		this.emit('connected');
	},

	/**
	 * Called when data from the server is received on the client.
	 * @param data
	 * @private
	 */
	_onMessageFromServer: function (data) {
		var ciDecoded = data[0].charCodeAt(0),
			commandName = this._networkCommandsIndex[ciDecoded];

		if (this._networkCommands[commandName]) {
			if (this.debug()) {
				console.log('Received "' + commandName + '" (index ' + ciDecoded + ') with data:', data[1]);
				this._debugCounter++;
			}

			this._networkCommands[commandName](data[1]);
		}

		this.emit(commandName, data[1]);
	},

	/**
	 * Called when the client is disconnected from the server.
	 * @param data
	 * @private
	 */
	_onDisconnectFromServer: function (data) {
		if (data === 'booted') {
			this.log('Server rejected our connection because it is not accepting connections at this time!', 'warning');
		} else {
			this.log('Disconnected from server!');
		}
		this.emit('disconnected');
	},

	/**
	 * Called when the client has an error with the connection.
	 * @param {Object} data
	 * @private
	 */
	_onError: function (data) {
		this.log('Error with connection: ' + data.reason, 'error');
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeNetIoClient; };var IgeNetIoServer = {
	_idCounter: 0,
	_requests: {},

	/**
	 * Starts the network for the server.
	 * @param {*} data The port to listen on.
	 * @param {Function=} callback A callback method to call once the
	 * network has started.
	 */
	start: function (data, callback) {
		var self = this;

		this._socketById = {};
		this._socketsByRoomId = {};

		if (typeof(data) !== 'undefined') {
			this._port = data;
		}

		// Start net.io
		this.log('Starting net.io listener on port ' + this._port);
		this._io = new this._netio(this._port, callback);

		// Setup listeners
		this._io.on('connection', function () { self._onClientConnect.apply(self, arguments); });

		// Setup default commands
		this.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
		this.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
		this.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });

		// Start network sync
		this.timeSyncStart();

		return this._entity;
	},

	/**
	 * Sets a network command and optional callback. When a network command
	 * is received by the server, the callback set up for that command will
	 * automatically be called and passed the data from the incoming network
	 * packet.
	 * @param {String} commandName The name of the command to define.
	 * @param {Function=} callback A function to call when the defined network
	 * command is received by the network.
	 * @return {*}
	 */
	define: function (commandName, callback) {
		if (commandName !== undefined) {
			this._networkCommands[commandName] = callback;

			// Record reverse lookups
			var index = this._networkCommandsIndex.length;
			this._networkCommandsIndex[index] = commandName;
			this._networkCommandsLookup[commandName] = index;

			return this._entity;
		} else {
			this.log('Cannot define a network command without a commandName parameter!', 'error');
		}
	},

	/**
	 * Adds a client to a room by id. All clients are added to room id
	 * "ige" by default when they connect to the server. 
	 * @param {String} clientId The id of the client to add to the room.
	 * @param {String} roomId The id of the room to add the client to.
	 * @returns {*}
	 */
	clientJoinRoom: function (clientId, roomId) {
		if (clientId !== undefined) {
			if (roomId !== undefined) {
				this._clientRooms[clientId] = this._clientRooms[clientId] || [];
				this._clientRooms[clientId].push(roomId);
				
				this._socketsByRoomId[roomId] = this._socketsByRoomId[roomId] || {};
				this._socketsByRoomId[roomId][clientId] = this._socketById[clientId];
				
				if (this.debug()) {
					this.log('Client ' + clientId + ' joined room ' + roomId);
				}
				
				return this._entity;
			}
			
			this.log('Cannot add client to room because no roomId was provided!', 'warning');
			return this._entity;
		}
		
		this.log('Cannot add client to room because no clientId was provided!', 'warning');
		return this._entity;
	},
	
	/**
	 * Removes a client from a room by id. All clients are added to room id
	 * "ige" by default when they connect to the server and you can remove
	 * them from it if your game defines custom rooms etc.
	 * @param {String} clientId The id of the client to remove from the room.
	 * @param {String} roomId The id of the room to remove the client from.
	 * @returns {*}
	 */
	clientLeaveRoom: function (clientId, roomId) {
		if (clientId !== undefined) {
			if (roomId !== undefined) {
				if (this._clientRooms[clientId]) {
					this._clientRooms[clientId].pull(roomId);
					delete this._socketsByRoomId[roomId][clientId];
				}
				
				return this._entity;
			}
			
			this.log('Cannot remove client from room because no roomId was provided!', 'warning');
			return this._entity;
		}
		
		this.log('Cannot remove client from room because no clientId was provided!', 'warning');
		return this._entity;
	},

	/**
	 * Removes a client from all rooms that it is a member of.
	 * @param {String} clientId The client id to remove from all rooms.
	 * @returns {*}
	 */
	clientLeaveAllRooms: function (clientId) {
		if (clientId !== undefined) {
			if (this._clientRooms[clientId] !== undefined) {
				var arr = this._clientRooms[clientId],
					arrCount = arr.length;

				while (arrCount--) {
					this.clientLeaveRoom(clientId, arr[arrCount]);
				}

				delete this._clientRooms[clientId];
				return this._entity;
			}
		}
		
		this.log('Cannot remove client from room because no clientId was provided!', 'warning');
		return this._entity;
	},

	/**
	 * Gets the array of room ids that the client has joined.
	 * @param clientId
	 * @returns {Array} An array of string ids for each room the client has joined.
	 */
	clientRooms: function (clientId) {
		if (clientId !== undefined) {
			return this._clientRooms[clientId] || [];
		}
		
		this.log('Cannot get/set the clientRoom id because no clientId was provided!', 'warning');
		return [];
	},
	
	/**
	 * Returns an associative array of all connected clients
	 * by their ID.
	 * @param {String=} roomId Optional, if provided will only return clients
	 * that have joined room specified by the passed roomId.
	 * @return {Array}
	 */
	clients: function (roomId) {
		if (roomId !== undefined) {
			return this._socketsByRoomId[roomId];
		}
		
		return this._socketById;
	},

	/**
	 * Returns the socket associated with the specified client id.
	 * @param {String=} clientId
	 * @return {*}
	 */
	socket: function (clientId) {
		return this._socketById[clientId];
	},

	/**
	 * Gets / sets the current flag that determines if client connections
	 * should be allowed to connect (true) or dropped instantly (false).
	 * @param {Boolean} val Set to true to allow connections or false
	 * to drop any incoming connections.
	 * @return {*}
	 */
	acceptConnections: function (val) {
		if (typeof(val) !== 'undefined') {
			this._acceptConnections = val;
			if (val) {
				this.log('Server now accepting connections!');
			} else {
				this.log('Server no longer accepting connections!');
			}

			return this._entity;
		}

		return this._acceptConnections;
	},

	/**
	 * Sends a message over the network.
	 * @param {String} commandName
	 * @param {Object} data
	 * @param {*=} clientId If specified, sets the recipient socket id or a array of socket ids to send to.
	 */
	send: function (commandName, data, clientId) {
		var commandIndex = this._networkCommandsLookup[commandName],
			ciEncoded;

		if (commandIndex !== undefined) {
			ciEncoded = String.fromCharCode(commandIndex);
			this._io.send([ciEncoded, data], clientId);
		} else {
			this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
		}
	},

	/**
	 * Sends a network request. This is different from a standard
	 * call to send() because the recipient code will be able to
	 * respond by calling ige.network.response(). When the response
	 * is received, the callback method that was passed in the
	 * callback parameter will be fired with the response data.
	 * @param {String} commandName
	 * @param {Object} data
	 * @param {Function} callback
	 */
	request: function (commandName, data, callback) {
		// Build the request object
		var req = {
			id: this.newIdHex(),
			cmd: commandName,
			data: data,
			callback: callback,
			timestamp: new Date().getTime()
		};

		// Store the request object
		this._requests[req.id] = req;

		// Send the network request packet
		this.send(
			'_igeRequest',
			{
				id: req.id,
				cmd: commandName,
				data: req.data
			}
		);
	},

	/**
	 * Sends a response to a network request.
	 * @param {String} requestId
	 * @param {Object} data
	 */
	response: function (requestId, data) {
		// Grab the original request object
		var req = this._requests[requestId];

		if (req) {
			// Send the network response packet
			this.send(
				'_igeResponse',
				{
					id: requestId,
					cmd: req.commandName,
					data: data
				},
				req.clientId
			);

			// Remove the request as we've now responded!
			delete this._requests[requestId];
		}
	},

	/**
	 * Generates a new 16-character hexadecimal unique ID
	 * @return {String}
	 */
	newIdHex: function () {
		this._idCounter++;
		return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
	},

	/**
	 * Determines if the origin of a request should be allowed or denied.
	 * @param origin
	 * @return {Boolean}
	 * @private
	 */
	_originIsAllowed: function (origin) {
		// put logic here to detect whether the specified origin is allowed.
		return true;
	},

	/**
	 * Called when the server receives a client connection request. Sets
	 * up event listeners on the socket and sends the client the initial
	 * networking data required to allow network commands to operate
	 * correctly over the connection.
	 * @param {Object} socket The client socket object.
	 * @private
	 */
	_onClientConnect: function (socket) {
		var self = this;

		if (this._acceptConnections) {
			// Check if any listener cancels this
			if (!this.emit('connect', socket)) {
				this.log('Accepted connection with id ' + socket.id);
				this._socketById[socket.id] = socket;
				
				// Store a rooms array for this client
				this._clientRooms[socket.id] = this._clientRooms[socket.id] || [];

				socket.on('message', function (data) {
					self._onClientMessage.apply(self, [data, socket.id]);
				});

				socket.on('disconnect', function (data) {
					self._onClientDisconnect.apply(self, [data, socket]);
				});

				// Send an init message to the client
				socket.send({
					cmd: 'init',
					ncmds: this._networkCommandsLookup,
					ts: ige._timeScale,
					ct: ige._currentTime
				});

				// Send a clock sync command
				this._sendTimeSync(undefined, socket.id);
			} else {
				// Reject the connection
				socket.close();
			}
		} else {
			this.log('Rejecting connection with id ' + socket.id + ' - we are not accepting connections at the moment!');
			socket.close();
		}
	},

	/**
	 * Called when the server receives a network message from a client.
	 * @param {Object} data The data sent by the client.
	 * @param {String} clientId The client socket id.
	 * @private
	 */
	_onClientMessage: function (data, clientId) {
		var ciDecoded = data[0].charCodeAt(0),
			commandName = this._networkCommandsIndex[ciDecoded];

		if (this._networkCommands[commandName]) {
			this._networkCommands[commandName](data[1], clientId);
		}

		this.emit(commandName, [data[1], clientId]);
	},
	
	_onRequest: function (data, clientId) {
		// The message is a network request so fire
		// the command event with the request id and
		// the request data
		data.clientId = clientId;
		this._requests[data.id] = data;

		if (this.debug()) {
			console.log('onRequest', data);
			console.log('emitting', data.cmd, [data.id, data.data]);
			this._debugCounter++;
		}

		if (this._networkCommands[data.cmd]) {
			this._networkCommands[data.cmd](data.data, clientId, data.id);
		}

		this.emit(data.cmd, [data.id, data.data, clientId]);
	},

	_onResponse: function (data, clientId) {
		// The message is a network response
		// to a request we sent earlier
		id = data.id;

		// Get the original request object from
		// the request id
		req = this._requests[id];

		if (this.debug()) {
			console.log('onResponse', data);
			this._debugCounter++;
		}

		if (req) {
			// Fire the request callback!
			req.callback(req.cmd, [data.data, clientId]);

			// Delete the request from memory
			delete this._requests[id];
		}
	},

	/**
	 * Called when a client disconnects from the server.
	 * @param {Object} data Any data sent along with the disconnect.
	 * @param {Object} socket The client socket object.
	 * @private
	 */
	_onClientDisconnect: function (data, socket) {
		this.log('Client disconnected with id ' + socket.id);
		this.emit('disconnect', socket.id);
		
		// Remove them from all rooms
		this.clientLeaveAllRooms(socket.id);

		delete this._socketById[socket.id];
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeNetIoServer; }
;var IgeNetIoComponent = IgeEventingClass.extend([
	{extension: IgeTimeSyncExtension, overwrite: false}
], {
	classId: 'IgeNetIoComponent',
	componentId: 'network',

	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Setup the network commands storage
		this._networkCommands = {};
		this._networkCommandsIndex = [];
		this._networkCommandsLookup = {};

		// Set some defaults
		this._port = 8000;
		this._debug = false;
		this._debugCounter = 0;
		this._debugMax = 0;
		this._clientRooms = {};

		// Time sync defaults
		this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default
		this._timeSyncLog = {};
		this._latency = 0;

		

		if (ige.isClient) {
			this._netio = IgeNetIoClient;
			this.implement(IgeNetIoClient);
		}

		this.log('Network component initiated with Net.IO version: ' + this._netio.version);
	},

	/**
	 * Gets / sets debug flag that determines if debug output
	 * is logged to the console.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this._entity;
		}

		// Check the debug counter settings
		if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {
			this._debug = false;
			this._debugCounter = 0;
		}

		return this._debug;
	},

	/**
	 * Gets / sets the maximum number of debug messages that
	 * should be allowed to be output to the console before
	 * debugging is automatically turned off. This is useful
	 * if you want to sample a certain number of outputs and
	 * then automatically disable output so your console is
	 * not flooded.
	 * @param {Number=} val Number of debug messages to allow
	 * to be output to the console. Set to zero to allow
	 * infinite amounts.
	 * @return {*}
	 */
	debugMax: function (val) {
		if (val !== undefined) {
			this._debugMax = val;
			return this._entity;
		}

		return this._debugMax;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeNetIoComponent; }
;var IgeUiPositionExtension = {
	/**
	 * Gets / sets the entity's x position relative to the left of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	left: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiLeft;
				delete this._uiLeftPercent;
			} else {
				delete this._uiCenter;
				delete this._uiCenterPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiLeftPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiLeft = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiLeft = px;
					delete this._uiLeftPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiLeft;
	},
	
	/**
	 * Gets / sets the entity's x position relative to the right of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	right: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiRight;
				delete this._uiRightPercent;
			} else {
				delete this._uiCenter;
				delete this._uiCenterPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiRightPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiRight = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiRight = px;
					delete this._uiRightPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiRight;
	},

	/**
	 * Gets / sets the viewport's x position relative to the center of
	 * the entity parent.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	center: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiCenter;
				delete this._uiCenterPercent;
			} else {
				delete this._uiLeft;
				delete this._uiLeftPercent;
				delete this._uiRight;
				delete this._uiRightPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiCenterPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x2;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x2;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiCenter = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiCenter = px;
					delete this._uiCenterPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiCenter;
	},

	/**
	 * Gets / sets the entity's y position relative to the top of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	top: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiTop;
				delete this._uiTopPercent;
			} else {
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiTopPercent = px;
					
					// Check if we are already mounted
					var parentHeight,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentHeight = this._parent._bounds2d.y;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentHeight = ige._bounds2d.y;
					}
						
					// Calculate real width from percentage
					newVal = (parentHeight / 100 * val) | 0;
	
					this._uiTop = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiTop = px;
					delete this._uiTopPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiTop;
	},

	/**
	 * Gets / sets the entity's y position relative to the bottom of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	bottom: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiBottom;
				delete this._uiBottomPercent;
			} else {
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiBottomPercent = px;
					
					// Check if we are already mounted
					var parentHeight,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentHeight = this._parent._bounds2d.y;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentHeight = ige._bounds2d.y;
					}
						
					// Calculate real width from percentage
					newVal = (parentHeight / 100 * val) | 0;
	
					this._uiBottom = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiBottom = px;
					delete this._uiBottomPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiBottom;
	},
	
	/**
	 * Gets / sets the viewport's y position relative to the middle of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	middle: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
			} else {
				delete this._uiTop;
				delete this._uiTopPercent;
				delete this._uiBottom;
				delete this._uiBottomPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiMiddlePercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.y2;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.y2;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiMiddle = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiMiddle = px;
					delete this._uiMiddlePercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiMiddle;
	},

	/**
	 * Gets / sets the geometry.x in pixels.
	 * @param {Number, String=} px Either the width in pixels or a percentage
	 * @param {Boolean=} lockAspect
	 * @param {Number=} modifier A value to add to the final width. Useful when
	 * you want to alter a percentage value by a certain number of pixels after
	 * it has been calculated.
	 * @param {Boolean=} noUpdate
	 * @return {*}
	 */
	width: function (px, lockAspect, modifier, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiWidth;
				this._bounds2d.x = 0;
				this._bounds2d.x2 = 0;
			} else {
				this._uiWidth = px;
				this._widthModifier = modifier !== undefined ? modifier : 0;
	
				if (typeof(px) === 'string') {
					if (this._parent) {
						// Percentage
						var parentWidth = this._parent._bounds2d.x,
							val = parseInt(px, 10),
							newVal,
							ratio;
	
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) + this._widthModifier | 0;
	
						if (lockAspect) {
							// Calculate the height from the change in width
							ratio = newVal / this._bounds2d.x;
							this.height(this._bounds2d.y / ratio, false, 0, noUpdate);
						}
	
						this._bounds2d.x = newVal;
						this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						var parentWidth = ige._bounds2d.x,
							val = parseInt(px, 10);
	
						// Calculate real height from percentage
						this._bounds2d.x = (parentWidth / 100 * val) + this._widthModifier | 0;
						this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
					}
				} else {
					if (lockAspect) {
						// Calculate the height from the change in width
						var ratio = px / this._bounds2d.x;
						this.height(this._bounds2d.y * ratio, false, 0, noUpdate);
					}
	
					this._bounds2d.x = px;
					this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
				}
			}

			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._bounds2d.x;
	},

	/**
	 * Gets / sets the geometry.y in pixels.
	 * @param {Number=} px
	 * @param {Boolean=} lockAspect
	 * @param {Number=} modifier A value to add to the final height. Useful when
	 * you want to alter a percentage value by a certain number of pixels after
	 * it has been calculated.
	 * @param {Boolean=} noUpdate
	 * @return {*}
	 */
	height: function (px, lockAspect, modifier, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiHeight;
				this._bounds2d.y = 0;
				this._bounds2d.y2 = 0;
			} else {
				this._uiHeight = px;
				this._heightModifier = modifier !== undefined ? modifier : 0;
	
				if (typeof(px) === 'string') {
					if (this._parent) {
						// Percentage
						var parentHeight = this._parent._bounds2d.y,
							val = parseInt(px, 10),
							newVal,
							ratio;
	
						// Calculate real height from percentage
						// Calculate real width from percentage
						newVal = (parentHeight / 100 * val) + this._heightModifier | 0;
	
						if (lockAspect) {
							// Calculate the height from the change in width
							ratio = newVal / this._bounds2d.y;
							this.width(this._bounds2d.x / ratio, false, 0, noUpdate);
						}
	
						this._bounds2d.y = newVal;
						this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						var parentHeight = ige._bounds2d.y,
							val = parseInt(px, 10);
	
						// Calculate real height from percentage
						this._bounds2d.y = (parentHeight / 100 * val) + this._heightModifier | 0;
						this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
					}
				} else {
					if (lockAspect) {
						// Calculate the height from the change in width
						var ratio = px / this._bounds2d.y;
						this.width(this._bounds2d.x * ratio, false, 0, noUpdate);
					}
	
					this._bounds2d.y = px;
					this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._bounds2d.y;
	},
	
	autoScaleX: function (val, lockAspect) {
		if (val !== undefined) {
			this._autoScaleX = val;
			this._autoScaleLockAspect = lockAspect;

			this._updateUiPosition();
			return this;
		}

		return this._autoScaleX;
	},

	autoScaleY: function (val, lockAspect) {
		if (val !== undefined) {
			this._autoScaleY = val;
			this._autoScaleLockAspect = lockAspect;

			this._updateUiPosition();
			return this;
		}

		return this._autoScaleY;
	},

	/**
	 * Updates the UI position of every child entity down the scenegraph
	 * for this UI entity.
	 * @return {*}
	 */
	updateUiChildren: function () {
		var arr = this._children,
			arrCount,
			arrItem;
		
		if (arr) {
			arrCount = arr.length;
			
			while (arrCount--) {
				arrItem = arr[arrCount];
				if (arrItem._updateUiPosition) {
					arrItem._updateUiPosition();
				}
				
				if (typeof(arrItem.updateUiChildren) === 'function') {
					arrItem.updateUiChildren();
				}
			}
		}
		
		return this;
	},

	/**
	 * Sets the correct translate x and y for the viewport's left, right
	 * top and bottom co-ordinates.
	 * @private
	 */
	_updateUiPosition: function () {
		if (this._parent) {
			var parentGeom = this._parent._bounds2d,
				geomScaled = this._bounds2d.multiplyPoint(this._scale),
				percent,
				newVal,
				ratio;
			
			/*if (this._ignoreCamera && ige._currentCamera) {
				// Handle cam ignore when calculating 
				parentGeom = parentGeom.dividePoint(ige._currentCamera._scale);
			}*/
			
			if (this._autoScaleX) {
				// Get the percentage as an integer
				percent = parseInt(this._autoScaleX, 10);
	
				// Calculate new width from percentage
				newVal = (parentGeom.x / 100 * percent);
	
				// Calculate scale ratio
				ratio = newVal / this._bounds2d.x;
	
				// Set the new scale
				this._scale.x = ratio;
				
				if (this._autoScaleLockAspect) {
					this._scale.y = ratio;
				}
			}

			if (this._autoScaleY) {
				// Get the percentage as an integer
				percent = parseInt(this._autoScaleY, 10);

				// Calculate new height from percentage
				newVal = (parentGeom.y / 100 * percent);

				// Calculate scale ratio
				ratio = newVal / this._bounds2d.y;

				// Set the new scale
				this._scale.y = ratio;

				if (this._autoScaleLockAspect) {
					this._scale.x = ratio;
				}
			}

			if (this._uiWidth) { this.width(this._uiWidth, false, this._widthModifier, true); }
			if (this._uiHeight) { this.height(this._uiHeight, false, this._heightModifier, true); }
			
			if (this._uiCenterPercent) { this.center(this._uiCenterPercent, true); }
			if (this._uiMiddlePercent) { this.middle(this._uiMiddlePercent, true); }
			if (this._uiLeftPercent) { this.left(this._uiLeftPercent, true); }
			if (this._uiRightPercent) { this.right(this._uiRightPercent, true); }
			if (this._uiTopPercent) { this.top(this._uiTopPercent, true); }
			if (this._uiBottomPercent) { this.bottom(this._uiBottomPercent, true); }
			
			if (this._uiCenter !== undefined) {
				// The element is center-aligned
				this._translate.x = Math.floor(this._uiCenter);
			} else {
				// The element is not center-aligned, process left and right
				if (this._uiLeft !== undefined && this._uiRight !== undefined) {
					// Both left and right values are set, position left and assign width to reach right
					this.width((parentGeom.x) - this._uiLeft - this._uiRight, false, 0, true);
							
					// Update translation
					this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
				} else {
					if (this._uiLeft !== undefined) {
						// Position left aligned
						this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
					}
					
					if (this._uiRight !== undefined) {
						// Position right aligned
						this._translate.x = Math.floor(parentGeom.x2 - geomScaled.x2 - this._uiRight);
					}
				}
			}
			
			if (this._uiMiddle !== undefined) {
				// The element is middle-aligned
				this._translate.y = Math.floor(this._uiMiddle);
			} else {
				// The element is not middle-aligned, process top and bottom
				if (this._uiTop !== undefined && this._uiBottom !== undefined) {
					// Both top and bottom values are set, position top and assign height to reach bottom
					this.height((parentGeom.y) - this._uiTop - this._uiBottom, false, 0, true);
							
					// Update translation
					this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
				} else {
					if (this._uiTop !== undefined) {
						// Position top aligned
						this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
					}
					
					if (this._uiBottom !== undefined) {
						// Position bottom aligned
						this._translate.y = Math.floor(parentGeom.y2 - geomScaled.y2 - this._uiBottom);
					}
				}
			}
			
			this.emit('uiUpdate');
			
			this.cacheDirty(true);
		}
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiPositionExtension; };// TODO: Add "overflow" with automatic scroll-bars
var IgeUiStyleExtension = {
	/**
	 * Gets / sets the color to use as the font color.
	 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	color: function (color) {
		if (color !== undefined) {
			this._color = color;
			this.cacheDirty(true);
			return this;
		}

		return this._color;
	},
	
	/**
	 * Sets the current background texture and the repeatType
	 * to determine in which axis the image should be repeated.
	 * @param {IgeTexture=} texture
	 * @param {String=} repeatType Accepts "repeat", "repeat-x",
	 * "repeat-y" and "no-repeat".
	 * @return {*} Returns this if any parameter is specified or
	 * the current background image if no parameters are specified.
	 */
	backgroundImage: function (texture, repeatType) {
		if (texture && texture.image) {
			if (!repeatType) { repeatType = 'no-repeat'; }

			// Store the repeatType
			this._patternRepeat = repeatType;

			// Store the texture
			this._patternTexture = texture;

			// Resize the image if required
			if (this._backgroundSize) {
				texture.resize(this._backgroundSize.x, this._backgroundSize.y);
				this._patternWidth = this._backgroundSize.x;
				this._patternHeight = this._backgroundSize.y;
			} else {
				this._patternWidth = texture.image.width;
				this._patternHeight = texture.image.height;
			}

			if (this._cell > 1) {
				// We are using a cell sheet, render the cell to a
				// temporary canvas and set that as the pattern image
				var canvas = document.createElement('canvas'),
					ctx = canvas.getContext('2d'),
					cellData = texture._cells[this._cell];

				canvas.width = cellData[2];
				canvas.height = cellData[3];

				ctx.drawImage(
					texture.image,
					cellData[0],
					cellData[1],
					cellData[2],
					cellData[3],
					0,
					0,
					cellData[2],
					cellData[3]
				);

				// Create the pattern from the texture cell
				this._patternFill = ige._ctx.createPattern(canvas, repeatType);
			} else {
				// Create the pattern from the texture
				this._patternFill = ige._ctx.createPattern(texture.image, repeatType);
			}

			texture.restoreOriginal();
			this.cacheDirty(true);
			return this;
		}

		return this._patternFill;
	},

	backgroundSize: function (x, y) {
		if (x !== undefined && y !== undefined) {
			if (typeof(x) === 'string') {
				// Work out the actual size in pixels
				// from the percentage
				x = this._bounds2d.x / 100 * parseInt(x, 10);
			}

			if (typeof(y) === 'string') {
				// Work out the actual size in pixels
				// from the percentage
				y = this._bounds2d.y / 100 * parseInt(y, 10);
			}
			
			if (x !== 0 && y !== 0) {
				this._backgroundSize = {x: x, y: y};
	
				// Reset the background image
				if (this._patternTexture && this._patternRepeat) {
					this.backgroundImage(this._patternTexture, this._patternRepeat);
				}
				this.cacheDirty(true);
			} else {
				this.log('Cannot set background to zero-sized x or y!', 'error');
			}
			return this;
		}

		return this._backgroundSize;
	},

	/**
	 * Gets / sets the color to use as a background when
	 * rendering the UI element.
	 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	backgroundColor: function (color) {
		if (color !== undefined) {
			this._backgroundColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._backgroundColor;
	},

	/**
	 * Gets / sets the position to start rendering the background image at.
	 * @param {Number=} x
	 * @param {Number=} y
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	backgroundPosition: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._backgroundPosition = {x: x, y: y};
			this.cacheDirty(true);
			return this;
		}

		return this._backgroundPosition;
	},

	borderColor: function (color) {
		if (color !== undefined) {
			this._borderColor = color;
			this._borderLeftColor = color;
			this._borderTopColor = color;
			this._borderRightColor = color;
			this._borderBottomColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderColor;
	},

	borderLeftColor: function (color) {
		if (color !== undefined) {
			this._borderLeftColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderLeftColor;
	},

	borderTopColor: function (color) {
		if (color !== undefined) {
			this._borderTopColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderTopColor;
	},

	borderRightColor: function (color) {
		if (color !== undefined) {
			this._borderRightColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderRightColor;
	},

	borderBottomColor: function (color) {
		if (color !== undefined) {
			this._borderBottomColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderBottomColor;
	},

	borderWidth: function (px) {
		if (px !== undefined) {
			this._borderWidth = px;
			this._borderLeftWidth = px;
			this._borderTopWidth = px;
			this._borderRightWidth = px;
			this._borderBottomWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderWidth;
	},

	borderLeftWidth: function (px) {
		if (px !== undefined) {
			this._borderLeftWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderLeftWidth;
	},

	borderTopWidth: function (px) {
		if (px !== undefined) {
			this._borderTopWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderTopWidth;
	},

	borderRightWidth: function (px) {
		if (px !== undefined) {
			this._borderRightWidth = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderRightWidth;
	},

	borderBottomWidth: function (px) {
		if (px !== undefined) {
			this._borderBottomWidth = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderBottomWidth;
	},

	borderRadius: function (px) {
		if (px !== undefined) {
			this._borderRadius = px;
			this._borderTopLeftRadius = px;
			this._borderTopRightRadius = px;
			this._borderBottomRightRadius = px;
			this._borderBottomLeftRadius = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderRadius;
	},

	padding: function (left, top, right, bottom) {
		this._paddingLeft = left;
		this._paddingTop = top;
		this._paddingRight = right;
		this._paddingBottom = bottom;

		this.cacheDirty(true);
		return this;
	},

	paddingLeft: function (px) {
		if (px !== undefined) {
			this._paddingLeft = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingLeft;
	},

	paddingTop: function (px) {
		if (px !== undefined) {
			this._paddingTop = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingTop;
	},

	paddingRight: function (px) {
		if (px !== undefined) {
			this._paddingRight = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingRight;
	},

	paddingBottom: function (px) {
		if (px !== undefined) {
			this._paddingBottom = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingBottom;
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiStyleExtension; };var nullMethod = function () {},
	IgeDummyContext = {
		dummy: true,
		save: nullMethod,
		restore: nullMethod,
		translate: nullMethod,
		rotate: nullMethod,
		scale: nullMethod,
		drawImage: nullMethod,
		fillRect: nullMethod,
		strokeRect: nullMethod,
		stroke: nullMethod,
		fill: nullMethod,
		rect: nullMethod,
		moveTo: nullMethod,
		lineTo: nullMethod,
		arc: nullMethod,
		clearRect: nullMethod,
		beginPath: nullMethod,
		clip: nullMethod,
		transform: nullMethod,
		setTransform: nullMethod,
		fillText: nullMethod
	};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeDummyContext; };/**
 * Creates a new tween instance.
 */
var IgeTween = IgeClass.extend({
	classId: 'IgeTween',

	init: function (targetObj, propertyObj, durationMs, options) {
		// Create a new tween object and return it
		// so the user can decide when to start it
		this._targetObj = targetObj;
		this._steps = [];
		this._currentStep = -1;
		if (propertyObj !== undefined) {
			this.stepTo(propertyObj);
		}
		this._durationMs = durationMs !== undefined ? durationMs : 0;
		this._started = false;
		this._stepDirection = false;

		// Sort out the options
		if (options && options.easing) { this.easing(options.easing); } else { this.easing('none'); }
		if (options && options.startTime !== undefined) { this.startTime(options.startTime); }
		if (options && options.beforeTween !== undefined) { this.beforeTween(options.beforeTween); }
		if (options && options.afterTween !== undefined) { this.afterTween(options.afterTween); }
	},

	/**
	 * Sets the object in which the properties to tween exist.
	 * @param targetObj
	 * @return {*}
	 */
	targetObj: function (targetObj) {
		if (targetObj !== undefined) {
			this._targetObj = targetObj;
		}

		return this;
	},

	/**
	 * Sets the tween's target properties to tween to.
	 * @param propertyObj
	 * @return {*}
	 */
	properties: function (propertyObj) {
		if (propertyObj !== undefined) {
			// Reset any existing steps and add this new one
			this._steps = [];
			this._currentStep = -1;
			this.stepTo(propertyObj);
		}

		return this;
	},

	/**
	 * Gets / sets the repeat mode for the tween. If the mode
	 * is set to 1 the tween will repeat from the first step.
	 * If set to 2 the tween will reverse the order of the steps
	 * each time the repeat occurs. The count determines the
	 * number of times the tween will be repeated before stopping.
	 * Setting the count to -1 will make it repeat infinitely.
	 * @param val
	 * @param count
	 * @return {*}
	 */
	repeatMode: function (val, count) {
		if (val !== undefined) {
			this._repeatMode = val;
			this.repeatCount(count);
			return this;
		}

		return this._repeatMode;
	},

	/**
	 * Gets / sets the repeat count. The count determines the
	 * number of times the tween will be repeated before stopping.
	 * Setting the count to -1 will make it repeat infinitely.
	 * This setting is used in conjunction with the repeatMode()
	 * method. If you just set a repeat count and no mode then
	 * the tween will not repeat.
	 * @param val
	 * @return {*}
	 */
	repeatCount: function (val) {
		if (val !== undefined) {
			this._repeatCount = val;
			this._repeatedCount = 0;
			return this;
		}

		return this._repeatCount;
	},

	/**
	 * DEPRECIATED, Renamed to stepTo().
	 */
	step: function (propertyObj, durationMs, easing) {
		this.log('The step method has been renamed to stepTo(). Please update your code as the step() method will soon be removed.', 'warning');
		this.stepTo(propertyObj, durationMs, easing);
		return this;
	},

	/**
	 * Defines a step in a multi-stage tween. Uses the properties
	 * as destination value.
	 * @param {Object} propertyObj The properties to
	 * tween during this step.
	 * @param {Number=} durationMs The number of milliseconds
	 * to spend tweening this step, or if not provided uses
	 * the current tween durationMs setting.
	 * @param {String=} easing The name of the easing method
	 * to use during this step.
	 * @param {Boolean=} delta If true will set the step to use
	 * delta values instead of absolute values as the destination.
	 * @return {*}
	 */
	stepTo: function (propertyObj, durationMs, easing, delta) {
		if (propertyObj !== undefined) {
			// Check if we have already been given a standard
			// non-staged property
			this._steps.push({
				props: propertyObj,
				durationMs: durationMs,
				easing: easing,
				isDelta: delta
			});
		}

		return this;
	},
	
	/**
	 * Defines a step in a multi-stage tween. Uses the properties
	 * as deltas, not as destination values
	 * @param {Object} propertyObj The properties to
	 * tween during this step.
	 * @param {Number=} durationMs The number of milliseconds
	 * to spend tweening this step, or if not provided uses
	 * the current tween durationMs setting.
	 * @param {String=} easing The name of the easing method
	 * to use during this step.
	 * @return {*}
	 */
	stepBy: function (propertyObj, durationMs, easing) {
		this.stepTo(
			propertyObj,
			durationMs,
			easing,
			true
		);
		
		return this;
	},

	/**
	 * Sets the duration of the tween in milliseconds.
	 * @param durationMs
	 * @return {*}
	 */
	duration: function (durationMs) {
		if (durationMs !== undefined) {
			this._durationMs = durationMs;
		}

		return this;
	},

	/**
	 * Sets the method to be called just before the tween has started.
	 * @param callback
	 * @return {*}
	 */
	beforeTween: function (callback) {
		if (callback !== undefined) {
			this._beforeTween = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after the tween has ended.
	 * @param callback
	 * @return {*}
	 */
	afterTween: function (callback) {
		if (callback !== undefined) {
			this._afterTween = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just before a tween step has
	 * started.
	 * @param callback
	 * @return {*}
	 */
	beforeStep: function (callback) {
		if (callback !== undefined) {
			this._beforeStep = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after a tween step has
	 * ended.
	 * @param callback
	 * @return {*}
	 */
	afterStep: function (callback) {
		if (callback !== undefined) {
			this._afterStep = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after a tween has changed
	 * the values of the target object every update tick.
	 * @param callback
	 * @return {*}
	 */
	afterChange: function (callback) {
		if (callback !== undefined) {
			this._afterChange = callback;
		}

		return this;
	},

	/**
	 * Returns the object that this tween is modifying.
	 * @return {*}
	 */
	targetObject: function () {
		return this._targetObj;
	},

	/**
	 * Sets the name of the easing method to use with the tween.
	 * @param methodName
	 * @return {*}
	 */
	easing: function (methodName) {
		if (methodName !== undefined) {
			if (ige.tween.easing[methodName]) {
				this._easing = methodName;
			} else {
				this.log('The easing method you have selected does not exist, please use a valid easing method. For a list of easing methods please inspect ige.tween.easing from your console.', 'error', ige.tween.easing);
			}
		}

		return this;
	},

	/**
	 * Sets the timestamp at which the tween should start.
	 * @param timeMs
	 * @return {*}
	 */
	startTime: function (timeMs) {
		if (timeMs !== undefined) {
			this._startTime = timeMs;
		}

		return this;
	},

	/**
	 * Starts the tweening operation.
	 * @param {Number=} timeMs If set, the tween will start this
	 * many milliseconds in the future.
	 */
	start: function (timeMs) {
		if (timeMs !== undefined) {
			this.startTime(timeMs + ige._currentTime);
		}
		
		ige.tween.start(this);

		// Add the tween to the target object's tween array
		this._targetObj._tweenArr = this._targetObj._tweenArr || [];
		this._targetObj._tweenArr.push(this);

		return this;
	},

	/**
	 * Stops the tweening operation.
	 */
	stop: function () {
		ige.tween.stop(this);
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.pull(this);
		}

		return this;
	},

	/**
	 * Starts all tweens registered to an object.
	 * @private
	 */
	startAll: function () {
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.eachReverse(function (tweenItem) {
				tweenItem.start();
			});
		}

		return this;
	},

	/**
	 * Stops all tweens registered to an object.
	 * @private
	 */
	stopAll: function () {
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.eachReverse(function (tweenItem) {
				tweenItem.stop();
			});
		}

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTween; };/**
 * Creates a new texture.
 */
var IgeTexture = IgeEventingClass.extend({
	classId: 'IgeTexture',
	IgeTexture: true,

	/**
	 * Constructor for a new IgeTexture.
	 * @param {String, Object} urlOrObject Either a string URL that
	 * points to the path of the image or script you wish to use as
	 * the texture image, or an object containing a smart texture.
	 * @return {*}
	 */
	init: function (urlOrObject) {
		this._loaded = false;
		
		

		// Create an array that is used to store cell dimensions
		this._cells = [];
		this._smoothing = ige.igeRendering._globalSmoothing;

		// Stores the SVG XML data so we can modify later
		// This is undefined unless the texture is a SVG
		this.svgXML = undefined;
		
		// Instantiate filter lists for filter combinations
		this._applyFilters = [];
		this._applyFiltersData = [];
		this._preFilters = [];
		this._preFiltersData = [];

		var type = typeof(urlOrObject);

		if (type === 'string') {
			// Load the texture URL
			if (urlOrObject) {
				this.url(urlOrObject);
			}
		}

		if (type === 'object') {
			// Assign the texture script object
			this.assignSmartTextureImage(urlOrObject);
		}
	},

	/**
	 * Gets / sets the current object id. If no id is currently assigned and no
	 * id is passed to the method, it will automatically generate and assign a
	 * new id as a 16 character hexadecimal value typed as a string.
	 * @param {String=} id
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	id: function (id) {
		if (id !== undefined) {
			// Check if this ID already exists in the object register
			if (ige._register[id]) {
				if (ige._register[id] === this) {
					// We are already registered as this id
					return this;
				}
				
				// Already an object with this ID!
				this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
			} else {
				// Check if we already have an id assigned
				if (this._id && ige._register[this._id]) {
					// Unregister the old ID before setting this new one
					ige.unRegister(this);
				}

				this._id = id;

				// Now register this object with the object register
				ige.register(this);

				return this;
			}
		}

		if (!this._id) {
			// The item has no id so generate one automatically
			if (this._url) {
				// Generate an ID from the URL string of the image
				// this texture is using. Useful for always reproducing
				// the same ID for the same texture :)
				this._id = ige.newIdFromString(this._url);
			} else {
				// We don't have a URL so generate a random ID
				this._id = ige.newIdHex();
			}
			ige.register(this);
		}

		return this._id;
	},

	/**
	 * Gets / sets the source file for this texture.
	 * @param {String=} url "The url used to load the file for this texture.
	 * @return {*}
	 */
	url: function (url) {
		if (url !== undefined) {
			this._url = url;

			if (url.substr(url.length - 2, 2) === 'js') {
				// This is a script-based texture, load the script
				this._loadScript(url);
			}
			else if (url.substr(url.length - 3, 3) === 'svg') {
				// This is an SVG, load the image
				this._loadSvg(url);
			}
			else {
				// This is an image-based texture, load the image
				this._loadImage(url);
			}

			return this;
		}

		return this._url;
	},

	/**
	 * Loads an image into an img tag and sets an onload event
	 * to capture when the image has finished loading.
	 * @param {String} imageUrl The image url used to load the
	 * image data.
	 * @private
	 */
	_loadImage: function (imageUrl) {
		var image,
			self = this;

		if (ige.isClient) {
			// Increment the texture load count
			ige.textureLoadStart(imageUrl, this);

			// Check if the image url already exists in the image cache
			if (!ige._textureImageStore[imageUrl]) {
				// Image not in cache, create the image object
				image = ige._textureImageStore[imageUrl] = this.image = this._originalImage = new Image();
				image._igeTextures = image._igeTextures || [];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				image.onload = function () {
					// Mark the image as loaded
					image._loaded = true;

					// Log success
					ige.log('Texture image (' + imageUrl + ') loaded successfully');

					/*if (image.width % 2) {
						self.log('The texture ' + imageUrl + ' width (' + image.width + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture width is divisible by 2!', 'warning');
					}

					if (image.height % 2) {
						self.log('The texture ' + imageUrl + ' height (' + image.height + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture height is divisible by 2!', 'warning');
					}*/

					// Loop textures that are using this image
					var arr = image._igeTextures,
						arrCount = arr.length, i,
						item;

					for (i = 0; i < arrCount; i++) {
						item = arr[i];

						item._mode = 0;

						item.sizeX(image.width);
						item.sizeY(image.height);

						item._cells[1] = [0, 0, item._sizeX, item._sizeY];
						
						// Mark texture as loaded
						item._textureLoaded();
					}
				};

				// Start the image loading by setting the source url
				image.src = imageUrl;
			} else {
				// Grab the cached image object
				image = this.image = this._originalImage = ige._textureImageStore[imageUrl];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				if (image._loaded) {
					// The cached image object is already loaded so
					// fire off the relevant events
					self._mode = 0;

					self.sizeX(image.width);
					self.sizeY(image.height);

					if (image.width % 2) {
						this.log('This texture\'s width is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					if (image.height % 2) {
						this.log('This texture\'s height is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					self._cells[1] = [0, 0, self._sizeX, self._sizeY];
					
					// Mark texture as loaded
					self._textureLoaded();
				}
			}
		}
	},

	/**
	 * Loads a SVG into an img tag, stores the SVG's XML so it can be modified
	 * later, and sets an onload event to capture when the image has finished
	 * loading.
	 * @param {String} imageUrl The image url used to load the image data.
	 * @private
	 */
	_loadSvg: function (imageUrl) {
		var image,
			self = this;

		if (ige.isClient) {
			// Increment the texture load count
			ige.textureLoadStart(imageUrl, this);

			// Check if the image url already exists in the image cache
			if (!ige._textureImageStore[imageUrl]) {
				// Image not in cache, create the image object
				image = ige._textureImageStore[imageUrl] = this.image = this._originalImage = new Image();
				image._igeTextures = image._igeTextures || [];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				// Ask the server for the SVG
				var request = new XMLHttpRequest();
				request.onreadystatechange = function() {
					if (request.readyState === 4) {
						if (request.status === 200) {
							// Save SVG XML data for later modification
							self.svgXML = request.responseText;
							// Convert the SVG XML into a data URI
							var imageSrc = 'data:image/svg+xml;base64,' + btoa(self.svgXML);

							// Load the image
							image.onload = function () {
								// Mark the image as loaded
								image._loaded = true;

								// Log success
								ige.log('Texture image (' + imageUrl + ') loaded successfully');

								// Loop textures that are using this image
								var arr = image._igeTextures,
									arrCount = arr.length, i,
									item;

								for (i = 0; i < arrCount; i++) {
									item = arr[i];

									item._mode = 0;

									item.sizeX(image.width);
									item.sizeY(image.height);

									item._cells[1] = [0, 0, item._sizeX, item._sizeY];

									// Mark texture as loaded
									item._textureLoaded();
								}
							};

							// Start the image loading by setting the source url
							image.src = imageSrc;
						}
						else {
							console.error("Received status code " + request.status + " when trying to load textures from server.");
						}
					}
				};

				request.open('GET', imageUrl, true);
				request.send();
			} else {
				// Grab the cached image object
				image = this.image = this._originalImage = ige._textureImageStore[imageUrl];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				if (image._loaded) {
					// The cached image object is already loaded so
					// fire off the relevant events
					self._mode = 0;

					self.sizeX(image.width);
					self.sizeY(image.height);

					if (image.width % 2) {
						this.log('This texture\'s width is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					if (image.height % 2) {
						this.log('This texture\'s height is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					self._cells[1] = [0, 0, self._sizeX, self._sizeY];

					// Mark texture as loaded
					self._textureLoaded();
				}
			}
		}
	},

	_textureLoaded: function () {
		var self = this;
		
		// Set a timeout here so that when this event is emitted,
		// the code creating the texture is given a chance to
		// set a listener first, otherwise this will be emitted
		// but nothing will have time to register a listener!
		setTimeout(function () {
			self._loaded = true;
			self.emit('loaded');

			// Inform the engine that this image has loaded
			ige.textureLoadEnd(self.image.src, self);
		}, 5);
	},

	/**
	 * Loads a render script into a script tag and sets an onload
	 * event to capture when the script has finished loading.
	 * @param {String} scriptUrl The script url used to load the
	 * script data.
	 * @private
	 */
	_loadScript: function (scriptUrl) {
		var textures = ige.textures,
			rs_sandboxContext,
			self = this,
			scriptElem;

		ige.textureLoadStart(scriptUrl, this);

		if (ige.isClient) {
			scriptElem = document.createElement('script');
			scriptElem.onload = function(data) {
				self.log('Texture script "' + scriptUrl + '" loaded successfully');
				// Parse the JS with evil eval and store the result in the asset
				eval(data);

				// Store the eval data (the "image" variable is declared
				// by the texture script and becomes available in this scope
				// because we evaluated it above)
				self._mode = 1;
				self.script = image;

				// Run the asset script init method
				if (typeof(image.init) === 'function') {
					image.init.apply(image, [self]);
				}

				//self.sizeX(image.width);
				//self.sizeY(image.height);

				self._loaded = true;
				self.emit('loaded');
				ige.textureLoadEnd(scriptUrl, self);
			};

			scriptElem.addEventListener('error', function () {
				self.log('Error loading smart texture script file: ' + scriptUrl, 'error');
			}, true);

			scriptElem.src = scriptUrl;
			document.getElementsByTagName('head')[0].appendChild(scriptElem);
		}
	},

	/**
	 * Assigns a render script to the smart texture.
	 * @param {String} scriptObj The script object.
	 * @private
	 */
	assignSmartTextureImage: function (scriptObj) {
		var textures = ige.textures,
			rs_sandboxContext,
			self = this,
			scriptElem;
		
		// Check the object has a render method
		if (typeof(scriptObj.render) === 'function') {
			//ige.textureLoadStart(scriptUrl, this);
	
			// Store the script data
			self._mode = 1;
			self.script = scriptObj;
	
			// Run the asset script init method
			if (typeof(scriptObj.init) === 'function') {
				scriptObj.init.apply(scriptObj, [self]);
			}
	
			//self.sizeX(image.width);
			//self.sizeY(image.height);
	
			self._loaded = true;
			self.emit('loaded');
			//ige.textureLoadEnd(scriptUrl, self);
		} else {
			this.log('Cannot assign smart texture because it doesn\'t have a render() method!', 'error');
		}
	},

	/**
	 * Sets the image element that the IgeTexture will use when
	 * rendering. This is a special method not designed to be called
	 * directly by any game code and is used specifically when
	 * assigning an existing canvas element to an IgeTexture.
	 * @param {Image} imageElement The canvas / image to use as
	 * the image data for the IgeTexture.
	 * @private
	 */
	_setImage: function (imageElement) {
		var image,
			self = this;

		if (ige.isClient) {
			// Create the image object
			image = this.image = this._originalImage = imageElement;
			image._igeTextures = image._igeTextures || [];

			// Mark the image as loaded
			image._loaded = true;

			this._mode = 0;

			this.sizeX(image.width);
			this.sizeY(image.height);

			this._cells[1] = [0, 0, this._sizeX, this._sizeY];
		}
	},

	/**
	 * Creates a new texture from a cell in the existing texture
	 * and returns the new texture.
	 * @param {Number, String} indexOrId The cell index or id to use.
	 * @return {*}
	 */
	textureFromCell: function (indexOrId) {
		var tex = new IgeTexture(),
			self = this;

		if (this._loaded) {
			this._textureFromCell(tex, indexOrId);
		} else {
			// The texture has not yet loaded, return the new texture and set a listener to handle
			// when this texture has loaded so we can assign the texture's image properly
			this.on('loaded', function () {
				self._textureFromCell(tex, indexOrId);
			})
		}

		return tex;
	},

	/**
	 * Called by textureFromCell() when the texture is ready
	 * to be processed. See textureFromCell() for description.
	 * @param {IgeTexture} tex The new texture to paint to.
	 * @param {Number, String} indexOrId The cell index or id
	 * to use.
	 * @private
	 */
	_textureFromCell: function (tex, indexOrId) {
		var index,
			cell,
			canvas,
			ctx;

		if (typeof(indexOrId) === 'string') {
			index = this.cellIdToIndex(indexOrId);
		} else {
			index = indexOrId;
		}

		if (this._cells[index]) {
			// Create a new IgeTexture, then draw the existing cell
			// to it's internal canvas
			cell = this._cells[index];
			canvas = document.createElement('canvas');
			ctx = canvas.getContext('2d');

			// Set smoothing mode
			// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
			// TODO: track of the value and evaluate first before changing?
			if (!this._smoothing) {
				ctx.imageSmoothingEnabled = false;
				ctx.webkitImageSmoothingEnabled = false;
				ctx.mozImageSmoothingEnabled = false;
			} else {
				ctx.imageSmoothingEnabled = true;
				ctx.webkitImageSmoothingEnabled = true;
				ctx.mozImageSmoothingEnabled = true;
			}

			canvas.width = cell[2];
			canvas.height = cell[3];

			// Draw the cell to the canvas
			ctx.drawImage(
				this._originalImage,
				cell[0],
				cell[1],
				cell[2],
				cell[3],
				0,
				0,
				cell[2],
				cell[3]
			);

			// Set the new texture's image to the canvas
			tex._setImage(canvas);
			tex._loaded = true;

			// Fire the loaded event
			setTimeout(function () {
				tex.emit('loaded');
			}, 1);
		} else {
			this.log('Unable to create new texture from passed cell index (' + indexOrId + ') because the cell does not exist!', 'warning');
		}
	},

	/**
	 * Sets the _sizeX property.
	 * @param {Number} val
	 */
	sizeX: function (val) {
		this._sizeX = val;
	},

	/**
	 * Sets the _sizeY property.
	 * @param {Number} val
	 */
	sizeY: function (val) {
		this._sizeY = val;
	},

	/**
	 * Resizes the original texture image to a new size. This alters
	 * the image that the texture renders so all entities that use
	 * this texture will output the newly resized version of the image.
	 * @param {Number} x The new width.
	 * @param {Number} y The new height.
	 * @param {Boolean=} dontDraw If true the resized image will not be
	 * drawn to the texture canvas. Useful for just resizing the texture
	 * canvas and not the output image. Use in conjunction with the
	 * applyFilter() and preFilter() methods.
	 */
	resize: function (x, y, dontDraw) {
		if (this._originalImage) {
			if (this._loaded) {
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');
				}

				this._textureCanvas.width = x;
				this._textureCanvas.height = y;
				this._textureCtx = this._textureCanvas.getContext('2d');

				// Set smoothing mode
				if (!this._smoothing) {
					this._textureCtx.imageSmoothingEnabled = false;
					this._textureCtx.webkitImageSmoothingEnabled = false;
					this._textureCtx.mozImageSmoothingEnabled = false;
				} else {
					this._textureCtx.imageSmoothingEnabled = true;
					this._textureCtx.webkitImageSmoothingEnabled = true;
					this._textureCtx.mozImageSmoothingEnabled = true;
				}

				if (!dontDraw) {
					// Draw the original image to the new canvas
					// scaled as required
					this._textureCtx.drawImage(
						this._originalImage,
						0,
						0,
						this._originalImage.width,
						this._originalImage.height,
						0,
						0,
						x,
						y
					);
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;
			} else {
				this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
			}
		}
	},

	/**
	 * Resizes the original texture image to a new size based on percentage.
	 * This alters the image that the texture renders so all entities that use
	 * this texture will output the newly resized version of the image.
	 * @param {Number} x The new width.
	 * @param {Number} y The new height.
	 * @param {Boolean=} dontDraw If true the resized image will not be
	 * drawn to the texture canvas. Useful for just resizing the texture
	 * canvas and not the output image. Use in conjunction with the
	 * applyFilter() and preFilter() methods.
	 */
	resizeByPercent: function (x, y, dontDraw) {
		if (this._originalImage) {
			if (this._loaded) {
				// Calc final x/y values
				x = Math.floor((this.image.width / 100) * x);
				y = Math.floor((this.image.height / 100) * y);

				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');
				}

				this._textureCanvas.width = x;
				this._textureCanvas.height = y;
				this._textureCtx = this._textureCanvas.getContext('2d');

				// Set smoothing mode
				if (!this._smoothing) {
					this._textureCtx.imageSmoothingEnabled = false;
					this._textureCtx.webkitImageSmoothingEnabled = false;
					this._textureCtx.mozImageSmoothingEnabled = false;
				} else {
					this._textureCtx.imageSmoothingEnabled = true;
					this._textureCtx.webkitImageSmoothingEnabled = true;
					this._textureCtx.mozImageSmoothingEnabled = true;
				}

				if (!dontDraw) {
					// Draw the original image to the new canvas
					// scaled as required
					this._textureCtx.drawImage(
						this._originalImage,
						0,
						0,
						this._originalImage.width,
						this._originalImage.height,
						0,
						0,
						x,
						y
					);
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;
			} else {
				this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
			}
		}
	},

	/**
	 * Sets the texture image back to the original image that the
	 * texture first loaded. Useful if you have applied filters
	 * or resized the image and now want to revert back to the
	 * original.
	 */
	restoreOriginal: function () {
		this.image = this._originalImage;
		delete this._textureCtx;
		delete this._textureCanvas;
		
		this.removeFilters();
	},

	smoothing: function (val) {
		if (val !== undefined) {
			this._smoothing = val;
			return this;
		}

		return this._smoothing;
	},

	/**
	 * Renders the texture image to the passed canvas context.
	 * @param {CanvasRenderingContext2d} ctx The canvas context to draw to.
	 * @param {IgeEntity} entity The entity that this texture is
	 * being drawn for.
	 */
	render: function (ctx, entity) {
		// Check that the cell is not set to null. If it is then
		// we don't render anything which effectively makes the
		// entity "blank"
		if (entity.cell() !== null) {
			// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
			// TODO: track of the value and evaluate first before changing?
			if (!this._smoothing) {
				ige._ctx.imageSmoothingEnabled = false;
				ige._ctx.webkitImageSmoothingEnabled = false;
				ige._ctx.mozImageSmoothingEnabled = false;
			} else {
				ige._ctx.imageSmoothingEnabled = true;
				ige._ctx.webkitImageSmoothingEnabled = true;
				ige._ctx.mozImageSmoothingEnabled = true;
			}

			if (this._mode === 0) {
				// This texture is image-based
				var cell = this._cells[entity.cell()],
					geom = entity._bounds2d,
					poly = entity.renderable._renderPos; // Render pos is calculated in the IgeEntity.aabb() method

				if (cell) {
					if (this._preFilters.length > 0 && this._textureCtx) {
						// Call the drawing of the original image
						this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
						this._textureCtx.drawImage(this._originalImage, 0, 0);
						
						var self = this;
						// Call the applyFilter and preFilter methods one by one
						this._applyFilters.forEach(function(method, index) {
							self._textureCtx.save();
							method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
							self._textureCtx.restore();
						});
						this._preFilters.forEach(function(method, index) {
							self._textureCtx.save();
							method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._preFiltersData[index]);
							self._textureCtx.restore();
						});
					}

					ctx.drawImage(
						this.image,
						cell[0], // texture x
						cell[1], // texture y
						cell[2], // texture width
						cell[3], // texture height
						poly.x, // render x
						poly.y, // render y
						geom.x, // render width
						geom.y // render height
					);

					ige._drawCount++;
				} else {
					this.log('Cannot render texture using cell ' + entity.cell() + ' because the cell does not exist in the assigned texture!', 'error');
				}
			}

			if (this._mode === 1) {
				// This texture is script-based (a "smart texture")
				ctx.save();
					this.script.render(ctx, entity, this);
				ctx.restore();

				ige._drawCount++;
			}
		}
	},
	
	/**
	 * Removes a certain filter from the texture
	 * Useful if you want to keep resizings, etc. 
	 */
	removeFilter: function(method) {
		var i;
		while ((i = this._preFilters.indexOf(method)) > -1) {
			this._preFilters[i] = undefined;
			this._preFiltersData[i] = undefined;
		}
		while ((i = this._applyFilters.indexOf(method)) > -1) {
			this._applyFilters[i] = undefined;
			this._applyFiltersData[i] = undefined;
		}
		this._preFilters = this._preFilters.clean();
		this._preFiltersData = this._preFiltersData.clean();
		this._applyFilters = this._applyFilters.clean();
		this._applyFiltersData = this._applyFiltersData.clean();
		
		this._rerenderFilters();
	},
	
	/**
	 * Removes all filters on the texture
	 * Useful if you want to keep resizings, etc. 
	 */
	removeFilters: function() {
		this._applyFilters = [];
		this._applyFiltersData = [];
		this._preFilters = [];
		this._preFiltersData = [];
		
		this._rerenderFilters();
	},
	
	/**
	 * Rerenders image with filter list. Keeps sizings.
	 * Useful if you have no preFilters
	 */
	_rerenderFilters: function() {
		if (!this._textureCanvas) return;
		// Rerender applyFilters from scratch:
		// Draw the basic image
		// resize it to the old boundaries
		this.resize(this._textureCanvas.width, this._textureCanvas.height, false);
		// Draw applyFilter layers upon it
		var self = this;
		this._applyFilters.forEach(function(method, index) {
			self._textureCtx.save();
			method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
			self._textureCtx.restore();
		});
	},

	/**
	 * Gets / sets the pre-filter method that will be called before
	 * the texture is rendered and will allow you to modify the texture
	 * image before rendering each tick.
	 * @param method
	 * @return {*}
	 */
	preFilter: function (method, data) {
		if (method !== undefined) {
			if (this._originalImage) {
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');

					this._textureCanvas.width = this._originalImage.width;
					this._textureCanvas.height = this._originalImage.height;
					this._textureCtx = this._textureCanvas.getContext('2d');

					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.webkitImageSmoothingEnabled = false;
						this._textureCtx.mozImageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.webkitImageSmoothingEnabled = true;
						this._textureCtx.mozImageSmoothingEnabled = true;
					}
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;

				// Save filter in active preFilter list
				this._preFilters[this._preFilters.length] = method;
				this._preFiltersData[this._preFiltersData.length] = !data ? {} : data;
			}
			return this;
		} else {
			this.log('Cannot use pre-filter, no filter method was passed!', 'warning');
		}

		return this._preFilters[this._preFilters.length - 1];
	},

	/**
	 * Applies a filter to the texture. The filter is a method that will
	 * take the canvas, context and originalImage parameters and then
	 * use context calls to alter / paint the context with the texture
	 * and any filter / adjustments that you want to apply.
	 * @param {Function} method
	 * @param {Object=} data
	 * @return {*}
	 */
	applyFilter: function (method, data) {
		if (this._loaded) {
			if (method !== undefined) {
				if (this._originalImage) {
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
	
						this._textureCanvas.width = this._originalImage.width;
						this._textureCanvas.height = this._originalImage.height;
						this._textureCtx = this._textureCanvas.getContext('2d');
						
						// Draw the basic image
						this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
						this._textureCtx.drawImage(this._originalImage, 0, 0);
	
						// Set smoothing mode
						if (!this._smoothing) {
							this._textureCtx.imageSmoothingEnabled = false;
							this._textureCtx.webkitImageSmoothingEnabled = false;
							this._textureCtx.mozImageSmoothingEnabled = false;
						} else {
							this._textureCtx.imageSmoothingEnabled = true;
							this._textureCtx.webkitImageSmoothingEnabled = true;
							this._textureCtx.mozImageSmoothingEnabled = true;
						}
					}
	
					// Swap the current image for this new canvas
					this.image = this._textureCanvas;
	
					// Call the passed method
					if (this._preFilters.length <= 0) {
						this._textureCtx.save();
						method(this._textureCanvas, this._textureCtx, this._originalImage, this, data);
						this._textureCtx.restore();
					}
					
					// Save filter in active applyFiler list
					this._applyFilters[this._applyFilters.length] = method;
					this._applyFiltersData[this._applyFiltersData.length] = !data ? {} : data;
				}
			} else {
				this.log('Cannot apply filter, no filter method was passed!', 'warning');
			}
		} else {
			this.log('Cannot apply filter, the texture you are trying to apply the filter to has not yet loaded!', 'error');
		}

		return this;
	},
	
	/**
	 * Retrieves pixel data from x,y texture coordinate (starts from top-left).
	 * Important: If the texture has a cross-domain url, the image host must allow
	 * cross-origin resource sharing or a security error will be thrown.
	 * Reference: http://blog.chromium.org/2011/07/using-cross-domain-images-in-webgl-and.html
	 * @param  {Number} x
	 * @param  {Number} y
	 * @return {Array} [r,g,b,a] Pixel data.
	 */
	pixelData: function (x, y) {
		if (this._loaded) {
			if (this.image) {
				// Check if the texture is already using a canvas
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');

					this._textureCanvas.width = this.image.width;
					this._textureCanvas.height = this.image.height;
					this._textureCtx = this._textureCanvas.getContext('2d');

					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.webkitImageSmoothingEnabled = false;
						this._textureCtx.mozImageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.webkitImageSmoothingEnabled = true;
						this._textureCtx.mozImageSmoothingEnabled = true;
					}
					
					// Draw the image to the canvas
					this._textureCtx.drawImage(this.image, 0, 0);
				} else {
					this._textureCtx = this._textureCtx;
				}

				return this._textureCtx.getImageData(x, y, 1, 1).data;
			}
		} else {
			this.log('Cannot read pixel data, the texture you are trying to read data from has not yet loaded!', 'error');
		}

		return this;
	},

	/**
	 * Creates a clone of the texture.
	 * @return {IgeTexture} A new, distinct texture with the same attributes
	 * as the one being cloned.
	 */
	clone: function () {
		return this.textureFromCell(1);
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function () {
		var str = "new " + this.classId() + "('" + this._url + "')";

		// Every object has an ID, assign that first
		// We've commented this because ids for textures are actually generated
		// from their asset so will ALWAYS produce the same ID as long as the asset
		// is the same path.
		//str += ".id('" + this.id() + "')";

		// Now get all other properties
		str += this._stringify();

		return str;
	},
	
	_stringify: function () {
		return '';
	},

	/**
	 * Destroys the item.
	 */
	destroy: function () {
		delete this._eventListeners;

		// Remove us from the image store reference array
		if (this.image && this.image._igeTextures) {
			this.image._igeTextures.pull(this);
		}

		// Remove the texture from the texture store
		ige._textureStore.pull(this);

		delete this.image;
		delete this.script;
		delete this._textureCanvas;
		delete this._textureCtx;

		this._destroyed = true;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTexture; }
;/**
 * Creates a new object.
 */
var IgeObject = IgeEventingClass.extend({
	classId: 'IgeObject',

	init: function () {
		this._newBorn = true;
		this._alive = true;
		this._mode = 0;
		this._mountMode = 0;
		this._parent = null;
		this._children = [];
		this._layer = 0;
		this._timeStream = [];
		this._managed = 2;
		
		this._specialProp = [
			'_id',
			'_parent',
			'_children'
		];

		if (!ige.isServer) {
			this._pixiDisplayObject = new PIXI.DisplayObjectContainer();
		}
	},

	/**
	 * Determines if the object is alive or not. The alive
	 * value is automatically set to false when the object's
	 * destroy() method is called. Useful for checking if
	 * an object that you are holding a reference to has been
	 * destroyed.
	 * @param {Boolean=} val The value to set the alive flag
	 * to.
	 * @example #Get the alive flag value
	 *     var entity = new IgeEntity();
	 *     console.log(entity.alive());
	 * @example #Set the alive flag value
	 *     var entity = new IgeEntity();
	 *     entity.alive(true);
	 * @return {*}
	 */
	alive: function (val) {
		if (val !== undefined) {
			this._alive = val;
			return this;
		}

		return this._alive;
	},

	/**
	 * Gets / set the managed mode from 0 to 2. 0 = off, 1 = static, 2 = dynamic.
	 * 
	 * @param {Number=} val Set to 0 to switch off managed mode, 1 to set to static
	 * managed mode or 2 to dynamic managed mode. When in a managed mode and when
	 * the parent of this entity has an entity manager component enabled, the entity
	 * will be checked to see if it is inside the visible area of a viewport. If it
	 * is deemed not to be in a visible area (via it's AABB non-intersection with
	 * viewport view area) then it will either be un-mounted from the parent (mode 1)
	 * or marked as no longer in view (mode 2). Mode 2 in view = false will cause the
	 * entity to no longer be depth-sorted or rendered but will still have it's
	 * update() method called each frame allowing logic processing to occur as normal.
	 * The default managed mode is 2.
	 * @returns {*}
	 */
	managed: function (val) {
		if (val !== undefined) {
			this._managed = val;
			return this;
		}
		
		return this._managed;
	},

	/**
	 * Gets / sets the current object id. If no id is currently assigned and no
	 * id is passed to the method, it will automatically generate and assign a
	 * new id as a 16 character hexadecimal value typed as a string.
	 * @param {String=} id
	 * @example #Get the id of an entity
	 *     var entity = new IgeEntity();
	 *     console.log(entity.id());
	 * @example #Set the id of an entity
	 *     var entity = new IgeEntity();
	 *     entity.id('myNewId');
	 * @example #Set the id of an entity via chaining
	 *     var entity = new IgeEntity()
	 *         .id('myNewId');
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	id: function (id) {
		if (id !== undefined) {
			// Check if we're changing the id
			if (id !== this._id) {
				// Check if this ID already exists in the object register
				if (ige._register[id]) {
					// Already an object with this ID!
					if (ige._register[id] !== this) {
						this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
					}
				} else {
					// Check if we already have an id assigned
					if (this._id && ige._register[this._id]) {
						// Unregister the old ID before setting this new one
						ige.unRegister(this);
					}

					this._id = id;

					// Now register this object with the object register
					ige.register(this);

					return this;
				}
			} else {
				// The same ID we already have is being applied,
				// ignore the request and return
				return this;
			}
		}

		if (!this._id) {
			// The item has no id so generate one automatically
			this._id = ige.newIdHex();
			ige.register(this);
		}

		return this._id;
	},

	/**
	 * Gets / sets the arbitrary category name that the object belongs to.
	 * @param {String=} val
	 * @example #Get the category of an entity
	 *     var entity = new IgeEntity();
	 *     console.log(entity.category());
	 * @example #Set the category of an entity
	 *     var entity = new IgeEntity();
	 *     entity.category('myNewCategory');
	 * @example #Set the category of an entity via chaining
	 *     var entity = new IgeEntity()
	 *         .category('myNewCategory');
	 * @example #Get all the entities belonging to a category
	 *     var entityArray = ige.$$('categoryName');
	 * @example #Remove the category of an entity
	 *     // Set category to some name
	 *     var entity = new IgeEntity()
	 *         .category('myCategory');
	 *         
	 *     // Will output "myCategory"
	 *     console.log(entity.category());
	 *     
	 *     // Now remove the category
	 *     entity.category('');
	 *     
	 *     // Will return ""
	 *     console.log(entity.category());
	 * @return {*}
	 */
	category: function (val) {
		if (val !== undefined) {
			// Check if we already have a category
			if (this._category) {
				// Check if the category being assigned is different from
				// the current one
				if (this._category !== val) {
					// The category is different so remove this object
					// from the current category association
					ige.categoryUnRegister(this);
				}
			}
			
			this._category = val;

			// Check the category is not a blank string
			if (val) {
				// Now register this object with the category it has been assigned
				ige.categoryRegister(this);
			}
			return this;
		}

		return this._category;
	},

	/**
	 * DEPRECIATED - Use category() instead. A warning method to
	 * help developers move to the new groups system.
	 */
	group: function () {
		this.log('The group() method has been renamed to category(). Please update your code.', 'error');
	},

	/**
	 * Adds this entity to a group or groups passed as
	 * arguments.
	 * @param {*} groupName A group or array of group names
	 * to add the entity to.
	 * @example #Add entity to a single group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1');
	 * @example #Add entity to multiple groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2', 'g3');
	 * @example #Add entity to multiple groups via an array
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2', 'g3']);
	 * @example #Add entity to multiple groups via multiple arrays
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2', 'g3'], ['g4', 'g5']);
	 * @return {*}
	 */
	addGroup: function () {
		var arrCount = arguments.length,
			groupName,
			groupItemCount;

		while (arrCount--) {
			groupName = arguments[arrCount];
			
			// Check if the argument is an array
			if (groupName instanceof Array) {
				groupItemCount = groupName.length;
				
				// Add each group of the array to the entity
				while (groupItemCount--) {
					if (!this._groups || this._groups.indexOf(groupName[groupItemCount]) === -1) {
						this._groups = this._groups || [];
						this._groups.push(groupName[groupItemCount]);

						// Now register this object with the group it has been assigned
						ige.groupRegister(this, groupName[groupItemCount]);
					}
				}
			} else {
				if (!this._groups || this._groups.indexOf(groupName) === -1) {
					this._groups = this._groups || [];
					this._groups.push(groupName);
	
					// Now register this object with the group it has been assigned
					ige.groupRegister(this, groupName);
				}
			}
		}

		return this;
	},

	/**
	 * Checks if the entity is in the group or array of group
	 * names passed.
	 * @param {*} groupName A group name or array of names.
	 * @param {Boolean=} matchAllGroups If set to true, will cause
	 * the method to check if the entity is in ALL the groups,
	 * otherwise the method will check if the entity is in ANY group.
	 * @example #Check if the entity is in a group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // Will output true since entity is part of g1 group
	 *     console.log(entity.inGroup('g1', false);
	 *	
	 *     // Will output false since entity is not part of g3 group
	 *     console.log(entity.inGroup('g3', false);
	 * @example #Check if the entity is in an array of groups using ANY and ALL options
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *     
	 *     // Will output true since entity is part of g1 group
	 *     console.log(entity.inGroup(['g1, 'g3'], false);
	 *     
	 *     // Will output false since entity is not part of g3 group
	 *     console.log(entity.inGroup(['g1, 'g3'], true);
	 * @return {Boolean}
	 */
	inGroup: function (groupName, matchAllGroups) {
		if (groupName) {
			if (matchAllGroups) {
				return this.inAllGroups(groupName);
			} else {
				return this.inAnyGroup(groupName);
			}
		}
		
		return false;
	},

	/**
	 * Checks if the entity is in the specified group or
	 * array of groups. If multiple group names are passed,
	 * as an array the method will only return true if the
	 * entity is in ALL the passed groups.
	 * @param {*} groupName The name of the group or array
	 * if group names to check if this entity is a member of.
	 * @example #Check if entity belongs to all of the passed groups
	 *     // Add a couple of groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2']);
	 *	
	 *     // This will output "false" (entity is not part of g3)
	 *     console.log(entity.inAllGroups(['g1', 'g3']));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAllGroups('g1'));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAllGroups(['g1', 'g2']));
	 * @return {Boolean}
	 */
	inAllGroups: function (groupName) {
		var arrItem, arrCount;
		
		if (groupName instanceof Array) {
			arrCount = groupName.length;
			
			while (arrCount--) {
				arrItem = groupName[arrCount];
			
				if (arrItem) {
					if (!this._groups || this._groups.indexOf(arrItem) === -1) {
						return false;
					}
				}
			}
		} else {
			return !(!this._groups || this._groups.indexOf(groupName) === -1);
		}

		return true;
	},

	/**
	 * Checks if the entity is in the specified group or
	 * array of group names. If multiple group names are passed
	 * as an array, the method will return true if the entity
	 * is in ANY of the the passed groups.
	 * @param {*} groupName The name of the group or array of
	 * group names to check if this entity is a member of.
	 * @example #Check if entity belongs to any of the passed groups
	 *     // Add a couple of groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "false"
	 *     console.log(entity.inAnyGroup('g3'));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAnyGroup(['g3', 'g1']));
	 * @return {Boolean}
	 */
	inAnyGroup: function (groupName) {
		var arrItem, arrCount;

		if (groupName instanceof Array) {
			arrCount = groupName.length;

			while (arrCount--) {
				arrItem = groupName[arrCount];

				if (arrItem) {
					if (this._groups && this._groups.indexOf(arrItem) > -1) {
						return true;
					}
				}
			}
		} else {
			return (this._groups && this._groups.indexOf(groupName) > -1);
		}

		return false;
	},

	/**
	 * Gets an array of all groups this entity belongs to.
	 * @example #Get array of groups entity belongs to
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "['g1', 'g2']"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	groups: function () {
		return this._groups || [];
	},

	/**
	 * Gets the number of groups this entity belongs to.
	 * @example #Get number of groups entity belongs to
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "2"
	 *     console.log(entity.groupCount());
	 * @return {Number}
	 */
	groupCount: function () {
		return this._groups ? this._groups.length : 0;
	},

	/**
	 * Removes the entity from the group or groups passed. This
	 * method accepts multiple arguments and will remove the entity
	 * from all groups passed as arguments.
	 * @param {*} groupName The name of the group or array of group
	 * names to remove this entity as a member of.
	 * @example #Remove entity from single group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "['g1', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from a single group
	 *     entity.removeGroup('g1');
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup('g1', 'g3');
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups via an array
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup(['g1', 'g3']);
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups via multiple arrays
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7');
	 *	
	 *     // This will output "['g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup(['g1', 'g3'], ['g5', 'g6', 'g7']);
	 *	
	 *     // This will output "['g2', 'g4']"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	removeGroup: function () {
		if (this._groups) {
			var arrCount = arguments.length,
				groupName,
				groupNameCount;

			while (arrCount--) {
				groupName = arguments[arrCount];
				
				if (groupName instanceof Array) {
					groupNameCount = groupName.length;
					
					while (groupNameCount--) {
						this._groups.pull(groupName[groupNameCount]);

						// Now un-register this object with the group it has been assigned
						ige.groupUnRegister(this, groupName[groupNameCount]);
					}
				} else {
					this._groups.pull(groupName);
	
					// Now un-register this object with the group it has been assigned
					ige.groupUnRegister(this, groupName);
				}
			}
		}

		return this;
	},

	/**
	 * Removes the entity from all groups it is a member of.
	 * @example #Remove entity from all groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove all the groups
	 *     entity.removeAllGroups();
	 *	
	 *     // This will output "[]"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	removeAllGroups: function () {
		if (this._groups) {
			// Loop through all groups and un-register one at a time
			var arr = this._groups,
				arrCount = arr.length;

			while (arrCount--) {
				ige.groupUnRegister(this, arr[arrCount]);
			}

			delete this._groups;
		}
		return this;
	},

	/**
	 * Adds a behaviour to the object's active behaviour list.
	 * @param {String} id
	 * @param {Function} behaviour
	 * @param {Boolean=} duringTick If true, will execute the behaviour
	 * during the tick() method instead of the update() method.
	 * @example #Add a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now since each update we are setting _somePropertyOfTheEntity
	 *     // to equal "moo" we can console log the property and get
	 *     // the value as "moo"
	 *     console.log(entity._somePropertyOfTheEntity);
	 * @return {*} Returns this on success or false on failure.
	 */
	addBehaviour: function (id, behaviour, duringTick) {
		if (typeof(id) === 'string') {
			if (typeof(behaviour) === 'function') {
				if (duringTick) {
					this._tickBehaviours = this._tickBehaviours || [];
					this._tickBehaviours.push({
						id:id,
						method: behaviour
					});
				} else {
					this._updateBehaviours = this._updateBehaviours || [];
					this._updateBehaviours.push({
						id:id,
						method: behaviour
					});	
				}

				return this;
			} else {
				this.log('The behaviour you passed is not a function! The second parameter of the call must be a function!', 'error');
			}
		} else {
			this.log('Cannot add behaviour to object because the specified behaviour id is not a string. You must provide two parameters with the addBehaviour() call, an id:String and a behaviour:Function. Adding a behaviour with an id allows you to remove it by it\'s id at a later stage!', 'error');
		}

		return false;
	},

	/**
	 * Removes a behaviour to the object's active behaviour list by it's id.
	 * @param {String} id
	 * @param {Boolean=} duringTick If true will look to remove the behaviour
	 * from the tick method rather than the update method.
	 * @example #Remove a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now remove the "myBehaviour" behaviour
	 *     entity.removeBehaviour('myBehaviour');
	 * @return {*} Returns this on success or false on failure.
	 */
	removeBehaviour: function (id, duringTick) {
		if (id !== undefined) {
			var arr,
				arrCount;
			
			if (duringTick) {
				arr = this._tickBehaviours;
			} else {
				arr = this._updateBehaviours;
			}

			// Find the behaviour
			if (arr) {
				arrCount = arr.length;

				while (arrCount--) {
					if (arr[arrCount].id === id) {
						// Remove the item from the array
						arr.splice(arrCount, 1);
						return this;
					}
				}
			}
		}

		return false;
	},

	/**
	 * Checks if the object has the specified behaviour already added to it.
	 * @param {String} id
	 * @param {Boolean=} duringTick If true will look to remove the behaviour
	 * from the tick method rather than the update method.
	 * @example #Check for a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now check for the "myBehaviour" behaviour
	 *     console.log(entity.hasBehaviour('myBehaviour')); // Will log "true"
	 * @return {*} Returns this on success or false on failure.
	 */
	hasBehaviour: function (id, duringTick) {
		if (id !== undefined) {
			var arr,
				arrCount;
			
			if (duringTick) {
				arr = this._tickBehaviours;
			} else {
				arr = this._updateBehaviours;
			}

			// Find the behaviour
			if (arr) {
				arrCount = arr.length;

				while (arrCount--) {
					if (arr[arrCount].id === id) {
						return true;
					}
				}
			}
		}

		return false;
	},
	
	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's bounds drawn when the bounds for all objects are being drawn.
	 * In order for bounds to be drawn the viewport the object is being drawn
	 * to must also have draw bounds enabled.
	 * @param {Boolean} val
	 * @example #Enable draw bounds
	 *     var entity = new IgeEntity();
	 *     entity.drawBounds(true);
	 * @example #Disable draw bounds
	 *     var entity = new IgeEntity();
	 *     entity.drawBounds(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawBounds());
	 * @return {*}
	 */
	drawBounds: function (val) {
		if (val !== undefined) {
			this._drawBounds = val;
			return this;
		}

		return this._drawBounds;
	},

	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's bounds data drawn when the bounds for all objects are being drawn.
	 * Bounds data includes the object ID and it's current depth etc.
	 * @param {Boolean} val
	 * @example #Enable draw bounds data
	 *     var entity = new IgeEntity();
	 *     entity.drawBoundsData(true);
	 * @example #Disable draw bounds data
	 *     var entity = new IgeEntity();
	 *     entity.drawBoundsData(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawBoundsData());
	 * @return {*}
	 */
	drawBoundsData: function (val) {
		if (val !== undefined) {
			this._drawBoundsData = val;
			return this;
		}

		return this._drawBoundsData;
	},

	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's mouse position drawn, usually for debug purposes.
	 * @param {Boolean=} val
	 * @example #Enable draw mouse position data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouse(true);
	 * @example #Disable draw mouse position data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouse(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawMouse());
	 * @return {*}
	 */
	drawMouse: function (val) {
		if (val !== undefined) {
			this._drawMouse = val;
			return this;
		}

		return this._drawMouse;
	},
	
	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's extra mouse data drawn for debug purposes. For instance, on tilemaps
	 * (IgeTileMap2d) instances, when enabled you will see the tile x and y
	 * co-ordinates currently being hoverered over by the mouse.
	 * @param {Boolean=} val
	 * @example #Enable draw mouse data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouseData(true);
	 * @example #Disable draw mouse data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouseData(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawMouseData());
	 * @return {*}
	 */
	drawMouseData: function (val) {
		if (val !== undefined) {
			this._drawMouseData = val;
			return this;
		}

		return this._drawMouseData;
	},

	/**
	 * Finds a child entity that matches the id mounted to this
	 * or any other child entity down the scenegraph chain. Will
	 * only return an object if the entity found has this entity
	 * as an ancestor (parent or parent of parent etc).
	 * @param {String} id The id of the entity to find.
	 * @returns {*} The entity or undefined.
	 */
	$: function (id) {
		var obj = ige.$(id);
		
		if (obj._parent === this) {
			// We found a child and it's parent is this object so return it
			return obj;
		} else {
			// Scan up the object's parent chain to see if this object is
			// an ancestor at some point
			var ancestor = obj.parent(this.id());
			
			if (ancestor) {
				return obj;
			} else {
				return undefined;
			}
		}
	},

	/**
	 * Finds all child entities of this or any child of this entity
	 * down the scenegraph who's category matches the category name
	 * passed.
	 * @param {String} categoryName The category name to scan for.
	 * @returns {Array}
	 */
	$$: function (categoryName) {
		var objArr = ige.$$(categoryName),
			arrCount = objArr.length,
			obj,
			finalArr = [],
			thisId = this.id();
			
		// Scan all objects that have the specified category
		// and see if we are it's parent or an ancestor
		while (arrCount--) {
			obj = objArr[arrCount];
			if (obj._parent === this || obj.parent(thisId)) {
				finalArr.push(obj);
			}
		}
		
		return finalArr;
	},

	/**
	 * Returns the object's parent object (the object that
	 * it is mounted to).
	 * @param {String=} id Optional, if present will scan up
	 * the parent chain until a parent with the matching id is
	 * found. If none is found, returns undefined.
	 * @example #Get the object parent
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *     
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *     
	 *     // Get the parent of entity2 (which is entity1)
	 *     var parent = entity2.parent();
	 *     
	 *     // Log the parent's id (will output "entity1")
	 *     console.log(parent.id());
	 * @return {*}
	 */
	parent: function (id) {
		if (!id) {
			return this._parent;
		}
		
		if (this._parent) {
			if (this._parent.id() === id) {
				return this._parent;
			} else {
				return this._parent.parent(id);
			}
		}
		
		return undefined;
	},

	/**
	 * Returns the object's children as an array of objects.
	 * @example #Get the child objects array
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *	
	 *     // Get the chilren array entity1
	 *     var childArray = entity1.children();
	 *	
	 *     // Log the child array contents (will contain entity2)
	 *     console.log(childArray);
	 * @return {Array} The array of child objects.
	 */
	children: function () {
		return this._children;
	},

	/**
	 * Mounts this object to the passed object in the scenegraph.
	 * @param {IgeObject} obj
	 * @example #Mount an entity to another entity
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 * @return {*} Returns this on success or false on failure.
	 */
	mount: function (obj) {
		if (obj) {
			if (obj === this) {
				this.log('Cannot mount an object to itself!', 'error');
				return this;
			}
			
			if (obj._children) {
				// Check that the engine will allow us to register this object
				this.id(); // Generates a new id if none is currently set, and registers it on the object register!

				if (this._parent) {
					if (this._parent === obj) {
						// We are already mounted to the parent!
						return this;
					} else {
						// We are already mounted to a different parent
						this.unMount();
					}
				}

				this._parent = obj;
				
				// Check if we need to set the ignore camera flag
				if (!this._ignoreCamera && this._parent._ignoreCamera) {
					this._ignoreCamera = this._parent._ignoreCamera;
					
					/*if (this.ignoreCameraComposite) {
						this.ignoreCameraComposite(this._parent._ignoreCamera);
					}*/
				}
				
				// Make sure we keep the child's room id in sync with it's parent
				if (this._parent._streamRoomId) {
					this._streamRoomId = this._parent._streamRoomId;
				}
				
				obj._children.push(this);
				this._parent._childMounted(this);

				if (ige.isClient && obj.updateTransform) {
					obj.updateTransform();
					obj.aabb(true);
				}
				
				if (obj.renderable && obj.renderable._compositeCache) {
					this._compositeParent = true;
				} else {
					delete this._compositeParent;
				}
				
				this._mounted(this._parent);

				this.emit('mounted', this._parent);

				return this;
			} else {
				// The object has no _children array!
				this.log('Cannot mount object because it has no _children array! If you are mounting to a custom class, ensure that you have called the prototype.init() method of your super-class during the init of your custom class.', 'warning');
				return false;
			}
		} else {
			this.log('Cannot mount non-existent object!', 'error');
		}
	},

	/**
	 * Unmounts this object from it's parent object in the scenegraph.
	 * @example #Unmount an entity from another entity
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *     
	 *     // Now unmount entity2 from entity1
	 *     entity2.unMount();
	 * @return {*} Returns this on success or false on failure.
	 */
	unMount: function () {
		if (this._parent) {
			var childArr = this._parent._children,
				index = childArr.indexOf(this),
				oldParent = this._parent;

			if (index > -1) {
				// Found this in the parent._children array so remove it
				childArr.splice(index, 1);

				this._parent._childUnMounted(this);
				this._parent = null;
				
				this._unMounted(oldParent);

				this.emit('unMounted');

				return this;
			} else {
				// Cannot find this in the parent._children array
				return false;
			}
		} else {
			return false;
		}
	},
	
	/**
	 * Determines if the object has a parent up the scenegraph whose
	 * id matches the one passed. Will traverse each parent object
	 * checking if the id matches. This information will be cached when
	 * first called and can be refreshed by setting the "fresh" parameter
	 * to true.
	 * @param {String} parentId The id of the parent to check for.
	 * @param {Boolean=} fresh If true will force a full check instead of
	 * using the cached value from an earlier check.
	 */
	hasParent: function (parentId, fresh) {
		var bool = false;
		
		// Check for a cached value
		if (!fresh && this._hasParent && this._hasParent[parentId] !== undefined) {
			return this._hasParent[parentId];
		}
		
		if (this._parent) {
			if (this._parent.id() === parentId) {
				bool = true;
			} else {
				bool = this._parent.hasParent(parentId, fresh);
			}
		}
		
		this._hasParent = this._hasParent || {};
		this._hasParent[parentId] = bool;
		
		return bool;
	},

	/**
	 * Clones the object and all it's children and returns a new object.
	 */
	clone: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		// Set some default option values
		if (options.id === undefined) { options.id = false; }
		if (options.mount === undefined) { options.mount = false; }
		if (options.transform === undefined) { options.transform = true; }
		
		// Loop all children and clone them, then return cloned version of ourselves
		var newObject = eval(this.stringify(options));
		
		return newObject;
	},

	/**
	 * Gets / sets the positioning mode of the entity.
	 * @param {Number=} val 0 = 2d, 1 = isometric
	 * @example #Set the positioning mode to 2d
	 *     var entity = new IgeEntity()
	 *         .mode(0);
	 * @example #Set the positioning mode to isometric
	 *     var entity = new IgeEntity()
	 *         .mode(1);
	 * @return {*}
	 */
	mode: function (val) {
		if (val !== undefined) {
			this._mode = val;
			return this;
		}

		return this._mode;
	},

	/**
	 * Gets / sets if this object should be positioned isometrically
	 * or in 2d.
	 * @param {Boolean} val Set to true to position this object in
	 * isometric space or false to position it in 2d space.
	 * @example #Set the positioning mode to isometric
	 *     var entity = new IgeEntity()
	 *         .isometric(true);
	 * @example #Set the positioning mode to 2d
	 *     var entity = new IgeEntity()
	 *         .isometric(false);
	 * @return {*}
	 */
	isometric: function (val) {
		if (val === true) {
			this._mode = 1;
			return this;
		}

		if (val === false) {
			this._mode = 0;
			return this;
		}

		return this._mode === 1;
	},

	/**
	 * Gets / sets if objects mounted to this object should be positioned
	 * and depth-sorted in an isometric fashion or a 2d fashion.
	 * @param {Boolean=} val Set to true to enabled isometric positioning
	 * and depth sorting of objects mounted to this object, or false to
	 * enable 2d positioning and depth-sorting of objects mounted to this
	 * object.
	 * @example #Set children to be positioned and depth sorted in 2d
	 *     var entity = new IgeEntity()
	 *         .isometricMounts(false);
	 * @example #Set children to be positioned and depth sorted in isometric
	 *     var entity = new IgeEntity()
	 *         .isometricMounts(true);
	 * @return {*}
	 */
	isometricMounts: function (val) {
		if (val === true) {
			this._mountMode = 1;
			return this;
		}

		if (val === false) {
			this._mountMode = 0;
			return this;
		}

		return this._mountMode === 1;
	},

	/**
	 * Gets / sets the indestructible flag. If set to true, the object will
	 * not be destroyed even if a call to the destroy() method is made.
	 * @param {Number=} val
	 * @example #Set an entity to indestructible
	 *     var entity = new IgeEntity()
	 *         .indestructible(true);
	 * @example #Set an entity to destructible
	 *     var entity = new IgeEntity()
	 *         .indestructible(false);
	 * @example #Get an entity's indestructible flag value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.indestructible());
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	indestructible: function (val) {
		if (typeof(val) !== 'undefined') {
			this._indestructible = val;
			return this;
		}

		return this._indestructible;
	},

	/**
	 * Gets / sets the current entity layer. This affects how the entity is depth-sorted
	 * against other entities of the same parent. Please note that entities are first sorted
	 * by their layer and then by their depth, and only entities of the same layer will be
	 * sorted against each other by their depth values.
	 * @param {Number=} val
	 * @example #Set an entity's layer to 22
	 *     var entity = new IgeEntity()
	 *         .layer(22);
	 * @example #Get an entity's layer value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.layer());
	 * @example #How layers and depths are handled together
	 *     var entity1 = new IgeEntity(),
	 *         entity2 = new IgeEntity(),
	 *         entity3 = new IgeEntity();
	 *         
	 *     // Set entity1 to at layer zero and depth 100
	 *     entity1.layer(0)
	 *         .depth(100);
	 *     
	 *     // Set entity2 and 3 to be at layer 1
	 *     entity2.layer(1);
	 *     entity3.layer(1);
	 *	
	 *     // Set entity3 to have a higher depth than entity2
	 *     entity2.depth(0);
	 *     entity3.depth(1);
	 *     
	 *     // The engine sorts first based on layer from lowest to highest
	 *     // and then within each layer, by depth from lowest to highest.
	 *     // This means that entity1 will be drawn before entity 2 and 3
	 *     // because even though it's depth is higher, it is not on the same
	 *     // layer as entity 2 and 3.
	 *     
	 *     // Based on the layers and depths we have assigned, here
	 *     // is how the engine will sort the draw order of the entities
	 *     // entity1
	 *     // entity2
	 *     // entity3
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	layer: function (val) {
		if (val !== undefined) {
			this._layer = val;
			return this;
		}

		return this._layer;
	},

	/**
	 * Gets / sets the current render depth of the object (higher depths
	 * are drawn over lower depths). Please note that entities are first sorted
	 * by their layer and then by their depth, and only entities of the same layer will be
	 * sorted against each other by their depth values.
	 * @param {Number=} val
	 * @example #Set an entity's depth to 1
	 *     var entity = new IgeEntity()
	 *         .depth(1);
	 * @example #Get an entity's depth value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.depth());
	 * @example #How layers and depths are handled together
	 *     var entity1 = new IgeEntity(),
	 *         entity2 = new IgeEntity(),
	 *         entity3 = new IgeEntity();
	 *
	 *     // Set entity1 to at layer zero and depth 100
	 *     entity1.layer(0)
	 *         .depth(100);
	 *
	 *     // Set entity2 and 3 to be at layer 1
	 *     entity2.layer(1);
	 *     entity3.layer(1);
	 *
	 *     // Set entity3 to have a higher depth than entity2
	 *     entity2.depth(0);
	 *     entity3.depth(1);
	 *
	 *     // The engine sorts first based on layer from lowest to highest
	 *     // and then within each layer, by depth from lowest to highest.
	 *     // This means that entity1 will be drawn before entity 2 and 3
	 *     // because even though it's depth is higher, it is not on the same
	 *     // layer as entity 2 and 3.
	 *
	 *     // Based on the layers and depths we have assigned, here
	 *     // is how the engine will sort the draw order of the entities
	 *     // entity1
	 *     // entity2
	 *     // entity3
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	depth: function (val) {
		if (val !== undefined) {
			this._depth = val;
			this.emit('depthSet');
			return this;
		}

		return this._depth;
	},

	/**
	 * Loops through all child objects of this object and destroys them
	 * by calling each child's destroy() method then clears the object's
	 * internal _children array.
	 */
	destroyChildren: function () {
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount].destroy();
			}
		}

		this._children = [];

		return this;
	},

	/**
	 * Removes all references to any behaviour methods that were added to
	 * this object.
	 */
	destroyBehaviours: function () {
		delete this._updateBehaviours;
		delete this._tickBehaviours;
	},

	/**
	 * Loops through all components added to this object and calls their
	 * destroy() method, then removes any references to the components.
	 * @return {*}
	 */
	destroyComponents: function () {
		var arr = this._components,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				if (arr[arrCount].destroy) {
					arr[arrCount].destroy();
				}
			}
		}

		delete this._components;

		return this;
	},

	/**
	 * Gets / sets the view checking flag that if set to true
	 * will ask the engine to check during each tick if this
	 * object is actually "on screen" or not, and bypass it
	 * if it is not. The default is this flag set to false.
	 * @param {Boolean=} val The boolean flag value.
	 * @return {*}
	 */
	viewChecking: function (val) {
		if (val !== undefined) {
			this._viewChecking = val;
			return this;
		}

		return this._viewChecking;
	},
	
	update: function (ctx, tickDelta) {
		// Check that we are alive before processing further
		if (this._alive) {
			if (this._newBorn) { this._newBorn = false; }
			var arr = this._children,
				arrCount,
				ts, td;

			if (arr) {
				arrCount = arr.length;
				
				// Depth sort all child objects
				if (arrCount && !ige._headless) {
					if (igeConfig.debug._timing) {
						if (!ige._timeSpentLastTick[this.id()]) {
							ige._timeSpentLastTick[this.id()] = {};
						}

						ts = new Date().getTime();
						this.depthSortChildren();
						td = new Date().getTime() - ts;
						ige._timeSpentLastTick[this.id()].depthSortChildren = td;
					} else {
						this.depthSortChildren();
					}
				}

				// Loop our children and call their update methods
				if (igeConfig.debug._timing) {
					while (arrCount--) {
						ts = new Date().getTime();
						arr[arrCount].update(ctx, tickDelta);
						td = new Date().getTime() - ts;
						if (arr[arrCount]) {
							if (!ige._timeSpentInTick[arr[arrCount].id()]) {
								ige._timeSpentInTick[arr[arrCount].id()] = 0;
							}

							if (!ige._timeSpentLastTick[arr[arrCount].id()]) {
								ige._timeSpentLastTick[arr[arrCount].id()] = {};
							}

							ige._timeSpentInTick[arr[arrCount].id()] += td;
							ige._timeSpentLastTick[arr[arrCount].id()].tick = td;
						}
					}
				} else {
					while (arrCount--) {
						arr[arrCount].update(ctx, tickDelta);
					}
				}
			}
		}
	},

	/**
	 * Processes the actions required each render frame.
	 */
	tick: function (ctx) {
		// Check that we are alive before processing further
		if (this._alive) {
			var arr = this._children,
				arrCount,
				ts, td;
	
			if (this._viewChecking) {
				// Set the in-scene flag for each child based on
				// the current viewport
				this.viewCheckChildren();
			}
	
			// Loop the child objects of this object
			if (arr) {
				arrCount = arr.length;
				
				// Loop our children and call their tick methods
				if (igeConfig.debug._timing) {
					while (arrCount--) {
						if (!arr[arrCount]) {
							this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
							continue;
						}
						
						if (!arr[arrCount]._newBorn) {
							ctx.save();
							ts = new Date().getTime();
							arr[arrCount].tick(ctx);
							td = new Date().getTime() - ts;
							if (arr[arrCount]) {
								if (!ige._timeSpentInTick[arr[arrCount].id()]) {
									ige._timeSpentInTick[arr[arrCount].id()] = 0;
								}
		
								if (!ige._timeSpentLastTick[arr[arrCount].id()]) {
									ige._timeSpentLastTick[arr[arrCount].id()] = {};
								}
		
								ige._timeSpentInTick[arr[arrCount].id()] += td;
								ige._timeSpentLastTick[arr[arrCount].id()].tick = td;
							}
							ctx.restore();
						}
					}
				} else {
					while (arrCount--) {
						if (!arr[arrCount]) {
							this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
							continue;
						}
						
						if (!arr[arrCount]._newBorn) {
							ctx.save();
							arr[arrCount].tick(ctx);
							ctx.restore();
						}
					}
				}
			}
		}
	},

	_depthSortVisit: function (u, sortObj) {
		var arr = sortObj.adj[u],
			arrCount = arr.length,
			i, v;

		sortObj.c[u] = 1;

		for (i = 0; i < arrCount; ++i) {
			v = arr[i];

			if (sortObj.c[v] === 0) {
				sortObj.p[v] = u;
				this._depthSortVisit(v, sortObj);
			}
		}

		sortObj.c[u] = 2;
		sortObj.order[sortObj.order_ind] = u;
		--sortObj.order_ind;
	},

	/**
	 * Handles screen resize events. Calls the _resizeEvent method of
	 * every child object mounted to this object.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		}


	},

	/**
	 * Calls each behaviour method for the object.
	 * @private
	 */
	_processUpdateBehaviours: function (ctx, tickDelta) {
		var arr = this._updateBehaviours,
			arrCount;

		if (arr) {
			arrCount = arr.length;
			while (arrCount--) {
				arr[arrCount].method.apply(this, arguments);
			}
		}
	},

	/**
	 * Calls each behaviour method for the object.
	 * @private
	 */
	_processTickBehaviours: function (ctx) {
		var arr = this._tickBehaviours,
			arrCount;

		if (arr) {
			arrCount = arr.length;
			while (arrCount--) {
				arr[arrCount].method.apply(this, arguments);
			}
		}
	},
	
	/**
	 * Called when a child object is mounted to this object.
	 * @param obj
	 * @private
	 */
	_childMounted: function (obj) {
		this._resizeEvent(null);
	},

	/**
	 * Called when a child object is un-mounted to this object.
	 * @param obj
	 * @private
	 */
	_childUnMounted: function (obj) {},
	
	/**
	 * Called when this object is mounted to another object.
	 * @param obj
	 * @private
	 */
	_mounted: function (obj) {
		
	},
	
	/**
	 * Called when this object is un-mounted from it's parent.
	 * @param obj
	 * @private
	 */
	_unMounted: function (obj) {
		
	},

	/**
	 * Destroys the object and all it's child objects, removing them from the
	 * scenegraph and from memory.
	 */
	destroy: function () {
		// Remove ourselves from any parent
		this.unMount();

		// Remove any children
		if (this._children) {
			this.destroyChildren();
		}

		// Remove any components
		this.destroyComponents();

		// Remove any behaviours
		this.destroyBehaviours();

		// Remove the object from the lookup system
		ige.unRegister(this);
		ige.categoryUnRegister(this);
		ige.groupUnRegister(this);

		// Set a flag in case a reference to this object
		// has been held somewhere, shows that the object
		// should no longer be interacted with
		this._alive = false;

		// Remove the event listeners array in case any
		// object references still exist there
		delete this._eventListeners;

		return this;
	},
	
	objSave: function () {
		return {igeClass: this.classId(), data: this._objSaveReassign(this, [])};
	},
	
	objLoad: function (obj) {
		this._objLoadReassign(this, obj.data);
	},
	
	saveSpecialProp: function (obj, i) {
		switch (i) {
			case '_id':
				if (obj._id) {
					return {_id: obj._id};
				}
				break;
			
			case '_parent':
				if (obj._parent) {
					return {_parent: obj._parent.id()};
				}
				break;
			
			case '_children':
				if (obj._children.length) {
					var childIndex,
						child,
						arr = [];
					
					for (childIndex = 0; childIndex < obj._children.length; childIndex++) {
						child = obj._children[childIndex];
						arr.push(child.objSave());
					}
					
					return {_children: arr};
				}
				break;
		}
		
		return undefined;
	},
	
	loadSpecialProp: function (obj, i) {
		switch (i) {
			case '_id':
				return {_id: obj[i]};
				break;
			
			case '_parent':
				return {_parent: obj[i]};
				break;
			
			case '_children':
				return {_children: obj[i]};
				break;
		}
		return undefined;
	},
	
	loadGraph: function (obj) {
		if (obj.igeClass && obj.data) {
			// Create a new class instance
			var classInstance = ige.newClassInstance(obj.igeClass),
				newId,
				childArr,
				childIndex,
				parentId;
			
			classInstance.objLoad(obj);
			
			if (classInstance._parent) {
				// Record the id and delete it
				parentId = classInstance._parent;
				delete classInstance._parent;
			}
			
			// Process item id
			if (classInstance._id) {
				newId = classInstance._id;
				delete classInstance._id;
				
				classInstance.id(newId);
			}
			
			// Check for children and process them if exists
			if (classInstance._children && classInstance._children.length) {
				childArr = classInstance._children;
				classInstance._children = [];
				
				for (childIndex = 0; childIndex < childArr.length; childIndex++) {
					classInstance.loadGraph(childArr[childIndex]);
				}
			}
			
			// Now mount the instance if it has a parent
			classInstance.mount(this);
		}
	},
	
	_objSaveReassign: function (obj, ref) {
		var copyObj,
			specialKeys = this._specialProp,
			refIndex,
			specProp,
			specPropKey,
			i;
		
		if (typeof(obj) === 'object' && !(obj instanceof Array)) {
			copyObj = {};
			
			for (i in obj) {
				if (obj.hasOwnProperty(i)) {
					if (typeof(obj[i]) === 'object') {
						if (specialKeys.indexOf(i) === -1) {
							// Check if the ref already exists
							refIndex = ref.indexOf(obj[i]);
							
							if (refIndex > -1) {
								copyObj[i] = '{ref:' + refIndex + '}';
								this.log('Possible circular reference for property ' + i);
							} else {
								ref.push(obj[i]);
								copyObj[i] = this._objSaveReassign(obj[i], ref);
							}
						} else {
							// This is a special property that needs handling via
							// it's own method to return an appropriate data value
							// so check if there is a method for it
							specProp = this.saveSpecialProp(obj, i);
							
							if (specProp) {
								if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
									// Process the returned object properties
									for (specPropKey in specProp) {
										if (specProp.hasOwnProperty(specPropKey)) {
											// Copy the special property data to the key in
											// our return object
											copyObj[specPropKey] = specProp[specPropKey];
										}
									}
								} else {
									copyObj[i] = specProp;
								}
							}
						}
					} else {
						copyObj[i] = obj[i];
					}
				}
			}
			
			return copyObj;
		} else {
			return obj;
		}
	},
	
	_objLoadReassign: function (obj, newProps) {
		var specialKeys = this._specialProp,
			specProp,
			specPropKey,
			i;
		
		for (i in newProps) {
			if (newProps.hasOwnProperty(i)) {
				if (specialKeys.indexOf(i) === -1) {
					if (typeof(newProps[i]) === 'object' && obj[i]) {
						this._objLoadReassign(obj[i], newProps[i]);
					} else {
						// Assign the property value directly
						obj[i] = newProps[i];
					}
				} else {
					// This is a special property that needs handling via
					// it's own method to return an appropriate data value
					// so check if there is a method for it
					specProp = this.loadSpecialProp(newProps, i);
					
					if (specProp) {
						if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
							// Process the returned object properties
							for (specPropKey in specProp) {
								if (specProp.hasOwnProperty(specPropKey)) {
									// Copy the special property data to the key in
									// our return object
									obj[specPropKey] = specProp[specPropKey];
								}
							}
						} else {
							obj[i] = specProp;
						}
					}
				}
			}
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		var str = "new " + this.classId() + "()";

		// Every object has an ID, assign that first
		if (options.id !== false) {
			str += ".id('" + this.id() + "')";
		}

		// Now check if there is a parent and mount that
		if (options.mount !== false && this.parent()) {
			str += ".mount(ige.$('" + this.parent().id() + "'))";
		}

		// Now get all other properties
		str += this._stringify(options);

		return str;
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		var str = '', i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_category':
						str += ".category(" + this.category() + ")";
						break;
					case '_drawBounds':
						str += ".drawBounds(" + this.drawBounds() + ")";
						break;
					case '_drawBoundsData':
						str += ".drawBoundsData(" + this.drawBoundsData() + ")";
						break;
					case '_drawMouse':
						str += ".drawMouse(" + this.drawMouse() + ")";
						break;
					case '_mode':
						str += ".mode(" + this.mode() + ")";
						break;
					case '_isometricMounts':
						str += ".isometricMounts(" + this.isometricMounts() + ")";
						break;
					case '_indestructible':
						str += ".indestructible(" + this.indestructible() + ")";
						break;
					case '_layer':
						str += ".layer(" + this.layer() + ")";
						break;
					case '_depth':
						str += ".depth(" + this.depth() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeObject; }
;/**
 * Creates an entity and handles the entity's life cycle and
 * all related entity actions / methods.
 */
var IgeEntity = IgeObject.extend({
	classId: 'IgeEntity',

	init: function (opts) {
		IgeObject.prototype.init.call(this);
		
		// Register the IgeEntity special properties handler for 
		// serialise and de-serialise support
		this._specialProp.push('_texture');
		this._specialProp.push('_eventListeners');
		this._specialProp.push('_aabb');

		this._deathTime = undefined;
		this._bornTime = ige._currentTime;

		this._localMatrix = new IgeMatrix2d();
		this._worldMatrix = new IgeMatrix2d();
		this._oldWorldMatrix = new IgeMatrix2d();

		if (opts && opts.translate) {
			this._translate = new IgePoint3d(
				opts.translate.x,
				opts.translate.y,
				0);
		}
		else {
			this._translate = new IgePoint3d(0, 0, 0);
		}

		this._rotate = new IgePoint3d(0, 0, 0);
		this._scale = new IgePoint3d(1, 1, 1);
		this._origin = new IgePoint3d(0.5, 0.5, 0.5);

		this._depthSortMode = 0;
		this._depth = 0;

		this._bounds2d = new IgePoint2d(40, 40);
		this._bounds3d = new IgePoint3d(0, 0, 0);
		
		this._oldBounds2d = new IgePoint2d(40, 40);
		this._oldBounds3d = new IgePoint3d(0, 0, 0);

		this._mouseEventsActive = false;
		
		this._velocity = new IgePoint3d(0, 0, 0);

		this._inView = true;

		this._streamEntityValid = undefined;

		//this._mouseEventTrigger = 0;

		

		// Set the default stream sections as just the transform data
		this.streamSections(['transform']);
	},

	/**
	 * Sets the entity as visible and able to be interacted with.
	 * @example #Show a hidden entity
	 *     entity.show();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	show: function () {
		return this.renderable.show();
	},

	/**
	 * Sets the entity as hidden and cannot be interacted with.
	 * @example #Hide a visible entity
	 *     entity.hide();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	hide: function () {
		return this.renderable.hide();
	},

	/**
	 * Checks if the entity is visible.
	 * @returns {boolean} True if the entity is visible.
	 */
	isVisible: function () {
		return this.renderable.isVisible();
	},
	
	/**
	 * Checks if the entity is hidden.
	 * @returns {boolean} True if the entity is hidden.
	 */
	isHidden: function () {
		return this.renderable.isHidden();
	},

	/**
	 * Getter/setter for the _streamEntityValid parameter.
	 * This parameter only applies to client-side streamed entities.
	 * This parameter is true when the streamed entity is valid. A streamed
	 * entity may become invalid when the server stops updating it when it is
	 * out of the player's visible rectangle.
	 * @param val {Boolean} Optional parameter.
	 * @returns {*} The current _streamEntityValid value, if getter.
	 * This object, if setter to make chaining calls easier.
	 * @memberof IgeEntity
	 * @instance
	 */
	streamEntityValid: function(val) {
		if (val === undefined) {
			return this._streamEntityValid;
		}

		this._streamEntityValid = val;
		return this;
	},

	/**
	 * Gets / sets the cache flag that determines if the entity's
	 * texture rendering output should be stored on an off-screen
	 * canvas instead of calling the texture.render() method each
	 * tick. Useful for expensive texture calls such as rendering
	 * fonts etc. If enabled, this will automatically disable advanced
	 * composite caching on this entity with a call to
	 * compositeCache(false).
	 * @param {Boolean=} val True to enable caching, false to
	 * disable caching.
	 * @example #Enable entity caching
	 *     entity.cache(true);
	 * @example #Disable entity caching
	 *     entity.cache(false);
	 * @example #Get caching flag value
	 *     var val = entity.cache();
	 * @return {*}
	 */
	cache: function (val) {
		return this.renderable.cache(val);
	},

	/**
	 * When using the caching system, this boolean determines if the
	 * cache canvas should have image smoothing enabled or not. If
	 * not set, the ige global smoothing setting will be used instead.
	 * @param {Boolean=} val True to enable smoothing, false to disable.
	 * @returns {*}
	 */
	cacheSmoothing: function (val) {
		return this.renderable.cacheSmoothing(val);
	},

	/**
	 * Gets / sets composite caching. Composite caching draws this entity
	 * and all of it's children (and their children etc) to a single off
	 * screen canvas so that the entity does not need to be redrawn with
	 * all it's children every tick. For composite entities where little
	 * change occurs this will massively increase rendering performance.
	 * If enabled, this will automatically disable simple caching on this
	 * entity with a call to cache(false).
	 * @param {Boolean=} val
	 * @example #Enable entity composite caching
	 *     entity.compositeCache(true);
	 * @example #Disable entity composite caching
	 *     entity.compositeCache(false);
	 * @example #Get composite caching flag value
	 *     var val = entity.cache();
	 * @return {*}
	 */
	compositeCache: function (val) {
		return this.renderable.compositeCache(val);
	},

	/**
	 * Gets / sets the cache dirty flag. If set to true this will
	 * instruct the entity to re-draw it's cached image from the
	 * assigned texture. Once that occurs the flag will automatically
	 * be set back to false. This works in either standard cache mode
	 * or composite cache mode.
	 * @param {Boolean=} val True to force a cache update.
	 * @example #Get cache dirty flag value
	 *     var val = entity.cacheDirty();
	 * @example #Set cache dirty flag value
	 *     entity.cacheDirty(true);
	 * @return {*}
	 */
	cacheDirty: function (val) {
		return this.renderable.cacheDirty(val);
	},

	/**
	 * Gets / sets updateChildren. Use this when your children are static and do
	 * not need to be updated. For example, children of RenderContainers do not
	 * need to be updated every engine step.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	updateChildren: function (val) {
		if (val !== undefined) {
			this._updateChildren = val;
			return this;
		}

		return this._updateChildren;
	},

	/**
	 * Gets / sets the updateChildrenNeeded flag. When set to true, the entity
	 * will update it's children the next engine step.
	 * @param {Boolean=} val True to force an update of the entity's children.
	 * @return {*}
	 */
	// TODO: Propogate up to parent in the style of cacheDirty(). This could
	// be useful when there are RenderContainers mounted to RenderContainers.
	updateChildrenNeeded: function (val) {
		if (val !== undefined) {
			this._updateChildrenNeeded = val;
			return this;
		}

		return this._updateChildrenNeeded;
	},

	/**
	 * Gets the position of the mouse relative to this entity's
	 * center point.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get the mouse position relative to the entity
	 *     // The returned value is an object with properties x, y, z
	 *     var mousePos = entity.mousePos();
	 * @return {IgePoint3d} The mouse point relative to the entity
	 * center.
	 */
	mousePos: function (viewport) {
		viewport = viewport || ige._currentViewport;
		if (viewport) {
			var mp = viewport._mousePos.clone(),
				cam;

			if (this._ignoreCamera) {
				/*cam = ige._currentCamera;
				mp.thisMultiply(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
				//mp.thisRotate(-cam._rotate.z);
				mp.thisAddPoint(cam._translate);*/
			}
			
			mp.x += viewport._translate.x;
			mp.y += viewport._translate.y;
			this._transformPoint(mp);
			return mp;
		} else {
			return new IgePoint3d(0, 0, 0);
		}
	},

	/**
	 * Gets the position of the mouse relative to this entity not
	 * taking into account viewport translation.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get absolute mouse position
	 *     var mousePosAbs = entity.mousePosAbsolute();
	 * @return {IgePoint3d} The mouse point relative to the entity
	 * center.
	 */
	mousePosAbsolute: function (viewport) {
		viewport = viewport || ige._currentViewport;
		if (viewport) {
			var mp = viewport._mousePos.clone();
			this._transformPoint(mp);
			return mp;
		}

		return new IgePoint3d(0, 0, 0);
	},

	/**
	 * Gets the position of the mouse in world co-ordinates.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get mouse position in world co-ordinates
	 *     var mousePosWorld = entity.mousePosWorld();
	 * @return {IgePoint3d} The mouse point relative to the world
	 * center.
	 */
	mousePosWorld: function (viewport) {
		viewport = viewport || ige._currentViewport;
		var mp = this.mousePos(viewport);
		this.localToWorldPoint(mp, viewport);

		if (this._ignoreCamera) {
			//viewport.camera._worldMatrix.getInverse().transform([mp]);
		}

		return mp;
	},

	/**
	 * Rotates the entity to point at the target point around the z axis.
	 * @param {IgePoint3d} point The point in world co-ordinates to
	 * point the entity at.
	 * @example #Point the entity at another entity
	 *     entity.rotateToPoint(otherEntity.worldPosition());
	 * @example #Point the entity at mouse
	 *     entity.rotateToPoint(ige._currentViewport.mousePos());
	 * @example #Point the entity at an arbitrary point x, y
	 *     entity.rotateToPoint(new IgePoint3d(x, y, 0));
	 * @return {*}
	 */
	rotateToPoint: function (point) {
		var worldPos = this.worldPosition();
		this.rotateTo(
			this._rotate.x,
			this._rotate.y,
			(Math.atan2(worldPos.y - point.y, worldPos.x - point.x) - this._parent._rotate.z) + Math.radians(270)
		);

		return this;
	},

	/**
	 * Gets / sets the texture to use as the background
	 * pattern for this entity.
	 * @param {IgeTexture} texture The texture to use as
	 * the background.
	 * @param {String=} repeat The type of repeat mode either: "repeat",
	 * "repeat-x", "repeat-y" or "none".
	 * @param {Boolean=} trackCamera If set to true, will track the camera
	 * translation and "move" the background with the camera.
	 * @param {Boolean=} isoTile If true the tiles of the background will
	 * be treated as isometric and will therefore be drawn so that they are
	 * layered seamlessly in isometric view.
	 * @example #Set a background pattern for this entity with 2d tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, false);
	 * @example #Set a background pattern for this entity with isometric tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, true);
	 * @return {*}
	 */
	backgroundPattern: function (texture, repeat, trackCamera, isoTile) {
		return this.renderable.backgroundPattern(texture, repeat, trackCamera, isoTile);
	},

	/**
	 * Set the object's width to the number of tile width's specified.
	 * @param {Number} val Number of tiles.
	 * @param {Boolean=} lockAspect If true, sets the height according
	 * to the texture aspect ratio and the new width.
	 * @example #Set the width of the entity based on the tile width of the map the entity is mounted to
	 *     // Set the entity width to the size of 1 tile with
	 *     // lock aspect enabled which will automatically size
	 *     // the height as well so as to maintain the aspect
	 *     // ratio of the entity
	 *     entity.widthByTile(1, true);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	widthByTile: function (val, lockAspect) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var tileSize = this._mode === 0 ? this._parent._tileWidth : this._parent._tileWidth * 2,
				ratio;

			this.width(val * tileSize);

			if (lockAspect) {
				if (this.texture()) {
					// Calculate the height based on the new width
					ratio = this.texture()._sizeX / this._bounds2d.x;
					this.height(this.texture()._sizeY / ratio);
				} else {
					this.log('Cannot set height based on texture aspect ratio and new width because no texture is currently assigned to the entity!', 'error');
				}
			}
		} else {
			this.log('Cannot set width by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},

	/**
	 * Set the object's height to the number of tile height's specified.
	 * @param {Number} val Number of tiles.
	 * @param {Boolean=} lockAspect If true, sets the width according
	 * to the texture aspect ratio and the new height.
	 * @example #Set the height of the entity based on the tile height of the map the entity is mounted to
	 *     // Set the entity height to the size of 1 tile with
	 *     // lock aspect enabled which will automatically size
	 *     // the width as well so as to maintain the aspect
	 *     // ratio of the entity
	 *     entity.heightByTile(1, true);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	heightByTile: function (val, lockAspect) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var tileSize = this._mode === 0 ? this._parent._tileHeight : this._parent._tileHeight * 2,
				ratio;

			this.height(val * tileSize);

			if (lockAspect) {
				if (this.texture()) {
					// Calculate the width based on the new height
					ratio = this.texture()._sizeY / this._bounds2d.y;
					this.width(this.texture()._sizeX / ratio);
				} else {
					this.log('Cannot set width based on texture aspect ratio and new height because no texture is currently assigned to the entity!', 'error');
				}
			}
		} else {
			this.log('Cannot set height by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},
	
	/**
	 * Adds the object to the tile map at the passed tile co-ordinates. If
	 * no tile co-ordinates are passed, will use the current tile position
	 * and the tileWidth() and tileHeight() values.
	 * @param {Number=} x X co-ordinate of the tile to occupy.
	 * @param {Number=} y Y co-ordinate of the tile to occupy.
	 * @param {Number=} width Number of tiles along the x-axis to occupy.
	 * @param {Number=} height Number of tiles along the y-axis to occupy.
	 */
	occupyTile: function (x, y, width, height) {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			if (x !== undefined && y !== undefined) {
				this._parent.occupyTile(x, y, width, height, this);
			} else {
				// Occupy tiles based upon tile point and tile width/height
				var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
					tilePoint = this._parent.pointToTile(trPoint);
	
				if (this._parent._mountMode === 1) {
					tilePoint.thisToIso();
				}
	
				this._parent.occupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight, this);
			}
		}
		return this;
	},
	
	/**
	 * Removes the object from the tile map at the passed tile co-ordinates.
	 * If no tile co-ordinates are passed, will use the current tile position
	 * and the tileWidth() and tileHeight() values.
	 * @param {Number=} x X co-ordinate of the tile to un-occupy.
	 * @param {Number=} y Y co-ordinate of the tile to un-occupy.
	 * @param {Number=} width Number of tiles along the x-axis to un-occupy.
	 * @param {Number=} height Number of tiles along the y-axis to un-occupy.
	 * @private
	 */
	unOccupyTile: function (x, y, width, height) {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			if (x !== undefined && y !== undefined) {
				this._parent.unOccupyTile(x, y, width, height);
			} else {
				// Un-occupy tiles based upon tile point and tile width/height
				var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
					tilePoint = this._parent.pointToTile(trPoint);
	
				if (this._parent._mountMode === 1) {
					tilePoint.thisToIso();
				}
	
				this._parent.unOccupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight);
			}
		}
		return this;
	},
	
	/**
	 * Returns an array of tile co-ordinates that the object is currently
	 * over, calculated using the current world co-ordinates of the object
	 * as well as it's 3d geometry.
	 * @private
	 * @return {Array} The array of tile co-ordinates as IgePoint3d instances.
	 */
	overTiles: function () {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			var x,
				y,
				tileWidth = this._tileWidth || 1,
				tileHeight = this._tileHeight || 1,
				tile = this._parent.pointToTile(this._translate),
				tileArr = [];
	
			for (x = 0; x < tileWidth; x++) {
				for (y = 0; y < tileHeight; y++) {
					tileArr.push(new IgePoint3d(tile.x + x, tile.y + y, 0));
				}
			}
	
			return tileArr;
		}
	},

	/**
	 * Gets / sets the anchor position that this entity's texture
	 * will be adjusted by.
	 * @param {Number=} x The x anchor value.
	 * @param {Number=} y The y anchor value.
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	anchor: function (x, y) {
		if (x !== undefined && y !== undefined && this.renderable) {
			this.renderable._anchor = new IgePoint2d(x, y);
			return this;
		}

		// If this is not a renderable object, it's anchor can't be anything other than (0, 0).
		if (!this.renderable) {
			return new IgePoint2d(0, 0);
		}

		return this.renderable._anchor;
	},

	/**
	 * Gets / sets the geometry x value.
	 * @param {Number=} px The new x value in pixels.
	 * @example #Set the width of the entity
	 *     entity.width(40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	width: function (px, lockAspect) {
		if (px !== undefined) {
			if (lockAspect) {
				// Calculate the height from the change in width
				var ratio = px / this._bounds2d.x;
				this.height(this._bounds2d.y * ratio);
			}

			this._bounds2d.x = px;
			this._bounds2d.x2 = (px / 2);
			return this;
		}

		return this._bounds2d.x;
	},

	/**
	 * Gets / sets the geometry y value.
	 * @param {Number=} px The new y value in pixels.
	 * @example #Set the height of the entity
	 *     entity.height(40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	height: function (px, lockAspect) {
		if (px !== undefined) {
			if (lockAspect) {
				// Calculate the width from the change in height
				var ratio = px / this._bounds2d.y;
				this.width(this._bounds2d.x * ratio);
			}

			this._bounds2d.y = px;
			this._bounds2d.y2 = (px / 2);
			return this;
		}

		return this._bounds2d.y;
	},
	
	/**
	 * Gets / sets the 2d geometry of the entity. The x and y values are
	 * relative to the center of the entity. This geometry is used when
	 * rendering textures for the entity and positioning in world space as
	 * well as UI positioning calculations. It holds no bearing on isometric
	 * positioning.
	 * @param {Number=} x The new x value in pixels.
	 * @param {Number=} y The new y value in pixels.
	 * @example #Set the dimensions of the entity (width and height)
	 *     entity.bounds2d(40, 40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	bounds2d: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._bounds2d = new IgePoint2d(x, y, 0);
			return this;
		}
		
		if (x !== undefined && y === undefined) {
			// x is considered an IgePoint2d instance
			this._bounds2d = new IgePoint2d(x.x, x.y);
		}

		return this._bounds2d;
	},

	/**
	 * Gets / sets the 3d geometry of the entity. The x and y values are
	 * relative to the center of the entity and the z value is wholly
	 * positive from the "floor". Used to define a 3d bounding cuboid for
	 * the entity used in isometric depth sorting and hit testing.
	 * @param {Number=} x The new x value in pixels.
	 * @param {Number=} y The new y value in pixels.
	 * @param {Number=} z The new z value in pixels.
	 * @example #Set the dimensions of the entity (width, height and length)
	 *     entity.bounds3d(40, 40, 20);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	bounds3d: function (x, y, z) {
		if (x !== undefined && y !== undefined && z !== undefined) {
			this._bounds3d = new IgePoint3d(x, y, z);
			return this;
		}

		return this._bounds3d;
	},

	/**
	 * @deprecated Use bounds3d instead
	 * @param x
	 * @param y
	 * @param z
	 */
	size3d: function (x, y, z) {
		this.log('size3d has been renamed to bounds3d but is exactly the same so please search/replace your code to update calls.', 'warning');
	},

	/**
	 * Gets / sets the life span of the object in milliseconds. The life
	 * span is how long the object will exist for before being automatically
	 * destroyed.
	 * @param {Number=} milliseconds The number of milliseconds the entity
	 * will live for from the current time.
	 * @param {Function=} deathCallback Optional callback method to call when
	 * the entity is destroyed from end of lifespan.
	 * @example #Set the lifespan of the entity to 2 seconds after which it will automatically be destroyed
	 *     entity.lifeSpan(2000);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	lifeSpan: function (milliseconds, deathCallback) {
		if (milliseconds !== undefined) {
			this.deathTime(ige._currentTime + milliseconds, deathCallback);
			return this;
		}

		return this.deathTime() - ige._currentTime;
	},

	/**
	 * Gets / sets the timestamp in milliseconds that denotes the time
	 * that the entity will be destroyed. The object checks it's own death
	 * time during each tick and if the current time is greater than the
	 * death time, the object will be destroyed.
	 * @param {Number=} val The death time timestamp. This is a time relative
	 * to the engine's start time of zero rather than the current time that
	 * would be retrieved from new Date().getTime(). It is usually easier
	 * to call lifeSpan() rather than setting the deathTime directly.
	 * @param {Function=} deathCallback Optional callback method to call when
	 * the entity is destroyed from end of lifespan.
	 * @example #Set the death time of the entity to 60 seconds after engine start
	 *     entity.deathTime(60000);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	deathTime: function (val, deathCallback) {
		if (val !== undefined) {
			this._deathTime = val;
			
			if (deathCallback !== undefined) {
				this._deathCallBack = deathCallback;
			}
			return this;
		}

		return this._deathTime;
	},

	/**
	 * Gets / sets the entity opacity from 0.0 to 1.0.
	 * @param {Number=} val The opacity value.
	 * @example #Set the entity to half-visible
	 *     entity.opacity(0.5);
	 * @example #Set the entity to fully-visible
	 *     entity.opacity(1.0);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	opacity: function (val) {
		if (this.pixiRenderable) {
			this.pixiRenderable.opacity(val);
		}
		return this.renderable.opacity(val);
	},

	/**
	 * Gets / sets the noAabb flag that determines if the entity's axis
	 * aligned bounding box should be calculated every tick or not. If
	 * you don't need the AABB data (for instance if you don't need to
	 * detect mouse events on this entity or you DO want the AABB to be
	 * updated but want to control it manually by calling aabb(true) 
	 * yourself as needed).
	 * @param {Boolean=} val If set to true will turn off AABB calculation.
	 * @returns {*}
	 */
	noAabb: function (val) {
		if (val !== undefined) {
			this._noAabb = val;
			return this;
		}

		return this._noAabb;
	},

	/**
	 * Gets / sets the texture to use when rendering the entity.
	 * @param {IgeTexture=} texture The texture object.
	 * @example #Set the entity texture (image)
	 *     var texture = new IgeTexture('path/to/some/texture.png');
	 *     entity.texture(texture);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	texture: function (texture) {
		return this.renderable.texture(texture);
	},

	/**
	 * Gets / sets the current texture cell used when rendering the game
	 * object's texture. If the texture is not cell-based, this value is
	 * ignored.
	 * @param {Number=} val The cell index.
	 * @example #Set the entity texture as a 4x4 cell sheet and then set the cell to use
	 *     var texture = new IgeCellSheet('path/to/some/cellSheet.png', 4, 4);
	 *     entity.texture(texture)
	 *         .cell(3);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	cell: function (val) {
		return this.renderable.cell(val);
	},

	/**
	 * Gets / sets the current texture cell used when rendering the game
	 * object's texture. If the texture is not cell-based, this value is
	 * ignored. This differs from cell() in that it accepts a string id
	 * as the cell
	 * @param {Number=} val The cell id.
	 * @example #Set the entity texture as a sprite sheet with cell ids and then set the cell to use
	 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
	 *         [0, 0, 40, 40, 'robotHead'],
	 *         [40, 0, 40, 40, 'humanHead'],
	 *     ]);
	 *     
	 *     // Assign the texture, set the cell to use and then
	 *     // set the entity to the size of the cell automatically!
	 *     entity.texture(texture)
	 *         .cellById('robotHead')
	 *         .dimensionsFromCell();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	cellById: function (val) {
		if (val !== undefined) {
			if (this.texture()) {
				// Find the cell index this id corresponds to
				var i,
					tex = this.texture(),
					cells = tex._cells;

				for (i = 1; i < cells.length; i++) {
					if (cells[i][4] === val) {
						// Found the cell id so assign this cell index
						this.cell(i);
						return this;
					}
				}

				// We were unable to find the cell index from the cell
				// id so produce an error
				this.log('Could not find the cell id "' + val + '" in the assigned entity texture ' + tex.id() + ', please check your sprite sheet (texture) cell definition to ensure the cell id "' + val + '" has been assigned to a cell!', 'error');
			} else {
				this.log('Cannot assign cell index from cell ID until an IgeSpriteSheet has been set as the texture for this entity. Please set the texture before calling cellById().', 'error');
			}
		}

		return this.cell();
	},

	/**
	 * Sets the geometry of the entity to match the width and height
	 * of the assigned texture.
	 * @param {Number=} percent The percentage size to resize to.
	 * @example #Set the entity dimensions based on the assigned texture
	 *     var texture = new IgeTexture('path/to/some/texture.png');
	 *	
	 *     // Assign the texture, and then set the entity to the
	 *     // size of the texture automatically!
	 *     entity.texture(texture)
	 *         .dimensionsFromTexture();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	dimensionsFromTexture: function (percent) {
		if (this.texture()) {
			if (percent === undefined) {
				this.width(this.texture()._sizeX);
				this.height(this.texture()._sizeY);
			} else {
				this.width(Math.floor(this.texture()._sizeX / 100 * percent));
				this.height(Math.floor(this.texture()._sizeY / 100 * percent));
			}

			// Recalculate localAabb
			this.localAabb(true);
		}

		return this;
	},

	/**
	 * Sets the geometry of the entity to match the width and height
	 * of the assigned texture cell. If the texture is not cell-based
	 * the entire texture width / height will be used.
	 * @param {Number=} percent The percentage size to resize to.
	 * @example #Set the entity dimensions based on the assigned texture and cell
	 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
	 *         [0, 0, 40, 40, 'robotHead'],
	 *         [40, 0, 40, 40, 'humanHead'],
	 *     ]);
	 *
	 *     // Assign the texture, set the cell to use and then
	 *     // set the entity to the size of the cell automatically!
	 *     entity.texture(texture)
	 *         .cellById('robotHead')
	 *         .dimensionsFromCell();
	 * @return {*} The object this method was called from to allow
	 * method chaining
	 */
	dimensionsFromCell: function (percent) {
		if (this.texture()) {
			if (this.texture()._cells && this.texture()._cells.length) {
				if (percent === undefined) {
					this.width(this.texture()._cells[this.cell()][2]);
					this.height(this.texture()._cells[this.cell()][3]);
				} else {
					this.width(Math.floor(this.texture()._cells[this.cell()][2] / 100 * percent));
					this.height(Math.floor(this.texture()._cells[this.cell()][3] / 100 * percent));
				}
				
				// Recalculate localAabb
				this.localAabb(true);
			}
		}

		return this;
	},

	/**
	 * Gets / sets the highlight mode. True is on false is off.
	 * @param {Boolean} val The highlight mode true or false.
	 * @example #Set the entity to render highlighted
	 *     entity.highlight(true);
	 * @example #Get the current highlight state
	 *     var isHighlighted = entity.highlight();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	highlight: function (val) {
		return this.renderable.highlight(val);
	},

	/**
	 * Returns the absolute world position of the entity as an
	 * IgePoint3d.
	 * @example #Get the world position of the entity
	 *     var wordPos = entity.worldPosition();
	 * @return {IgePoint3d} The absolute world position of the
	 * entity.
	 */
	worldPosition: function () {
		return new IgePoint3d(this._worldMatrix.matrix[2], this._worldMatrix.matrix[5], 0);
	},

	/**
	 * Returns the absolute world rotation z of the entity as a
	 * value in radians.
	 * @example #Get the world rotation of the entity's z axis
	 *     var wordRot = entity.worldRotationZ();
	 * @return {Number} The absolute world rotation z of the
	 * entity.
	 */
	worldRotationZ: function () {
		return this._worldMatrix.rotationRadians();
	},

	/**
	 * Converts an array of points from local space to this entity's
	 * world space using it's world transform matrix. This will alter
	 * the points passed in the array directly.
	 * @param {Array} points The array of IgePoints to convert.
	 */
	localToWorld: function (points, viewport, inverse) {
		// TODO: Remove this check once the IgeEngine is no longer an IgeEntity
		if (ige === this) {
			return;
		}
		viewport = viewport || ige._currentViewport;
		
		if (this._adjustmentMatrix) {
			// Apply the optional adjustment matrix
			this._worldMatrix.multiply(this._adjustmentMatrix);
		}
		
		if (!inverse) {
			this._worldMatrix.transform(points, this);
		} else {
			this._localMatrix.transform(points, this);
			//this._worldMatrix.getInverse().transform(points, this);
		}

		if (this._ignoreCamera) {
			//viewport.camera._worldMatrix.transform(points, this);
		}
	},

	/**
	 * Converts a point from local space to this entity's world space
	 * using it's world transform matrix. This will alter the point's
	 * data directly.
	 * @param {IgePoint3d} point The IgePoint3d to convert.
	 */
	localToWorldPoint: function (point, viewport) {
		viewport = viewport || ige._currentViewport;
		this._worldMatrix.transform([point], this);
	},
	
	/**
	 * Returns the screen position of the entity as an IgePoint3d where x is the
	 * "left" and y is the "top", useful for positioning HTML elements at the
	 * screen location of an IGE entity. This method assumes that the top-left
	 * of the main canvas element is at 0, 0. If not you can adjust the values
	 * yourself to allow for offset.
	 * @example #Get the screen position of the entity
	 *     var screenPos = entity.screenPosition();
	 * @return {IgePoint3d} The screen position of the entity.
	 */
	screenPosition: function () {
		return new IgePoint3d(
			Math.floor(((this._worldMatrix.matrix[2] - ige._currentCamera._translate.x) * ige._currentCamera._scale.x) + ige._bounds2d.x2),
			Math.floor(((this._worldMatrix.matrix[5] - ige._currentCamera._translate.y) * ige._currentCamera._scale.y) + ige._bounds2d.y2),
			0
		);
	},
	
	/**
	 * @deprecated Use bounds3dPolygon instead
	 */
	localIsoBoundsPoly: function () {},
	
	localBounds3dPolygon: function (recalculate) {
		if (this._bounds3dPolygonDirty || !this._localBounds3dPolygon || recalculate) {
			var geom = this._bounds3d,
				poly = new IgePoly2d(),
				// Bottom face
				bf2 = Math.toIso(+(geom.x2), -(geom.y2),  -(geom.z2)),
				bf3 = Math.toIso(+(geom.x2), +(geom.y2),  -(geom.z2)),
				bf4 = Math.toIso(-(geom.x2), +(geom.y2),  -(geom.z2)),
				// Top face
				tf1 = Math.toIso(-(geom.x2), -(geom.y2),  (geom.z2)),
				tf2 = Math.toIso(+(geom.x2), -(geom.y2),  (geom.z2)),
				tf4 = Math.toIso(-(geom.x2), +(geom.y2),  (geom.z2));
			
			poly.addPoint(tf1.x, tf1.y)
				.addPoint(tf2.x, tf2.y)
				.addPoint(bf2.x, bf2.y)
				.addPoint(bf3.x, bf3.y)
				.addPoint(bf4.x, bf4.y)
				.addPoint(tf4.x, tf4.y)
				.addPoint(tf1.x, tf1.y);
			
			this._localBounds3dPolygon = poly;
			this._bounds3dPolygonDirty = false;
		}
		
		return this._localBounds3dPolygon;
	},
	
	/**
	 * @deprecated Use bounds3dPolygon instead
	 */
	isoBoundsPoly: function () {},
	
	bounds3dPolygon: function (recalculate) {
		if (this._bounds3dPolygonDirty || !this._bounds3dPolygon || recalculate) {
			var poly = this.localBounds3dPolygon(recalculate).clone();
			
			// Convert local co-ordinates to world based on entities world matrix
			this.localToWorld(poly._poly);
			
			this._bounds3dPolygon = poly;
		}
		
		return this._bounds3dPolygon;
	},

	/**
	 * @deprecated Use mouseInBounds3d instead
	 */
	mouseInIsoBounds: function () {},
	
	mouseInBounds3d: function (recalculate) {
		var poly = this.localBounds3dPolygon(recalculate),
			mp = this.mousePos();
		
		return poly.pointInside(mp);
	},

	/**
	 * Calculates and returns the current axis-aligned bounding box in
	 * world co-ordinates.
	 * @param {Boolean=} recalculate If true this will force the
	 * recalculation of the AABB instead of returning a cached
	 * value.
	 * @example #Get the entity axis-aligned bounding box dimensions
	 *     var aabb = entity.aabb();
	 *     
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @example #Get the entity axis-aligned bounding box dimensions forcing the engine to update the values first
	 *     var aabb = entity.aabb(true); // Call with true to force update
	 *     
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @return {IgeRect} The axis-aligned bounding box in world co-ordinates.
	 */
	aabb: function (recalculate, inverse) {
		// TODO: Remove this check once the IgeEngine is no longer an IgeEntity
		if (ige === this) {
			return;
		}

		if (this._aabbDirty || !this._aabb || recalculate) { //  && this.newFrame()
			var poly = new IgePoly2d(),
				minX, minY,
				maxX, maxY,
				box,
				anc = this.anchor(),
				ancX = anc.x,
				ancY = anc.y,
				geom,
				geomX2,
				geomY2,
				x, y;

			geom = this._bounds2d;
			geomX2 = geom.x2;
			geomY2 = geom.y2;
			
			x = geomX2;
			y = geomY2;

			poly.addPoint(-x + ancX, -y + ancY);
			poly.addPoint(x + ancX, -y + ancY);
			poly.addPoint(x + ancX, y + ancY);
			poly.addPoint(-x + ancX, y + ancY);

			if (this.renderable) {
				this.renderable._renderPos = {x: -x + ancX, y: -y + ancY};
			}

			// Convert the poly's points from local space to world space
			this.localToWorld(poly._poly, null, inverse);

			// Get the extents of the newly transformed poly
			minX = Math.min(
				poly._poly[0].x,
				poly._poly[1].x,
				poly._poly[2].x,
				poly._poly[3].x
			);

			minY = Math.min(
				poly._poly[0].y,
				poly._poly[1].y,
				poly._poly[2].y,
				poly._poly[3].y
			);

			maxX = Math.max(
				poly._poly[0].x,
				poly._poly[1].x,
				poly._poly[2].x,
				poly._poly[3].x
			);

			maxY = Math.max(
				poly._poly[0].y,
				poly._poly[1].y,
				poly._poly[2].y,
				poly._poly[3].y
			);

			box = new IgeRect(minX, minY, maxX - minX, maxY - minY);

			this._aabb = box;
			this._aabbDirty = false;
		}

		return this._aabb;
	},

	/**
	 * Calculates and returns the local axis-aligned bounding box
	 * for the entity. This is the AABB relative to the entity's
	 * center point.
	 * @param {Boolean=} recalculate If true this will force the
	 * recalculation of the local AABB instead of returning a cached
	 * value.
	 * @example #Get the entity local axis-aligned bounding box dimensions
	 *     var aabb = entity.localAabb();
	 *	
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @example #Get the entity local axis-aligned bounding box dimensions forcing the engine to update the values first
	 *     var aabb = entity.localAabb(true); // Call with true to force update
	 *	
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @return {IgeRect} The local AABB.
	 */
	localAabb: function (recalculate) {
		if (!this._localAabb || recalculate) {
			var aabb = this.aabb();
			this._localAabb = new IgeRect(-Math.floor(aabb.width / 2), -Math.floor(aabb.height / 2), Math.floor(aabb.width), Math.floor(aabb.height));
		}

		return this._localAabb;
	},

	/**
	 * Calculates the axis-aligned bounding box for this entity, including
	 * all child entity bounding boxes and returns the final composite
	 * bounds.
	 * @example #Get the composite AABB
	 *     var entity = new IgeEntity(),
	 *         aabb = entity.compositeAabb();
	 * @return {IgeRect}
	 */
	compositeAabb: function (inverse) {
		var arr = this._children,
			arrCount,
			rect;
	
		if (inverse) {
			rect = this.aabb(true, inverse).clone();
		} else {
			rect = this.aabb().clone();	
		}

		// Now loop all children and get the aabb for each of them
		// them add those bounds to the current rect
		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				rect.thisCombineRect(arr[arrCount].compositeAabb(inverse));
			}
		}

		return rect;
	},

	/**
	 * Gets / sets the composite stream flag. If set to true, any objects
	 * mounted to this one will have their streamMode() set to the same
	 * value as this entity and will also have their compositeStream flag
	 * set to true. This allows you to easily automatically stream any
	 * objects mounted to a root object and stream them all.
	 * @param val
	 * @returns {*}
	 */
	compositeStream: function (val) {
		if (val !== undefined) {
			this._compositeStream = val;
			return this;
		}
		
		return this._compositeStream;
	},

	/**
	 * Override the _childMounted method and apply entity-based flags.
	 * @param {IgeEntity} child
	 * @private
	 */
	_childMounted: function (child) {
		// Check if we need to set the compositeStream and streamMode
		if (this.compositeStream()) {
			child.compositeStream(true);
			child.streamMode(this.streamMode());
			child.streamControl(this.streamControl());
		}
		
		IgeObject.prototype._childMounted.call(this, child);

		// TODO: Remove ige !== this comparison once IgeEngine is no longer an IgeEntity
		// Check if we are compositeCached and update the cache
		if (ige !== this && this.compositeCache()) {
			this.cacheDirty(true);
		}
	},
	
	/**
	 * Takes two values and returns them as an array where index [0]
	 * is the y argument and index[1] is the x argument. This method
	 * is used specifically in the 3d bounds intersection process to
	 * determine entity depth sorting.
	 * @param {Number} x The first value.
	 * @param {Number} y The second value.
	 * @return {Array} The swapped arguments.
	 * @private
	 */
	_swapVars: function (x, y) {
		return [y, x];
	},

	_internalsOverlap: function (x0, x1, y0, y1) {
		var tempSwap;

		if (x0 > x1) {
			tempSwap = this._swapVars(x0, x1);
			x0 = tempSwap[0];
			x1 = tempSwap[1];
		}

		if (y0 > y1) {
			tempSwap = this._swapVars(y0, y1);
			y0 = tempSwap[0];
			y1 = tempSwap[1];
		}

		if (x0 > y0) {
			tempSwap = this._swapVars(x0, y0);
			x0 = tempSwap[0];
			y0 = tempSwap[1];

			tempSwap = this._swapVars(x1, y1);
			x1 = tempSwap[0];
			y1 = tempSwap[1];
		}

		return y0 < x1;
	},

	_projectionOverlap: function (otherObject) {
		var thisG3d = this._bounds3d,
			thisMin = {
				x: this._translate.x - thisG3d.x / 2,
				y: this._translate.y - thisG3d.y / 2,
				z: this._translate.z - thisG3d.z
			},
			thisMax = {
				x: this._translate.x + thisG3d.x / 2,
				y: this._translate.y + thisG3d.y / 2,
				z: this._translate.z + thisG3d.z
			},
			otherG3d = otherObject._bounds3d,
			otherMin = {
				x: otherObject._translate.x - otherG3d.x / 2,
				y: otherObject._translate.y - otherG3d.y / 2,
				z: otherObject._translate.z - otherG3d.z
			},
			otherMax = {
				x: otherObject._translate.x + otherG3d.x / 2,
				y: otherObject._translate.y + otherG3d.y / 2,
				z: otherObject._translate.z + otherG3d.z
			};

		return this._internalsOverlap(
			thisMin.x - thisMax.y,
			thisMax.x - thisMin.y,
			otherMin.x - otherMax.y,
			otherMax.x - otherMin.y
		) && this._internalsOverlap(
			thisMin.x - thisMax.z,
			thisMax.x - thisMin.z,
			otherMin.x - otherMax.z,
			otherMax.x - otherMin.z
		) && this._internalsOverlap(
			thisMin.z - thisMax.y,
			thisMax.z - thisMin.y,
			otherMin.z - otherMax.y,
			otherMax.z - otherMin.y
		);
	},

	/**
	 * Compares the current entity's 3d bounds to the passed entity and
	 * determines if the current entity is "behind" the passed one. If an
	 * entity is behind another, it is drawn first during the scenegraph
	 * render phase.
	 * @param {IgeEntity} otherObject The other entity to check this
	 * entity's 3d bounds against.
	 * @example #Determine if this entity is "behind" another entity based on the current depth-sort 
	 *     var behind = entity.isBehind(otherEntity);
	 * @return {Boolean} If true this entity is "behind" the passed entity
	 * or false if not.
	 */
	isBehind: function (otherObject) {
		var thisG3d = this._bounds3d,
			thisMin = new IgePoint3d(
				this._translate.x - thisG3d.x / 2,
				this._translate.y - thisG3d.y / 2,
				this._translate.z
			),
			thisMax = new IgePoint3d(
				this._translate.x + thisG3d.x / 2,
				this._translate.y + thisG3d.y / 2,
				this._translate.z + thisG3d.z
			),
			otherG3d = otherObject._bounds3d,
			otherMin = new IgePoint3d(
				otherObject._translate.x - otherG3d.x / 2,
				otherObject._translate.y - otherG3d.y / 2,
				otherObject._translate.z
			),
			otherMax = new IgePoint3d(
				otherObject._translate.x + otherG3d.x / 2,
				otherObject._translate.y + otherG3d.y / 2,
				otherObject._translate.z + otherG3d.z
			);

		if (thisMax.x <= otherMin.x) {
			return false;
		}

		if (otherMax.x <= thisMin.x) {
			return true;
		}

		if (thisMax.y <= otherMin.y) {
			return false;
		}

		if (otherMax.y <= thisMin.y) {
			return true;
		}

		if (thisMax.z <= otherMin.z) {
			return false;
		}

		if (otherMax.z <= thisMin.z) {
			return true;
		}

		// Entity's are overlapping, calc based on x+y+z
		return ((this._translate.x + this._translate.y + this._translate.z) > (otherObject._translate.x + otherObject._translate.y + otherObject._translate.z));
	},

	/**
	 * Get / set the flag determining if this entity will respond
	 * to mouse interaction or not. When you set a mouse* event e.g.
	 * mouseUp, mouseOver etc this flag will automatically be reset
	 * to true.
	 * @param {Boolean=} val The flag value true or false.
	 * @example #Set entity to ignore mouse events
	 *     entity.mouseEventsActive(false);
	 * @example #Set entity to receive mouse events
	 *     entity.mouseEventsActive(true);
	 * @example #Get current flag value
	 *     var val = entity.mouseEventsActive();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	mouseEventsActive: function (val) {
		if (val !== undefined) {
			this._mouseEventsActive = val;
			return this;
		}

		return this._mouseEventsActive;
	},

	/**
	 * Sets the _ignoreCamera internal flag to the value passed for this
	 * and all child entities down the scenegraph.
	 * @param val
	 */
	ignoreCameraComposite: function (val) {
		var i,
			arr = this._children,
			arrCount = arr.length;
		
		this._ignoreCamera = val;
		
		for (i = 0; i < arrCount; i++) {
			if (arr[i].ignoreCameraComposite) {
				arr[i].ignoreCameraComposite(val);
			}
		}
	},

	/**
	 * Determines if the frame alternator value for this entity
	 * matches the engine's frame alternator value. The entity's
	 * frame alternator value will be set to match the engine's
	 * after each call to the entity.tick() method so the return
	 * value of this method can be used to determine if the tick()
	 * method has already been run for this entity.
	 *
	 * This is useful if you have multiple viewports which will
	 * cause the entity tick() method to fire once for each viewport
	 * but you only want to execute update code such as movement etc
	 * on the first time the tick() method is called.
	 * 
	 * @example #Determine if the entity has already had it's tick method called
	 *     var tickAlreadyCalled = entity.newFrame();
	 * @return {Boolean} If false, the entity's tick method has
	 * not yet been processed for this tick.
	 */
	newFrame: function () {
		return ige._frameAlternator !== this._frameAlternatorCurrent;
	},

	/**
	 * Sets the canvas context transform properties to match the the game
	 * object's current transform values.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to apply
	 * the transformation matrix to.
	 * @example #Transform a canvas context to the entity's local matrix values
	 *     var canvas = document.createElement('canvas');
	 *     canvas.width = 800;
	 *     canvas.height = 600;
	 *
	 *     var ctx = canvas.getContext('2d');
	 *     entity._transformContext(ctx);
	 * @private
	 */
	_transformContext: function (ctx, inverse) {
		//this.renderable._transformContext(ctx, inverse);
		if (this._parent && this._parent.renderable) {
			ctx.globalAlpha = this.renderable._computedOpacity = this._parent.renderable._computedOpacity * this.opacity();
		} else {
			ctx.globalAlpha = this.renderable._computedOpacity = this.opacity();
		}

		if (!inverse) {
			this._localMatrix.transformRenderingContext(ctx);
		} else {
			this._localMatrix.getInverse().transformRenderingContext(ctx);
		}
	},
	
	mouseAlwaysInside: function (val) {
		if (val !== undefined) {
			this._mouseAlwaysInside = val;
			return this;
		}
		
		return this._mouseAlwaysInside;
	},

	/**
	 * Processes the updates required each render frame. Any code in the update()
	 * method will be called ONCE for each render frame BEFORE the tick() method.
	 * This differs from the tick() method in that the tick method can be called
	 * multiple times during a render frame depending on how many viewports your
	 * simulation is being rendered to, whereas the update() method is only called
	 * once. It is therefore the perfect place to put code that will control your
	 * entity's motion, AI etc.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 */
	update: function (ctx, tickDelta) {
		// Check if the entity should still exist
		if (this._deathTime !== undefined && this._deathTime <= ige._tickStart) {
			// Check if the deathCallBack was set
			if (this._deathCallBack) {
				this._deathCallBack.apply(this);
				delete this._deathCallback;
			}
			
			// The entity should be removed because it has died
			this.destroy();
			return;
		}

		// _streamEntityValid is set to false when the server invalidates the
		// client-side entity. If the server determines that this entity should
		// be invisible to a client, skip the client-side update.
		if (this._streamEntityValid === false) {
			return;
		}

		// Check that the entity has been born
		if (this._bornTime === undefined || ige._currentTime >= this._bornTime) {
			// Remove the stream data cache
			delete this._streamDataCache;
			delete this._streamPrivateDataCache;

			// Process any behaviours assigned to the entity
			this._processUpdateBehaviours(ctx, tickDelta);

			// Process velocity
			if (this._velocity.x || this._velocity.y) {
				this._translate.x += (this._velocity.x / 16) * tickDelta;
				this._translate.y += (this._velocity.y / 16) * tickDelta;
			}

			if (this._timeStream.length) {
				// Process any interpolation
				this._processInterpolate(ige._tickStart - ige.network.stream._renderLatency);
			}

			// Check for changes to the transform values
			// directly without calling the transform methods
			this.updateTransform();

			if (!this._noAabb && this._aabbDirty) {
				// Update the aabb
				this.aabb();
			}

			// Update this object's current frame alternator value
			// which allows us to determine if we are still on the
			// same frame
			this._frameAlternatorCurrent = ige._frameAlternator;
		} else {
			// The entity is not yet born, unmount it and add to the spawn queue
			this._birthMount = this._parent.id();
			this.unMount();

			ige.spawnQueue(this);
		}


		if (this._updateChildren) {
			if (this._updateChildrenNeeded) {
				IgeObject.prototype.update.call(this, ctx, tickDelta);
				this._updateChildrenNeeded = false;
			}
		}
		else {
			// Process children
			IgeObject.prototype.update.call(this, ctx, tickDelta);

		}
	},

	/**
	 * Processes the actions required each render frame.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 * @param {Boolean} dontTransform If set to true, the tick method will
	 * not transform the context based on the entity's matrices. This is useful
	 * if you have extended the class and want to process down the inheritance
	 * chain but have already transformed the entity in a previous overloaded
	 * method.
	 */
	tick: function (ctx, dontTransform) {
		// _streamEntityValid is set to false when the server invalidates the
		// client-side entity. If the server determines that this entity should
		// be invisible to a client, skip the client-side update.
		if (this._streamEntityValid === false) {
			return;
		}

		// TODO: No need to check if this._parent.renderable exists after IgeEngine is no longer an IgeEntity
		if (this._inView && !this._streamJustCreated &&
			(this._streamEntityValid !== false) &&
			(!this._parent || (this._parent && this._parent._inView))) {
			// Process any behaviours assigned to the entity
			this._processTickBehaviours(ctx);
			
			// Process any mouse events we need to do
			if (this._mouseEventsActive) {
				if (this._processTriggerHitTests()) {
					// Point is inside the trigger bounds
					ige.input.queueEvent(this, this._mouseInTrigger, null);
				} else {
					if (ige.input.mouseMove) {
						// There is a mouse move event but we are not inside the entity
						// so fire a mouse out event (_handleMouseOut will check if the
						// mouse WAS inside before firing an out event).
						this._handleMouseOut(ige.input.mouseMove);
					}
				}
			}

			/*if (!this._dontRender) {
				// Check for cached version
				if (this.renderable._cache || this.renderable._compositeCache) {
					// Caching is enabled
					if (this._cacheDirty) {
						// The cache is dirty, redraw it
						this._refreshCache(dontTransform);
					}
					
					// Now render the cached image data to the main canvas
					this._renderCache(ctx);
				} else {
					// Non-cached output
					// Transform the context by the current transform settings
					if (!dontTransform) {
						this._transformContext(ctx);
					}
					
					// Render the entity
					this._renderEntity(ctx, dontTransform);
				}
			}*/

			// Process any automatic-mode stream updating required
			if (this._streamMode === 1) {
				this.streamSync();
			}

			/*if (this.renderable._compositeCache) {
				if (this._cacheDirty) {
					// Process children
					IgeObject.prototype.tick.call(this, this._cacheCtx);
					this._renderCache(ctx);
					this._cacheDirty = false;
				}
			} else {*/
				// Process children
				IgeObject.prototype.tick.call(this, ctx);
			//}
		}
	},
	
	_processTriggerHitTests: function () {
		var mp, mouseTriggerPoly;

		if (ige._currentViewport) {
			if (!this._mouseAlwaysInside) {
				mp = this.mousePosWorld();
	
				if (mp) {
					// Use the trigger polygon if defined
					if (this._triggerPolygon && this[this._triggerPolygon]) {
						mouseTriggerPoly = this[this._triggerPolygon](mp);
					} else {
						// Default to either aabb or bounds3dPolygon depending on entity parent mounting mode
						if (this._parent && this._parent._mountMode === 1) {
							// Use bounds3dPolygon
							mouseTriggerPoly = this.bounds3dPolygon();
						} else {
							// Use aabb
							mouseTriggerPoly = this.aabb();
						}
					}
					
					// Check if the current mouse position is inside this aabb
					return mouseTriggerPoly.xyInside(mp.x, mp.y);
				}
			} else {
				return true;
			}
		}
		
		return false;
	},

	/**
	 * Gets / sets the depth sort mode that is used when
	 * depth sorting this object's children against each other. This
	 * mode only applies if this object's mount mode is isometric,
	 * as set by calling isometricMounts(true). If the mount mode is
	 * 2d, the depth sorter will use a very fast 2d depth sort that
	 * does not use 3d bounds at all.
	 * @param {Number=} val The mode to use when depth sorting
	 * this object's children, given as an integer value.
	 * @example #Turn off all depth sorting for this object's children
	 *     entity.depthSortMode(-1);
	 * @example #Use 3d bounds when sorting this object's children
	 *     entity.depthSortMode(0);
	 * @example #Use 3d bounds optimised for mostly cube-shaped bounds when sorting this object's children
	 *     entity.depthSortMode(1);
	 * @example #Use 3d bounds optimised for all cube-shaped bounds when sorting this object's children
	 *     entity.depthSortMode(2);
	 * @return {*}
	 */
	depthSortMode: function (val) {
		if (val !== undefined) {
			this._depthSortMode = val;
			return this;
		}

		return this._depthSortMode;
	},

	/**
	 * Sorts the _children array by the layer and then depth of each object.
	 */
	depthSortChildren: function () {
		if (this._depthSortMode !== -1) {
			// TODO: Optimise this method, it is not especially efficient at the moment!
			var arr = this._children,
				arrCount,
				sortObj,
				i, j;

			if (arr) {
				arrCount = arr.length;

				// See if we can bug-out early
				if (arrCount > 1) {
					// Check if the mount mode is isometric
					if (this._mountMode === 1) {
						// Check the depth sort mode
						if (this._depthSortMode === 0) { // Slowest, uses 3d bounds
							// Calculate depths from 3d bounds
							sortObj = {
								adj: [],
								c: [],
								p: [],
								order: [],
								order_ind: arrCount - 1
							};

							for (i = 0; i < arrCount; ++i) {
								sortObj.c[i] = 0;
								sortObj.p[i] = -1;

								for (j = i + 1; j < arrCount; ++j) {
									sortObj.adj[i] = sortObj.adj[i] || [];
									sortObj.adj[j] = sortObj.adj[j] || [];

									if (arr[i]._inView && arr[j]._inView && arr[i]._projectionOverlap && arr[j]._projectionOverlap) {
										if (arr[i]._projectionOverlap(arr[j])) {
											if (arr[i].isBehind(arr[j])) {
												sortObj.adj[j].push(i);
											} else {
												sortObj.adj[i].push(j);
											}
										}
									}
								}
							}

							for (i = 0; i < arrCount; ++i) {
								if (sortObj.c[i] === 0) {
									this._depthSortVisit(i, sortObj);
								}
							}

							for (i = 0; i < sortObj.order.length; i++) {
								arr[sortObj.order[i]].depth(i);
							}

							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									return b._depth - a._depth;
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}

						if (this._depthSortMode === 1) { // Medium speed, optimised for almost-cube shaped 3d bounds
							// Now sort the entities by depth
							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									//if (a._projectionOverlap(b)) {
									if (a.isBehind(b)) {
										return -1;
									} else {
										return 1;
									}
									//}
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}

						if (this._depthSortMode === 2) { // Fastest, optimised for cube-shaped 3d bounds
							while (arrCount--) {
								sortObj = arr[arrCount];
								j = sortObj._translate;

								if (j) {
									sortObj._depth = j.x + j.y + j.z;
								}
							}

							// Now sort the entities by depth
							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									return b._depth - a._depth;
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}
					} else { // 2d mode
						// Now sort the entities by depth
						this._children.sort(function (a, b) {
							var layerIndex = b._layer - a._layer;

							if (layerIndex === 0) {
								// On same layer so sort by depth
								return b._depth - a._depth;
							} else {
								// Not on same layer so sort by layer
								return layerIndex;
							}
						});
					}
				}
			}
		}
	},

	/**
	 * ALPHA CODE DO NOT USE YET.
	 * When view checking is enabled, this method is called to
	 * determine if this object is within the bounds of an active
	 * viewport, essentially determining if the object is
	 * "on screen" or not.
	 */
	viewCheckChildren: function () {
		if (ige._currentViewport) {
			var arr = this._children,
				arrCount = arr.length,
				vpViewArea = ige._currentViewport.viewArea(),
				item;

			while (arrCount--) {
				item = arr[arrCount];

				if (item._alwaysInView) {
					item._inView = true;
				} else {
					if (item.aabb) {
						// Check the entity to see if its bounds are "inside" the
						// viewport's visible area
						if (vpViewArea.intersects(item.aabb(true))) {
							// The entity is inside the viewport visible area
							item._inView = true;
						} else {
							item._inView = false;
						}
					} else {
						item._inView = false;
					}
				}
			}
		}

		return this;
	},
	
	_refreshCache: function (dontTransform) {
		// The cache is not clean so re-draw it
		// Render the entity to the cache
		var _canvas = this._cacheCanvas,
			_ctx = this._cacheCtx;

		if (this.renderable._compositeCache) {
			// Get the composite entity AABB and alter the internal canvas
			// to the composite size so we can render the entire entity
			var aabbC = this.compositeAabb(true);
			
			this._compositeAabbCache = aabbC;
			
			if (aabbC.width > 0 && aabbC.height > 0) {
				_canvas.width = Math.ceil(aabbC.width);
				_canvas.height = Math.ceil(aabbC.height);
			} else {
				// We cannot set a zero size for a canvas, it will
				// cause the browser to freak out
				_canvas.width = 2;
				_canvas.height = 2;
			}
			
			// Translate to the center of the canvas
			_ctx.translate(-aabbC.x, -aabbC.y);

			/**
			 * Fires when the entity's composite cache is ready.
			 * @event IgeEntity#compositeReady
			 */
			this.emit('compositeReady');
		} else {
			if (this._bounds2d.x > 0 && this._bounds2d.y > 0) {
				_canvas.width = this._bounds2d.x;
				_canvas.height = this._bounds2d.y;
			} else {
				// We cannot set a zero size for a canvas, it will
				// cause the browser to freak out
				_canvas.width = 1;
				_canvas.height = 1;
			}
			
			// Translate to the center of the canvas
			_ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
			
			this._cacheDirty = false;
		}
		
		// Transform the context by the current transform settings
		if (!dontTransform) {
			this._transformContext(_ctx);
		}
		
		this._renderEntity(_ctx, dontTransform);
	},

	/**
	 * Handles calling the texture.render() method if a texture
	 * is applied to the entity. This part of the tick process has
	 * been abstracted to allow it to be overridden by an extending
	 * class.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render
	 * the entity to.
	 * @private
	 */
	_renderEntity: function (ctx) {
		if (this.opacity() > 0) {
			// Check if the entity has a background pattern
			if (this._backgroundPattern) {
				if (!this._backgroundPatternFill) {
					// We have a pattern but no fill produced
					// from it. Check if we have a context to
					// generate a pattern from
					if (ctx) {
						// Produce the pattern fill
						this._backgroundPatternFill = ctx.createPattern(this._backgroundPattern.image, this._backgroundPatternRepeat);
					}
				}

				if (this._backgroundPatternFill) {
					// Draw the fill
					ctx.save();
					ctx.fillStyle = this._backgroundPatternFill;

					// TODO: When firefox has fixed their bug regarding negative rect co-ordinates, revert this change

					// This is the proper way to do this but firefox has a bug which I'm gonna report
					// so instead I have to use ANOTHER translate call instead. So crap!
					//ctx.rect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
					ctx.translate(-this._bounds2d.x2, -this._bounds2d.y2);
					ctx.rect(0, 0, this._bounds2d.x, this._bounds2d.y);
					if (this._backgroundPatternTrackCamera) {
						ctx.translate(-ige._currentCamera._translate.x, -ige._currentCamera._translate.y);
						ctx.scale(ige._currentCamera._scale.x, ige._currentCamera._scale.y);
					}
					ctx.fill();
					ige._drawCount++;

					if (this._backgroundPatternIsoTile) {
						ctx.translate(-Math.floor(this._backgroundPattern.image.width) / 2, -Math.floor(this._backgroundPattern.image.height / 2));
						ctx.fill();
						ige._drawCount++;
					}

					ctx.restore();
				}
			}

			var texture = this.texture();

			// Check if the entity is visible based upon its opacity
			if (texture && texture._loaded) {
				// Draw the entity image
				texture.render(ctx, this, ige._tickDelta);

				if (this.highlight()) {
					ctx.globalCompositeOperation = 'lighter';
					texture.render(ctx, this);
				}
			}
			
			if (this.renderable._compositeCache && ige._currentViewport._drawCompositeBounds) {
				//console.log('moo');
				ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
				ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x,	this._bounds2d.y);
				ctx.fillStyle = '#ffffff';
				ctx.fillText('Composite Entity', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
				ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
			}
		}
	},

	_renderPixiEntity: function (parent) {
		if (this._pixiDisplayObject && parent._pixiDisplayObject) {
			this._pixiDisplayObject.position.x = this._translate.x;
			this._pixiDisplayObject.position.y = this._translate.y;
			this._pixiDisplayObject.rotation = this._rotate.z;
			parent._pixiDisplayObject.addChild(this._pixiDisplayObject);
		}
	},

	/**
	 * Draws the cached off-screen canvas image data to the passed canvas
	 * context.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render
	 * the entity to.
	 * @private
	 */
	_renderCache: function (ctx) {
		ctx.save();
		if (this.renderable._compositeCache) {
			var aabbC = this._compositeAabbCache;
			ctx.translate(this._bounds2d.x2 + aabbC.x, this._bounds2d.y2 + aabbC.y);
			
			if (this._parent && this._parent._ignoreCamera) {
				// Translate the entity back to negate the scene translate
				var cam = ige._currentCamera;
				//ctx.translate(-cam._translate.x, -cam._translate.y);
				this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
				this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);
			}
		}
		
		// We have a clean cached version so output that
		ctx.drawImage(
			this._cacheCanvas,
			-this._bounds2d.x2, -this._bounds2d.y2
		);
		
		if (ige._currentViewport._drawCompositeBounds) {
			ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
			ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._cacheCanvas.width,	this._cacheCanvas.height);
			ctx.fillStyle = '#ffffff';
			ctx.fillText('Composite Cache', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
			ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
		}

		ige._drawCount++;

		if (this.highlight()) {
			ctx.globalCompositeOperation = 'lighter';
			ctx.drawImage(
				this._cacheCanvas,
				-this._bounds2d.x2, -this._bounds2d.y2
			);

			ige._drawCount++;
		}
		ctx.restore();
	},

	/**
	 * Transforms a point by the entity's parent world matrix and
	 * it's own local matrix transforming the point to this entity's
	 * world space.
	 * @param {IgePoint3d} point The point to transform.
	 * @example #Transform a point by the entity's world matrix values
	 *     var point = new IgePoint3d(0, 0, 0);
	 *     entity._transformPoint(point);
	 *     
	 *     console.log(point);
	 * @return {IgePoint3d} The transformed point.
	 * @private
	 */
	_transformPoint: function (point) {
		// this.renderable._transformPoint(point);
		if (this._parent) {
			var tempMat = new IgeMatrix2d();
			// Copy the parent world matrix
			tempMat.copy(this._parent._worldMatrix);
			// Apply any local transforms
			tempMat.multiply(this._localMatrix);
			// Now transform the point
			tempMat.getInverse().transformCoord(point, this);
		} else {
			this._localMatrix.transformCoord(point, this);
		}

		return point;
	},
	
	/**
	 * Helper method to transform an array of points using _transformPoint.
	 * @param {Array} points The points array to transform.
	 * @private
	 */
	_transformPoints: function (points) {
		// this.renderable._transformPoints(points);
		var point, pointCount = points.length;
		
		while (pointCount--) {
			point = points[pointCount];
			if (this._parent) {
				var tempMat = new IgeMatrix2d();
				// Copy the parent world matrix
				tempMat.copy(this._parent._worldMatrix);
				// Apply any local transforms
				tempMat.multiply(this._localMatrix);
				// Now transform the point
				tempMat.getInverse().transformCoord(point, this);
			} else {
				this._localMatrix.transformCoord(point, this);
			}
		}
	},

	/**
	 * Generates a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String} The string code fragment that will
	 * reproduce this entity when evaluated.
	 */
	_stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		// Get the properties for all the super-classes
		var str = IgeObject.prototype._stringify.call(this, options), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_opacity':
						str += ".opacity(" + this.opacity() + ")";
						break;
					case '_texture':
						str += ".texture(ige.$('" + this.texture().id() + "'))";
						break;
					case '_cell':
						str += ".cell(" + this.cell() + ")";
						break;
					case '_translate':
						if (options.transform !== false && options.translate !== false) {
							str += ".translateTo(" + this._translate.x + ", " + this._translate.y + ", " + this._translate.z + ")";
						}
						break;
					case '_rotate':
						if (options.transform !== false && options.rotate !== false) {
							str += ".rotateTo(" + this._rotate.x + ", " + this._rotate.y + ", " + this._rotate.z + ")";
						}
						break;
					case '_scale':
						if (options.transform !== false && options.scale !== false) {
							str += ".scaleTo(" + this._scale.x + ", " + this._scale.y + ", " + this._scale.z + ")";
						}
						break;
					case '_origin':
						if (options.origin !== false) {
							str += ".originTo(" + this._origin.x + ", " + this._origin.y + ", " + this._origin.z + ")";
						}
						break;
					case '_anchor':
						if (options.anchor !== false) {
							str += ".anchor(" + this.anchor().x + ", " + this.anchor().y + ")";
						}
						break;
					case '_width':
						if (typeof(this.width()) === 'string') {
							str += ".width('" + this.width() + "')";
						} else {
							str += ".width(" + this.width() + ")";
						}
						break;
					case '_height':
						if (typeof(this.height()) === 'string') {
							str += ".height('" + this.height() + "')";
						} else {
							str += ".height(" + this.height() + ")";
						}
						break;
					case '_bounds3d':
						str += ".bounds3d(" + this._bounds3d.x + ", " + this._bounds3d.y + ", " + this._bounds3d.z + ")";
						break;
					case '_deathTime':
						if (options.deathTime !== false && options.lifeSpan !== false) {
							str += ".deathTime(" + this.deathTime() + ")";
						}
						break;
					case '_highlight':
						str += ".highlight(" + this.highlight() + ")";
						break;
				}
			}
		}

		return str;
	},

	/**
	 * Destroys the entity by removing it from the scenegraph,
	 * calling destroy() on any child entities and removing
	 * any active event listeners for the entity. Once an entity
	 * has been destroyed it's this._alive flag is also set to
	 * false.
	 * @example #Destroy the entity
	 *     entity.destroy();
	 */
	destroy: function () {
		this._alive = false;
		
		
		
		/**
		 * Fires when the entity has been destroyed.
		 * @event IgeEntity#destroyed
		 * @param {IgeEntity} The entity that has been destroyed. 
		 */
		this.emit('destroyed', this);

		// Call IgeObject.destroy()
		IgeObject.prototype.destroy.call(this);
	},
	
	saveSpecialProp: function (obj, i) {
		switch (i) {
			case '_texture':
				if (obj.texture()) {
					return {_texture: obj.texture().id()};
				}
				break;
			
			default:
				// Call super-class saveSpecialProp
				return IgeObject.prototype.saveSpecialProp.call(this, obj, i);
				break;
		}
		
		return undefined;
	},
	
	loadSpecialProp: function (obj, i) {
		switch (i) {
			case '_texture':
				return {_texture: ige.$(obj[i])};
				break;
			
			default:
				// Call super-class loadSpecialProp
				return IgeObject.prototype.loadSpecialProp.call(this, obj, i);
				break;
		}
		
		return undefined;
	},

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// INTERACTION
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Gets / sets the callback that is fired when a mouse
	 * move event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse move event and stop it propagating further down the scenegraph
	 *     entity.mouseMove(function (event, control) {
	 *         // Mouse moved with button
	 *         console.log('Mouse move button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseMove: function (callback) {
		if (callback) {
			this._mouseMove = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseMove;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * over event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse over event and stop it propagating further down the scenegraph
	 *     entity.mouseOver(function (event, control) {
	 *         // Mouse over with button
	 *         console.log('Mouse over button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseOver: function (callback) {
		if (callback) {
			this._mouseOver = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseOver;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * out event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse out event and stop it propagating further down the scenegraph
	 *     entity.mouseOut(function (event, control) {
	 *         // Mouse out with button
	 *         console.log('Mouse out button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseOut: function (callback) {
		if (callback) {
			this._mouseOut = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseOut;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * up event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse up event and stop it propagating further down the scenegraph
	 *     entity.mouseUp(function (event, control) {
	 *         // Mouse up with button
	 *         console.log('Mouse up button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseUp: function (callback) {
		if (callback) {
			this._mouseUp = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseUp;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * down event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse down event and stop it propagating further down the scenegraph
	 *     entity.mouseDown(function (event, control) {
	 *         // Mouse down with button
	 *         console.log('Mouse down button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseDown: function (callback) {
		if (callback) {
			this._mouseDown = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseDown;
	},
	
	/**
	 * Gets / sets the callback that is fired when a mouse
	 * wheel event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse wheel event and stop it propagating further down the scenegraph
	 *     entity.mouseWheel(function (event, control) {
	 *         // Mouse wheel with button
	 *         console.log('Mouse wheel button: ' + event.button);
	 *         console.log('Mouse wheel delta: ' + event.wheelDelta);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseWheel: function (callback) {
		if (callback) {
			this._mouseWheel = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseWheel;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * move event is triggered.
	 */
	mouseMoveOff: function () {
		delete this._mouseMove;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * over event is triggered.
	 */
	mouseOverOff: function () {
		delete this._mouseOver;

		return this;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * out event is triggered.
	 */
	mouseOutOff: function () {
		delete this._mouseOut;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * up event is triggered.
	 */
	mouseUpOff: function () {
		delete this._mouseUp;

		return this;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * down event is triggered if the listener was registered
	 * via the mouseDown() method.
	 */
	mouseDownOff: function () {
		delete this._mouseDown;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * wheel event is triggered.
	 */
	mouseWheelOff: function () {
		delete this._mouseWheel;

		return this;
	},
	
	triggerPolygon: function (poly) {
		if (poly !== undefined) {
			this._triggerPolygon = poly;
			return this;
		}
		
		return this._triggerPolygon;
	},

	/**
	 * Gets / sets the shape / polygon that the mouse events
	 * are triggered against. There are two options, 'aabb' and
	 * 'isoBounds'. The default is 'aabb'.
	 * @param val
	 * @returns {*}
	 * @deprecated
	 */
	mouseEventTrigger: function (val) {
		this.log('mouseEventTrigger is no longer in use. Please see triggerPolygon() instead.', 'warning');
		/*if (val !== undefined) {
			// Set default value
			this._mouseEventTrigger = 0;
			
			switch (val) {
				case 'isoBounds':
					this._mouseEventTrigger = 1;
					break;
				
				case 'custom':
					this._mouseEventTrigger = 2;
					break;
				
				case 'aabb':
					this._mouseEventTrigger = 0;
					break;
			}
			return this;
		}
		
		return this._mouseEventTrigger === 0 ? 'aabb' : 'isoBounds';*/
	},

	/**
	 * Handler method that determines which mouse-move event
	 * to fire, a mouse-over or a mouse-move.
	 * @private
	 */
	_handleMouseIn: function (event, evc, data) {
		// Check if the mouse move is a mouse over
		if (!this._mouseStateOver) {
			this._mouseStateOver = true;
			if (this._mouseOver) { this._mouseOver(event, evc, data); }
			
			/**
			 * Fires when the mouse moves over the entity.
			 * @event IgeEntity#mouseOver
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseOver', [event, evc, data]);
		}

		if (this._mouseMove) { this._mouseMove(event, evc, data); }
		this.emit('mouseMove', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-out event
	 * should be fired.
	 * @private
	 */
	_handleMouseOut: function (event, evc, data) {
		// The mouse went away from this entity so
		// set mouse-down to false, regardless of the situation
		this._mouseStateDown = false;

		// Check if the mouse move is a mouse out
		if (this._mouseStateOver) {
			this._mouseStateOver = false;
			if (this._mouseOut) { this._mouseOut(event, evc, data); }
			
			/**
			 * Fires when the mouse moves away from the entity.
			 * @event IgeEntity#mouseOut
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseOut', [event, evc, data]);
		}
	},
	
	/**
	 * Handler method that determines if a mouse-wheel event
	 * should be fired.
	 * @private
	 */
	_handleMouseWheel: function (event, evc, data) {
		if (this._mouseWheel) { this._mouseWheel(event, evc, data); }
		
		/**
		 * Fires when the mouse wheel is moved over the entity.
		 * @event IgeEntity#mouseWheel
		 * @param {Object} The DOM event object.
		 * @param {Object} The IGE event control object.
		 * @param {*} Any further event data.
		 */
		this.emit('mouseWheel', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-up event
	 * should be fired.
	 * @private
	 */
	_handleMouseUp: function (event, evc, data) {
		// Reset the mouse-down flag
		this._mouseStateDown = false;
		if (this._mouseUp) { this._mouseUp(event, evc, data); }
		
		/**
		 * Fires when a mouse up occurs on the entity.
		 * @event IgeEntity#mouseUp
		 * @param {Object} The DOM event object.
		 * @param {Object} The IGE event control object.
		 * @param {*} Any further event data.
		 */
		this.emit('mouseUp', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-down event
	 * should be fired.
	 * @private
	 */
	_handleMouseDown: function (event, evc, data) {
		if (!this._mouseStateDown) {
			this._mouseStateDown = true;
			if (this._mouseDown) { this._mouseDown(event, evc, data); }
			
			/**
			 * Fires when a mouse down occurs on the entity.
			 * @event IgeEntity#mouseDown
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseDown', [event, evc, data]);
		}
	},
	
	/**
	 * Checks mouse input types and fires the correct mouse event
	 * handler. This is an internal method that should never be
	 * called externally.
	 * @param {Object} evc The input component event control object.
	 * @param {Object} data Data passed by the input component into
	 * the new event.
	 * @private
	 */
	_mouseInTrigger: function (evc, data) {
		if (ige.input.mouseMove) {
			// There is a mouse move event
			this._handleMouseIn(ige.input.mouseMove, evc, data);
		}

		if (ige.input.mouseDown) {
			// There is a mouse down event
			this._handleMouseDown(ige.input.mouseDown, evc, data);
		}

		if (ige.input.mouseUp) {
			// There is a mouse up event
			this._handleMouseUp(ige.input.mouseUp, evc, data);
		}
		
		if (ige.input.mouseWheel) {
			// There is a mouse wheel event
			this._handleMouseWheel(ige.input.mouseWheel, evc, data);
		}
	},
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TRANSFORM
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Enables tracing calls which inadvertently assign NaN values to
	 * transformation properties. When called on an entity this system
	 * will break with a debug line when a transform property is set
	 * to NaN allowing you to step back through the call stack and 
	 * determine where the offending value originated.
	 * @returns {IgeEntity}
	 */
	debugTransforms: function () {
		ige.traceSet(this._translate, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._translate, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._translate, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		return this;
	},
	
	velocityTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._velocity.x = x;
			this._velocity.y = y;
			this._velocity.z = z;
		} else {
			this.log('velocityTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},
	
	velocityBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._velocity.x += x;
			this._velocity.y += y;
			this._velocity.z += z;
		} else {
			this.log('velocityBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},
	
	/**
	 * Translates the entity by adding the passed values to
	 * the current translation values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Translate the entity by 10 along the x axis
	 *     entity.translateBy(10, 0, 0);
	 * @return {*}
	 */
	translateBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._translate.x += x;
			this._translate.y += y;
			this._translate.z += z;
		} else {
			this.log('translateBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Translates the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Translate the entity to 10, 0, 0
	 *     entity.translateTo(10, 0, 0);
	 * @return {*}
	 */
	translateTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._translate.x = x;
			this._translate.y = y;
			this._translate.z = z;
		} else {
			this.log('translateTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Translates the entity to the passed point.
	 * @param {IgePoint3d} point The point with co-ordinates.
	 * @example #Translate the entity to 10, 0, 0
	 *     var point = new IgePoint3d(10, 0, 0),
	 *         entity = new IgeEntity();
	 *     
	 *     entity.translateToPoint(point);
	 * @return {*}
	 */
	translateToPoint: function (point) {
		if (point !== undefined) {
			this._translate.x = point.x;
			this._translate.y = point.y;
			this._translate.z = point.z;
		} else {
			this.log('translateToPoint() called with a missing or undefined point parameter!', 'error');
		}

		return this._entity || this;
	},
	
	/**
	 * Translates the object to the tile co-ordinates passed.
	 * @param {Number} x The x tile co-ordinate.
	 * @param {Number} y The y tile co-ordinate.
	 * @param {Number=} z The z tile co-ordinate.
	 * @example #Translate entity to tile
	 *     // Create a tile map
	 *     var tileMap = new IgeTileMap2d()
	 *         .tileWidth(40)
	 *         .tileHeight(40);
	 *     
	 *     // Mount our entity to the tile map
	 *     entity.mount(tileMap);
	 *     
	 *     // Translate the entity to the tile x:10, y:12
	 *     entity.translateToTile(10, 12, 0);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	translateToTile: function (x, y, z) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var finalZ;

			// Handle being passed a z co-ordinate
			if (z !== undefined) {
				finalZ = z * this._parent._tileWidth;
			} else {
				finalZ = this._translate.z;
			}

			this.translateTo((x * this._parent._tileWidth) + this._parent._tileWidth / 2, (y * this._parent._tileHeight) + this._parent._tileWidth / 2, finalZ);
		} else {
			this.log('Cannot translate to tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},

	/**
	 * Gets the translate accessor object.
	 * @example #Use the translate accessor object to alter the y co-ordinate of the entity to 10
	 *     entity.translate().y(10);
	 * @return {*}
	 */
	translate: function () {
		if (arguments.length) {
			this.log('You called translate with arguments, did you mean translateTo or translateBy instead of translate?', 'warning');
		}

		this.x = this._translateAccessorX;
		this.y = this._translateAccessorY;
		this.z = this._translateAccessorZ;

		return this._entity || this;
	},

	/**
	 * The translate accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorX: function (val) {
		if (val !== undefined) {
			this._translate.x = val;
			return this._entity || this;
		}

		return this._translate.x;
	},

	/**
	 * The translate accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorY: function (val) {
		if (val !== undefined) {
			this._translate.y = val;
			return this._entity || this;
		}

		return this._translate.y;
	},

	/**
	 * The translate accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorZ: function (val) {
		// TODO: Do we need to do anything to the matrix here for iso views?
		//this._localMatrix.translateTo(this._translate.x, this._translate.y);
		if (val !== undefined) {
			this._translate.z = val;
			return this._entity || this;
		}

		return this._translate.z;
	},

	/**
	 * Rotates the entity by adding the passed values to
	 * the current rotation values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Rotate the entity by 10 degrees about the z axis
	 *     entity.rotateBy(0, 0, Math.radians(10));
	 * @return {*}
	 */
	rotateBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._rotate.x += x;
			this._rotate.y += y;
			this._rotate.z += z;
		} else {
			this.log('rotateBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Rotates the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Rotate the entity to 10 degrees about the z axis
	 *     entity.rotateTo(0, 0, Math.radians(10));
	 * @return {*}
	 */
	rotateTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._rotate.x = x;
			this._rotate.y = y;
			this._rotate.z = z;
		} else {
			this.log('rotateTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the translate accessor object.
	 * @example #Use the rotate accessor object to rotate the entity about the z axis 10 degrees
	 *     entity.rotate().z(Math.radians(10));
	 * @return {*}
	 */
	rotate: function () {
		if (arguments.length) {
			this.log('You called rotate with arguments, did you mean rotateTo or rotateBy instead of rotate?', 'warning');
		}
		
		this.x = this._rotateAccessorX;
		this.y = this._rotateAccessorY;
		this.z = this._rotateAccessorZ;

		return this._entity || this;
	},

	/**
	 * The rotate accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorX: function (val) {
		if (val !== undefined) {
			this._rotate.x = val;
			return this._entity || this;
		}

		return this._rotate.x;
	},

	/**
	 * The rotate accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorY: function (val) {
		if (val !== undefined) {
			this._rotate.y = val;
			return this._entity || this;
		}

		return this._rotate.y;
	},

	/**
	 * The rotate accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorZ: function (val) {
		if (val !== undefined) {
			this._rotate.z = val;
			return this._entity || this;
		}

		return this._rotate.z;
	},

	/**
	 * Scales the entity by adding the passed values to
	 * the current scale values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Scale the entity by 2 on the x axis
	 *     entity.scaleBy(2, 0, 0);
	 * @return {*}
	 */
	scaleBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._scale.x += x;
			this._scale.y += y;
			this._scale.z += z;
		} else {
			this.log('scaleBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Scale the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Set the entity scale to 1 on all axes
	 *     entity.scaleTo(1, 1, 1);
	 * @return {*}
	 */
	scaleTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._scale.x = x;
			this._scale.y = y;
			this._scale.z = z;
		} else {
			this.log('scaleTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the scale accessor object.
	 * @example #Use the scale accessor object to set the scale of the entity on the x axis to 1
	 *     entity.scale().x(1);
	 * @return {*}
	 */
	scale: function () {
		if (arguments.length) {
			this.log('You called scale with arguments, did you mean scaleTo or scaleBy instead of scale?', 'warning');
		}
		
		this.x = this._scaleAccessorX;
		this.y = this._scaleAccessorY;
		this.z = this._scaleAccessorZ;

		return this._entity || this;
	},

	/**
	 * The scale accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorX: function (val) {
		if (val !== undefined) {
			this._scale.x = val;
			return this._entity || this;
		}

		return this._scale.x;
	},

	/**
	 * The scale accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorY: function (val) {
		if (val !== undefined) {
			this._scale.y = val;
			return this._entity || this;
		}

		return this._scale.y;
	},

	/**
	 * The scale accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorZ: function (val) {
		if (val !== undefined) {
			this._scale.z = val;
			return this._entity || this;
		}

		return this._scale.z;
	},

	/**
	 * Sets the origin of the entity by adding the passed values to
	 * the current origin values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Add 0.5 to the origin on the x axis
	 *     entity.originBy(0.5, 0, 0);
	 * @return {*}
	 */
	originBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._origin.x += x;
			this._origin.y += y;
			this._origin.z += z;
		} else {
			this.log('originBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Set the origin of the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Set the entity origin to 0.5 on all axes
	 *     entity.originTo(0.5, 0.5, 0.5);
	 * @return {*}
	 */
	originTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._origin.x = x;
			this._origin.y = y;
			this._origin.z = z;
		} else {
			this.log('originTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the origin accessor object.
	 * @example #Use the origin accessor object to set the origin of the entity on the x axis to 1
	 *     entity.origin().x(1);
	 * @return {*}
	 */
	origin: function () {
		this.x = this._originAccessorX;
		this.y = this._originAccessorY;
		this.z = this._originAccessorZ;

		return this._entity || this;
	},

	/**
	 * The origin accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorX: function (val) {
		if (val !== undefined) {
			this._origin.x = val;
			return this._entity || this;
		}

		return this._origin.x;
	},

	/**
	 * The origin accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorY: function (val) {
		if (val !== undefined) {
			this._origin.y = val;
			return this._entity || this;
		}

		return this._origin.y;
	},

	/**
	 * The origin accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorZ: function (val) {
		if (val !== undefined) {
			this._origin.z = val;
			return this._entity || this;
		}

		return this._origin.z;
	},

	_rotatePoint: function (point, radians, origin) {
		var cosAngle = Math.cos(radians),
			sinAngle = Math.sin(radians);

		return {
			x: origin.x + (point.x - origin.x) * cosAngle + (point.y - origin.y) * sinAngle,
			y: origin.y - (point.x - origin.x) * sinAngle + (point.y - origin.y) * cosAngle
		};
	},

	/**
	 * Checks the current transform values against the previous ones. If
	 * any value is different, the appropriate method is called which will
	 * update the transformation matrix accordingly.
	 */
	updateTransform: function () {
		// TODO: Remove this check once the IgeEngine is no longer an IgeEntity
		if (ige === this) {
			return;
		}
		// this.renderable.updateTransform();
		var localMatrixModified = false;

		if (this._mode === 0) {
			// 2d translation
			// If new values are the same as old values, don't bother modifying localMatrix
			if ((this._oldTranslateX !== this._translate.x) ||
				  (this._oldTranslateY !== this._translate.y)) {
				this._localMatrix.identity();
				this._localMatrix.multiply(this._localMatrix._newTranslate(this._translate.x, this._translate.y));
				this._oldTranslateX = this._translate.x;
				this._oldTranslateY = this._translate.y;
				localMatrixModified = true;
			}
		}

		if (this._mode === 1) {
			// iso translation
			var isoPoint = this._translateIso = new IgePoint3d(
				this._translate.x,
				this._translate.y,
				this._translate.z + this._bounds3d.z / 2
			).toIso();

			if (this._parent && this._parent._bounds3d.z) {
				// This adjusts the child entity so that 0, 0, 0 inside the
				// parent is the center of the base of the parent
				isoPoint.y += this._parent._bounds3d.z / 1.6;
			}

			this._localMatrix.multiply(this._localMatrix._newTranslate(isoPoint.x, isoPoint.y));
		}

		// If new values are the same as old values, don't bother modifying localMatrix
		if (localMatrixModified || (this._oldRotateZ !== this._rotate.z)) {
			this._localMatrix.rotateTo(this._rotate.z);
			this._oldRotateZ = this._rotate.z;
			localMatrixModified = true;
		}

		// If new values are the same as old values, don't bother modifying localMatrix
		if (localMatrixModified ||
				(this._oldScaleX !== this._scale.x) ||
				(this._oldScaleY !== this._scale.y)) {

			this._localMatrix.scaleBy(this._scale.x, this._scale.y);
			this._oldScaleX = this._scale.x;
			this._oldScaleY = this._scale.y;
			localMatrixModified = true;
		}
			
		
		// Adjust local matrix for origin values if not at center
		if (this._origin.x !== 0.5 || this._origin.y !== 0.5) {
			this._localMatrix.translateBy(
				(this._bounds2d.x * (0.5 - this._origin.x)),
				(this._bounds2d.y * (0.5 - this._origin.y))
			);
		}
		
		// TODO: If the parent and local transforms are unchanged, we should used cached values
		// TODO: Remove check for parent !== ige once IgeEngine is no longer an IgeEntity.
		if (this._parent && this._parent !== ige) {
			this._worldMatrix.copy(this._parent._worldMatrix);
			this._worldMatrix.multiply(this._localMatrix);
		} else {
			this._worldMatrix.copy(this._localMatrix);
		}
		
		// Check if the world matrix has changed and if so, set a few flags
		// to allow other methods to know that a matrix change has occurred
		if (!this._worldMatrix.compare(this._oldWorldMatrix)) {
			this._oldWorldMatrix.copy(this._worldMatrix);
			this._transformChanged = true;
			this._aabbDirty = true;
			this._bounds3dPolygonDirty = true;
		} else {
			this._transformChanged = false;
		}
		
		// Check if the geometry has changed and if so, update the aabb dirty
		if (!this._oldBounds2d.compare(this._bounds2d)) {
			this._aabbDirty = true;
			
			// Record the new geometry to the oldGeometry data
			this._oldBounds2d.copy(this._bounds2d);
		}
		
		if (!this._oldBounds3d.compare(this._bounds3d)) {
			this._bounds3dPolygonDirty = true;
			
			// Record the new geometry to the oldGeometry data
			this._oldBounds3d.copy(this._bounds3d);
		}
		
		return this;
	},

	/**
	 * Gets / sets the disable interpolation flag. If set to true then
	 * stream data being received by the client will not be interpolated
	 * and will be instantly assigned instead. Useful if your entity's
	 * transformations should not be interpolated over time.
	 * @param val
	 * @returns {*}
	 */
	disableInterpolation: function (val) {
		if (val !== undefined) {
			this._disableInterpolation = val;
			return this;
		}
		
		return this._disableInterpolation;
	},

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// STREAM
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Gets / sets the array of sections that this entity will
	 * encode into its stream data.
	 * @param {Array=} sectionArray An array of strings.
	 * @example #Define the sections this entity will use in the network stream. Use the default "transform" section as well as a "custom1" section
	 *     entity.streamSections('transform', 'custom1');
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamSections: function (sectionArray) {
		if (sectionArray !== undefined) {
			this._streamSections = sectionArray;
			return this;
		}

		return this._streamSections;
	},

	streamPrivateSections: function (sections) {
		if (sections !== undefined) {
			this._streamPrivateSections = sections;
			return this;
		}
		return this._streamPrivateSections;
	},

	/**
	 * Gets / sets the data for the specified data section id. This method
	 * is usually not called directly and instead is part of the network
	 * stream system. General use case is to write your own custom streamSectionData
	 * method in a class that extends IgeEntity so that you can control the
	 * data that the entity will send and receive over the network stream.
	 * @param {String} sectionId A string identifying the section to
	 * handle data get / set for.
	 * @param {*=} data If present, this is the data that has been sent
	 * from the server to the client for this entity.
	 * @param {Boolean=} bypassTimeStream If true, will assign transform
	 * directly to entity instead of adding the values to the time stream.
	 * @return {*} "this" when a data argument is passed to allow method
	 * chaining or the current value if no data argument is specified.
	 */
	streamSectionData: function (sectionId, data, bypassTimeStream) {
		switch (sectionId) {
			case 'transform':
				if (data) {
					// We have received updated data
					var dataArr = data.split(',');
	
					if (!this._disableInterpolation && !bypassTimeStream && !this._streamJustCreated) {
						// Translate
						if (dataArr[0]) { dataArr[0] = parseFloat(dataArr[0]); }
						if (dataArr[1]) { dataArr[1] = parseFloat(dataArr[1]); }
						if (dataArr[2]) { dataArr[2] = parseFloat(dataArr[2]); }
	
						// Scale
						if (dataArr[3]) { dataArr[3] = parseFloat(dataArr[3]); }
						if (dataArr[4]) { dataArr[4] = parseFloat(dataArr[4]); }
						if (dataArr[5]) { dataArr[5] = parseFloat(dataArr[5]); }
	
						// Rotate
						if (dataArr[6]) { dataArr[6] = parseFloat(dataArr[6]); }
						if (dataArr[7]) { dataArr[7] = parseFloat(dataArr[7]); }
						if (dataArr[8]) { dataArr[8] = parseFloat(dataArr[8]); }
	
						// Add it to the time stream
						this._timeStream.push([ige.network.stream._streamDataTime + ige.network._latency, dataArr]);
	
						// Check stream length, don't allow higher than 10 items
						if (this._timeStream.length > 10) {
							// Remove the first item
							this._timeStream.shift();
						}
					} else {
						this._setTransformFromStreamData(dataArr);
						
						// If we are using composite caching ensure we update the cache
						if (this.renderable._compositeCache) {
							this.cacheDirty(true);
						}
					}
				} else {
					// We should return stringified data
					return this._translate.toString(this._streamFloatPrecision) + ',' + // translate
						this._scale.toString(this._streamFloatPrecision) + ',' + // scale
						this._rotate.toString(this._streamFloatPrecision) + ','; // rotate
				}
				break;
			
			case 'depth':
					if (data !== undefined) {
						if (ige.isClient) {
							this.depth(parseInt(data));
						}
					} else {
						return String(this.depth());
					}
					break;
				
			case 'layer':
				if (data !== undefined) {
					if (ige.isClient) {
						this.layer(parseInt(data));
					}
				} else {
					return String(this.layer());
				}
				break;
			
			case 'bounds2d':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.bounds2d(parseFloat(geom[0]), parseFloat(geom[1]));
					}
				} else {
					return String(this._bounds2d.x + ',' + this._bounds2d.y);
				}
				break;
			
			case 'bounds3d':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.bounds3d(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
					}
				} else {
					return String(this._bounds3d.x + ',' + this._bounds3d.y + ',' + this._bounds3d.z);
				}
				break;
			
			case 'hidden':
				if (data !== undefined) {
					if (ige.isClient) {
						if (data == 'true') {
							this.hide();
						} else {
							this.show();
						}
					}
				} else {
					return String(this.isHidden());
				}
				break;
			
			case 'mount':
				if (data !== undefined) {
					if (ige.isClient) {
						if (data) {
							var newParent = ige.$(data);
							
							if (newParent) {
								this.mount(newParent);
							}
						} else {
							// Unmount
							this.unMount();
						}
					}
				} else {
					var parent = this.parent();
					
					if (parent) {
						return this.parent().id();
					} else {
						return '';
					}
				}
				break;
			
			case 'origin':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.origin(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
					}
				} else {
					return String(this._origin.x + ',' + this._origin.y + ',' + this._origin.z);
				}
				break;
		}
	},

	

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// INTERPOLATOR
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Calculates the current value based on the time along the
	 * value range.
	 * @param {Number} startValue The value that the interpolation started from.
	 * @param {Number} endValue The target value to be interpolated to.
	 * @param {Number} startTime The time the interpolation started.
	 * @param {Number} currentTime The current time.
	 * @param {Number} endTime The time the interpolation will end.
	 * @return {Number} The interpolated value.
	 */
	interpolateValue: function (startValue, endValue, startTime, currentTime, endTime) {
		var totalValue = endValue - startValue,
			dataDelta = endTime - startTime,
			offsetDelta = currentTime - startTime,
			deltaTime = offsetDelta / dataDelta;

		// Clamp the current time from 0 to 1
		if (deltaTime < 0) { deltaTime = 0; } else if (deltaTime > 1) { deltaTime = 1; }

		return (totalValue * deltaTime) + startValue;
	},

	/**
	 * Processes the time stream for the entity.
	 * @param {Number} renderTime The time that the time stream is
	 * targeting to render the entity at.
	 * @param {Number} maxLerp The maximum lerp before the value
	 * is assigned directly instead of being interpolated.
	 * @private
	 */
	_processInterpolate: function (renderTime, maxLerp) {
		// Set the maximum lerp to 200 if none is present
		if (!maxLerp) { maxLerp = 200; }

		var maxLerpSquared = maxLerp * maxLerp,
			previousData,
			nextData,
			timeStream = this._timeStream,
			dataDelta,
			offsetDelta,
			currentTime,
			previousTransform,
			nextTransform,
			currentTransform = [],
			i = 1;

		// Find the point in the time stream that is
		// closest to the render time and assign the
		// previous and next data points
		while (timeStream[i]) {
			if (timeStream[i][0] > renderTime) {
				// We have previous and next data points from the
				// time stream so store them
				previousData = timeStream[i - 1];
				nextData = timeStream[i];
				break;
			}
			i++;
		}

		// Check if we have some data to use
		if (!nextData && !previousData) {
			// No in-time data was found, check for lagging data
			if (timeStream.length > 2) {
				if (timeStream[timeStream.length - 1][0] < renderTime) {
					// Lagging data is available, use that
					previousData = timeStream[timeStream.length - 2];
					nextData = timeStream[timeStream.length - 1];
					timeStream.shift();
					
					/**
					 * Fires when the entity interpolates against old data, usually
					 * the result of slow processing on the client or too much data
					 * being sent from the server.
					 * @event IgeEntity#interpolationLag
					 */
					this.emit('interpolationLag');
				}
			}
		} else {
			// We have some new data so clear the old data
			timeStream.splice(0, i - 1);
		}

		// If we have data to use
		if (nextData && previousData) {
			// Check if the previous data has a timestamp and if not,
			// use the next data's timestamp
			if (isNaN(previousData[0])) { previousData[0] = nextData[0]; }

			// Store the data so outside systems can access them
			this._timeStreamPreviousData = previousData;
			this._timeStreamNextData = nextData;

			// Calculate the delta times
			dataDelta = nextData[0] - previousData[0];
			offsetDelta = renderTime - previousData[0];

			this._timeStreamDataDelta = Math.floor(dataDelta);
			this._timeStreamOffsetDelta = Math.floor(offsetDelta);

			// Calculate the current time between the two data points
			currentTime = offsetDelta / dataDelta;

			this._timeStreamCurrentInterpolateTime = currentTime;

			// Clamp the current time from 0 to 1
			//if (currentTime < 0) { currentTime = 0.0; } else if (currentTime > 1) { currentTime = 1.0; }

			// Set variables up to store the previous and next data
			previousTransform = previousData[1];
			nextTransform = nextData[1];

			// Translate
			currentTransform[0] = this.interpolateValue(previousTransform[0], nextTransform[0], previousData[0], renderTime, nextData[0]);
			currentTransform[1] = this.interpolateValue(previousTransform[1], nextTransform[1], previousData[0], renderTime, nextData[0]);
			currentTransform[2] = this.interpolateValue(previousTransform[2], nextTransform[2], previousData[0], renderTime, nextData[0]);
			// Scale
			currentTransform[3] = this.interpolateValue(previousTransform[3], nextTransform[3], previousData[0], renderTime, nextData[0]);
			currentTransform[4] = this.interpolateValue(previousTransform[4], nextTransform[4], previousData[0], renderTime, nextData[0]);
			currentTransform[5] = this.interpolateValue(previousTransform[5], nextTransform[5], previousData[0], renderTime, nextData[0]);
			// Rotate
			currentTransform[6] = this.interpolateValue(previousTransform[6], nextTransform[6], previousData[0], renderTime, nextData[0]);
			currentTransform[7] = this.interpolateValue(previousTransform[7], nextTransform[7], previousData[0], renderTime, nextData[0]);
			currentTransform[8] = this.interpolateValue(previousTransform[8], nextTransform[8], previousData[0], renderTime, nextData[0]);

			this._setTransformFromStreamData(currentTransform);

			/*// Calculate the squared distance between the previous point and next point
			 dist = this.distanceSquared(previousTransform.x, previousTransform.y, nextTransform.x, nextTransform.y);

			 // Check that the distance is not higher than the maximum lerp and if higher,
			 // set the current time to 1 to snap to the next position immediately
			 if (dist > maxLerpSquared) { currentTime = 1; }

			 // Interpolate the entity position by multiplying the Delta times T, and adding the previous position
			 currentPosition = {};
			 currentPosition.x = ( (nextTransform.x - previousTransform.x) * currentTime ) + previousTransform.x;
			 currentPosition.y = ( (nextTransform.y - previousTransform.y) * currentTime ) + previousTransform.y;

			 // Now actually transform the entity
			 this.translate(entity, currentPosition.x, currentPosition.y);*/

			// Record the last time we updated the entity so we can disregard any updates
			// that arrive and are before this timestamp (not applicable in TCP but will
			// apply if we ever get UDP in websockets)
			this._lastUpdate = new Date().getTime();
		}
	},

	_setTransformFromStreamData: function(dataArr) {
		this.translateTo(parseFloat(dataArr[0]), parseFloat(dataArr[1]), parseFloat(dataArr[2]));
		this.scaleTo(parseFloat(dataArr[3]), parseFloat(dataArr[4]), parseFloat(dataArr[5]));
		this.rotateTo(parseFloat(dataArr[6]), parseFloat(dataArr[7]), parseFloat(dataArr[8]));
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEntity; }
;// TODO: Implement the _stringify() method for this class
/**
 * Creates a new UI entity. UI entities use more resources and CPU
 * than standard IgeEntity instances so only use them if an IgeEntity
 * won't do the job.
 */
var IgeUiEntity = IgeEntity.extend([
	{extension: IgeUiStyleExtension, overwrite: true},
	{extension: IgeUiPositionExtension, overwrite: true}
], {
	classId: 'IgeUiEntity',

	init: function () {
		IgeEntity.prototype.init.call(this);

		// Set some defaults
		this._color = '#000000';
		this._borderLeftWidth = 0;
		this._borderTopWidth = 0;
		this._borderRightWidth = 0;
		this._borderBottomWidth = 0;
		this._borderTopLeftRadius = 0;
		this._borderTopRightRadius = 0;
		this._borderBottomRightRadius = 0;
		this._borderBottomLeftRadius = 0;
		this._backgroundPosition = {x: 0, y: 0};
		this._paddingLeft = 0;
		this._paddingTop = 0;
		this._paddingRight = 0;
		this._paddingBottom = 0;
	},
	
	disabled: function (val) {
		if (val !== undefined) {
			this._disabled = val;
			return this;
		}
		
		return this._disabled;
	},
	
	overflow: function (val) {
		if (val !== undefined) {
			this._overflow = val;
			return this;
		}
		
		return this._overflow;
	},

	_renderBackground: function (ctx) {
		var geom = this._bounds2d,
			left, top, width, height;

		if (this._backgroundColor || this._patternFill) {
			left = -(geom.x / 2) | 0;
			top = -(geom.y / 2) | 0;
			width = geom.x;
			height = geom.y;

			ctx.save();
				ctx.beginPath();

				// Check for early exit if we are rendering a rectangle
				if (!this._borderTopRightRadius && this._borderBottomRightRadius && !this._borderBottomLeftRadius && !this._borderTopLeftRadius) {
					ctx.rect(left, top, width, height);
				} else {
					// Top border
					ctx.moveTo(left + this._borderTopLeftRadius, top);
					ctx.lineTo(left + width - this._borderTopRightRadius, top);

					if (this._borderTopRightRadius > 0) {
						// Top-right corner
						ctx.arcTo(
							left + width,
							top,
							left + width,
							top + this._borderTopRightRadius,
							this._borderTopRightRadius
						);
					}

					// Right border
					ctx.lineTo(
						left + width,
						top + height - this._borderBottomRightRadius
					);

					if (this._borderBottomRightRadius > 0) {
						// Bottom-right corner
						ctx.arcTo(
							left + width,
							top + height,
							left + width - this._borderBottomRightRadius,
							top + height, this._borderBottomRightRadius
						);
					}

					// Bottom border
					ctx.lineTo(
						left + this._borderBottomLeftRadius,
						top + height
					);

					if (this._borderBottomLeftRadius > 0) {
						// Bottom-left corner
						ctx.arcTo(
							left,
							top + height,
							left,
							top + height - this._borderBottomLeftRadius,
							this._borderBottomLeftRadius
						);
					}

					// Left border
					ctx.lineTo(
						left,
						top + this._borderTopLeftRadius
					);

					if (this._borderTopLeftRadius > 0) {
						// Top-left corner
						ctx.arcTo(
							left,
							top,
							left + this._borderTopLeftRadius,
							top, this._borderTopLeftRadius
						);
					}

					ctx.clip();
				}

				// If there is a background colour, paint it here
				if (this._backgroundColor) {
					ctx.fillStyle = this._backgroundColor;
					ctx.fill();
				}

				// If there is a background image, paint it here
				if (this._patternFill) {
					ctx.translate(
						-(width / 2 | 0) + this._backgroundPosition.x,
						-(height / 2 | 0) + this._backgroundPosition.y
					);

					ctx.fillStyle = this._patternFill;
					ctx.fill();
				}
			ctx.restore();
		}
	},

	_renderBorder: function (ctx) {
		var rad,
			geom = this._bounds2d,
			left = (-(geom.x2) | 0) + 0.5,
			top = (-(geom.y2) | 0) + 0.5,
			width = geom.x - 1,
			height = geom.y - 1;

		// Check for early exit if we are rendering a rectangle
		if (!this._borderTopRightRadius && !this._borderBottomRightRadius && !this._borderBottomLeftRadius && !this._borderTopLeftRadius
			&& this._borderLeftWidth === this._borderWidth
			&& this._borderTopWidth === this._borderWidth
			&& this._borderRightWidth === this._borderWidth
			&& this._borderBottomWidth === this._borderWidth) {
			ctx.strokeStyle = this._borderColor;
			ctx.lineWidth = this._borderWidth;
			ctx.strokeRect(left, top, width, height);
		} else {
			var startNewStroke = function() {
				ctx.stroke();
				ctx.beginPath();
			};		
			rad = Math.PI / 180;
			
			ctx.beginPath();
			if (this._borderTopWidth) {
				// Top-left corner top-half
				ctx.strokeStyle = this._borderTopColor;
				ctx.lineWidth = this._borderTopWidth;

				if (this._borderTopLeftRadius > 0) {
					// Top-left corner top-half
					ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 225 * rad, 270 * rad);
				}

				// Top border
				ctx.moveTo(left + this._borderTopLeftRadius, top);
				ctx.lineTo(left + width - this._borderTopRightRadius, top);

				if (this._borderTopRightRadius > 0) {
					// Top-right corner top-half
					ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -90 * rad, -44 * rad); // use -44 instead of -45 to fully connect with next piece
				}
			}
			
			if (!this._borderRightWidth || this._borderTopColor != this._borderRightColor || this._borderTopWidth != this._borderRightWidth)
				startNewStroke();
			if (this._borderRightWidth) {
				// Top-right corner bottom-half
				ctx.strokeStyle = this._borderRightColor;
				ctx.lineWidth = this._borderRightWidth;

				if (this._borderTopRightRadius > 0) {
					ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -45 * rad, 0);
				}

				// Right border
				ctx.moveTo(left + width, top + this._borderTopRightRadius);
				ctx.lineTo(left + width, top + height - this._borderBottomRightRadius);

				if (this._borderBottomRightRadius > 0) {
					// Bottom-right corner top-half
					ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderTopRightRadius, 0, 46 * rad); // use 46 instead of 45 to fully connect with next piece
				}
			}

			if (!this._borderBottomWidth || this._borderRightColor != this._borderBottomColor || this._borderRightWidth != this._borderBottomWidth)
				startNewStroke();
			if (this._borderBottomWidth) {
				// Bottom-right corner bottom-half
				ctx.strokeStyle = this._borderBottomColor;
				ctx.lineWidth = this._borderBottomWidth;

				if (this._borderBottomRightRadius > 0) {
					ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderBottomRightRadius, 45 * rad, 90 * rad);
				}

				// Bottom border
				ctx.moveTo(left + width - this._borderBottomRightRadius, top + height);
				ctx.lineTo(left + this._borderBottomLeftRadius, top + height);

				if (this._borderBottomLeftRadius > 0) {
					// Bottom-left corner bottom-half
					ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 90 * rad, 136 * rad); // use 136 instead of 135 to fully connect with next piece
				}
			}

			if (!this._borderLeftWidth || this._borderBottomColor != this._borderLeftColor || this._borderBottomWidth != this._borderLeftWidth)
				startNewStroke();
			if (this._borderLeftWidth) {
				// Bottom-left corner top-half
				ctx.strokeStyle = this._borderLeftColor;
				ctx.lineWidth = this._borderLeftWidth;

				if (this._borderBottomLeftRadius > 0) {
					ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 135 * rad, 180 * rad);
				}

				// Left border
				ctx.moveTo(left, top + height - this._borderBottomLeftRadius);
				ctx.lineTo(left, top + this._borderTopLeftRadius);

				if (this._borderTopLeftRadius > 0) {
					// Top-left corner bottom-half
					ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 180 * rad, 226 * rad); // use 226 instead of 225 to fully connect with next piece
				}
			}
			ctx.stroke();
		}
	},

	cell: function (val) {
		var ret = IgeEntity.prototype.cell.call(this, val);

		if (ret === this && this._patternTexture) {
			this.backgroundImage(
				this._patternTexture,
				this._patternRepeat
			);
		}

		return ret;
	},

	mount: function (obj) {
		var ret = IgeEntity.prototype.mount.call(this, obj);

		if (this._parent) {
			// Now we're mounted update our ui calculations since we have a parent
			// to calculate from
			if (this._updateUiPosition) {
				this._updateUiPosition();
			}
			
			// Also update any children if we have any
			if(this._children.length) {
				this.updateUiChildren();
			}
		}

		return ret;
	},

	tick: function (ctx, dontTransform) {
		if (!this._hidden && this._inView && (!this._parent || (this._parent._inView)) && !this._streamJustCreated) {
			if (!dontTransform) {
				this._transformContext(ctx);
			}
			// TODO: Investigate caching expensive background and border calls
			//if (!this._cache || this._cacheDirty) {
				this._renderBackground(ctx);
				this._renderBorder(ctx);
			//}
	
			if (this._overflow === 'hidden') {
				// Limit drawing of child entities to within the bounds
				// of this one
				var geom = this._bounds2d,
					left = -(geom.x / 2) + this._paddingLeft | 0,
					top = -(geom.y / 2) + (this._paddingTop) | 0,
					width = geom.x + this._paddingRight,
					height = geom.y + this._paddingBottom;
	
				ctx.rect(left, top, width, height);
				//ctx.stroke();
				ctx.clip();
			}
	
			ctx.translate(this._paddingLeft, this._paddingTop);
			IgeEntity.prototype.tick.call(this, ctx, true);
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		
		if (this._updateUiPosition) {
			this._updateUiPosition();
		} else {
			debugger;
		}
		IgeEntity.prototype._resizeEvent.call(this, event);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiEntity; };/**
 * Creates a new UI element. UI elements use more resources and CPU
 * than standard IgeEntity instances but provide a rich set of extra
 * positioning and styling methods as well as reacting to styles
 * defined using the IgeUiManagerComponent.
 */
var IgeUiElement = IgeUiEntity.extend({
	classId: 'IgeUiElement',

	/**
	 * Constructor
	 */
	init: function () {
		var self = this;
		
		IgeUiEntity.prototype.init.call(this);
		ige.ui.registerElement(this);
		
		this._focused = false;
		this._allowHover = true;
		this._allowFocus = true;
		this._allowActive = true;
		
		var updateStyleFunc = function () {
			self._updateStyle();
		};
		
		this.on('mouseOver', function () {
			if (this._allowHover) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateOver = false;
			}
		});
		this.on('mouseOut', function () {
			if (this._allowHover) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateOver = false;
			}
		});
		this.on('mouseDown', function () {
			if (this._allowActive) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateDown = false;
			}
		});
		this.on('mouseUp', function () {
			if (this._allowFocus) {
				// Try to focus the entity
				if (!self.focus()) {
					updateStyleFunc();
				} else {
					ige.input.stopPropagation();
				}
			} else if (this._allowActive) {
				updateStyleFunc();
			}
		});
		
		// Enable mouse events on this entity by default
		this.mouseEventsActive(true);
	},
	
	allowHover: function (val) {
		if (val !== undefined) {
			this._allowHover = val;
			return this;
		}
		
		return this._allowHover;
	},
	
	allowFocus: function (val) {
		if (val !== undefined) {
			this._allowFocus = val;
			return this;
		}
		
		return this._allowFocus;
	},
	
	allowActive: function (val) {
		if (val !== undefined) {
			this._allowActive = val;
			return this;
		}
		
		return this._allowActive;
	},

	/**
	 * Gets / sets the applied style by name.
	 * @param {String=} name The style name to apply.
	 * @returns {*}
	 */
	styleClass: function (name) {
		if (name !== undefined) {
			// Add a period to the class name
			name = '.' + name;
			
			// Check for existing assigned style
			if (this._styleClass && this._styleClass !== name) {
				// Unregister this element from the style
				ige.ui.unRegisterElementStyle(this);
			}
			
			// Assign the new style
			this._styleClass = name;
			
			// Register the element for this style
			ige.ui.registerElementStyle(this);
			
			// Update the element style
			this._updateStyle();
			
			return this;
		}
		
		return this._styleClass;
	},
	
	_updateStyle: function () {
		// Apply styles in order of class, class:focus, class:hover, class:active,
		// id, id:focus, id:hover, id:active
		this._processStyle(this._classId);
		this._processStyle(this._styleClass);
		this._processStyle('#' + this._id);
		
		if (this._focused) {
			this._processStyle(this._classId, 'focus');
			this._processStyle(this._styleClass, 'focus');
			this._processStyle('#' + this._id, 'focus');
		}
		
		if (this._mouseStateOver) {
			this._processStyle(this._classId, 'hover');
			this._processStyle(this._styleClass, 'hover');
			this._processStyle('#' + this._id, 'hover');
		}
		
		if (this._mouseStateDown) {
			this._processStyle(this._classId, 'active');
			this._processStyle(this._styleClass, 'active');
			this._processStyle('#' + this._id, 'active');
		}
	},
	
	_processStyle: function (styleName, state) {
		if (styleName) {
			if (state) {
				styleName += ':' + state;
			}
			
			//this.log('Checking for styles with selector: ' + styleName);
			
			// Basic
			var styleData = ige.ui.style(styleName);
			if (styleData) {
				//this.log('Applying styles with selector "' + styleName + '"');
				this.applyStyle(styleData);
			}
		}
	},

	/**
	 * Apply styles from a style data object. Usually you don't want to
	 * call this method directly but rather assign a style by name using
	 * the style() method, however it is not illegal practise to apply
	 * here if you wish if you have not defined a style by name and simply
	 * wish to apply style data directly.
	 * 
	 * Style property names must correspond to method names in the element
	 * class that the style is being applied to. You can see the default
	 * ui style methods available in the ./engine/extensions/IgeUi* files.
	 * 
	 * In the example below showing padding, you can see how the data assigned
	 * is passed to the "padding()" method as arguments, which is the same
	 * as calling "padding(10, 10, 10, 10);".
	 * 
	 * @example #Apply a background color
	 *     var elem = new IgeUiElement()
	 *         .applyStyle({
	 *             'backgroundColor': '#ffffff' // Set background color to white
	 *         });
	 *         
	 * @example #Apply padding with multiple arguments
	 *     var elem = new IgeUiElement()
	 *         .applyStyle({
	 *             'padding': [10, 10, 10, 10] // Set padding using multiple values
	 *         });
	 * 
	 * @param {Object} styleData The style object to apply. This object should
	 * contain key/value pairs where the key matches a method name and the value
	 * is the parameter to pass it.
	 */
	applyStyle: function (styleData) {
		var args;
		
		if (styleData !== undefined) {
			// Loop the style data and apply styles as required
			for (var i in styleData) {
				if (styleData.hasOwnProperty(i)) {
					// Check that the style method exists
					if (typeof(this[i]) === 'function') {
						// The method exists, call it with the arguments
						if (styleData[i] instanceof Array) {
							args = styleData[i];
						} else {
							args = [styleData[i]];
						}
						
						this[i].apply(this, args);
					}
				}
			}
		}
		
		return this;
	},

	/**
	 * Sets global UI focus to this element.
	 */
	focus: function () {
		if (ige.ui.focus(this)) {
			// Re-apply styles since the change
			this._updateStyle();
			return true;
		}
		
		return false;
	},
	
	blur: function () {
		if (ige.ui.blur(this)) {
			// Re-apply styles since the change
			this._updateStyle();
			return true;
		}
		
		return false;
	},
	
	focused: function () {
		return this._focused;
	},
	
	value: function (val) {
		if (val !== undefined) {
			this._value = val;
			return this;
		}
		
		return this._value;
	},
	
	_mounted: function () {
		this._updateStyle();
	},

	/**
	 * Destructor
	 */
	destroy: function () {
		ige.ui.unRegisterElement(this);
		IgeUiEntity.prototype.destroy.call(this);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiElement; };/**
 * Creates a new particle emitter.
 */
var IgeParticleEmitter = IgeEntity.extend({
	classId: 'IgeParticleEmitter',
	IgeParticleEmitter: true,

	init: function () {
		// IgeBody.init()
		IgeEntity.prototype.init.call(this);

		// Set some defaults
		this._currentDelta = 0;
		this._started = false;
		//this._particles = [];

		this.applyDepthToParticles(true);
		this.applyLayerToParticles(true);
		this.quantityTimespan(1000);
		this.quantityBase(10);
		this.quantityVariance(0, 0);
		this.translateBaseX(0);
		this.translateBaseY(0);
		this.translateBaseZ(0);
		this.translateVarianceX(0, 0);
		this.translateVarianceY(0, 0);
		this.translateVarianceZ(0, 0);
		this.rotateBase(0);
		this.rotateVariance(0, 0);
		this.deathRotateBase(0);
		this.deathRotateVariance(0, 0);
		this.scaleBaseX(1);
		this.scaleBaseY(1);
		this.scaleBaseZ(1);
		this.scaleVarianceX(0, 0);
		this.scaleVarianceY(0, 0);
		this.scaleVarianceZ(0, 0);
		this.scaleLockAspect(false);
		this.deathScaleBaseX(0);
		this.deathScaleBaseY(0);
		this.deathScaleBaseZ(0);
		this.deathScaleVarianceX(0, 0);
		this.deathScaleVarianceY(0, 0);
		this.deathScaleVarianceZ(0, 0);
		this.deathScaleLockAspect(false);
		this.opacityBase(1);
		this.opacityVariance(0, 0);
		this.deathOpacityBase(1);
		this.deathOpacityVariance(0, 0);
		this.lifeBase(1000);
		this.lifeVariance(0, 0);
	},

	/**
	 * Sets the class that all particles emitted from this
	 * emitter will be created from.
	 * @param {IgeEntity} obj
	 * @return {*}
	 */
	particle: function (obj) {
		this._particle = obj;
		return this;
	},

	particleMountTarget: function (obj) {
		this._particleMountTarget = obj;
		return this;
	},

	applyDepthToParticles: function (val) {
		this._applyDepthToParticles = val;
		return this;
	},

	applyLayerToParticles: function (val) {
		this._applyLayerToParticles = val;
		return this;
	},

	quantityTimespan: function (val) {
		this._quantityTimespan = val;
		return this;
	},

	quantityBase: function (val) {
		this._quantityBase = val;
		return this;
	},

	quantityVariance: function (a, b) {
		this._quantityVariance = [a, b];
		return this;
	},

	quantityMax: function (val) {
		this._quantityMax = val;
		this._quantityProduced = 0;
		return this;
	},

	translateBaseX: function (val) {
		this._translateBaseX = val;
		return this;
	},

	translateBaseY: function (val) {
		this._translateBaseY = val;
		return this;
	},

	translateBaseZ: function (val) {
		this._translateBaseZ = val;
		return this;
	},

	translateVarianceX: function (a, b) {
		this._translateVarianceX = [a, b];
		return this;
	},

	translateVarianceY: function (a, b) {
		this._translateVarianceY = [a, b];
		return this;
	},

	translateVarianceZ: function (a, b) {
		this._translateVarianceZ = [a, b];
		return this;
	},

	rotateBase: function (val) {
		this._rotateBase = val;
		return this;
	},

	rotateVariance: function (a, b) {
		this._rotateVariance = [a, b];
		return this;
	},

	deathRotateBase: function (val) {
		this._deathRotateBase = val;
		return this;
	},

	deathRotateVariance: function (a, b) {
		this._deathRotateVariance = [a, b];
		return this;
	},

	scaleBaseX: function (val) {
		this._scaleBaseX = val;
		return this;
	},

	scaleBaseY: function (val) {
		this._scaleBaseY = val;
		return this;
	},

	scaleBaseZ: function (val) {
		this._scaleBaseZ = val;
		return this;
	},

	scaleVarianceX: function (a, b) {
		this._scaleVarianceX = [a, b];
		return this;
	},

	scaleVarianceY: function (a, b) {
		this._scaleVarianceY = [a, b];
		return this;
	},

	scaleVarianceZ: function (a, b) {
		this._scaleVarianceZ = [a, b];
		return this;
	},

	scaleLockAspect: function (val) {
		this._scaleLockAspect = val;
		return this;
	},

	deathScaleBaseX: function (val) {
		this._deathScaleBaseX = val;
		return this;
	},

	deathScaleBaseY: function (val) {
		this._deathScaleBaseY = val;
		return this;
	},

	deathScaleBaseZ: function (val) {
		this._deathScaleBaseZ = val;
		return this;
	},

	deathScaleVarianceX: function (a, b) {
		this._deathScaleVarianceX = [a, b];
		return this;
	},

	deathScaleVarianceY: function (a, b) {
		this._deathScaleVarianceY = [a, b];
		return this;
	},

	deathScaleVarianceZ: function (a, b) {
		this._deathScaleVarianceZ = [a, b];
		return this;
	},

	deathScaleLockAspect: function (val) {
		this._deathScaleLockAspect = val;
		return this;
	},

	opacityBase: function (val) {
		this._opacityBase = val;
		return this;
	},

	opacityVariance: function (a, b) {
		this._opacityVariance = [a, b];
		return this;
	},

	deathOpacityBase: function (val) {
		this._deathOpacityBase = val;
		return this;
	},

	deathOpacityVariance: function (a, b) {
		this._deathOpacityVariance = [a, b];
		return this;
	},

	lifeBase: function (val) {
		this._lifeBase = val;
		return this;
	},

	lifeVariance: function (a, b) {
		this._lifeVariance = [a, b];
		return this;
	},

	/**
	 * Sets the base velocity vector of each emitted particle and optionally
	 * the min and max vectors that are used to randomize the resulting particle
	 * velocity vector.
	 * @param baseVector
	 * @param minVector
	 * @param maxVector
	 */
	velocityVector: function (baseVector, minVector, maxVector) {
		this._velocityVector = {
			base: baseVector,
			min: minVector,
			max: maxVector
		};

		return this;
	},

	linearForceVector: function (baseVector, minVector, maxVector) {
		this._linearForceVector = {
			base: baseVector,
			min: minVector,
			max: maxVector
		};

		return this;
	},

	/**
	 * Starts the particle emitter which will begin spawning
	 * particle entities based upon the emitter's current settings.
	 * @return {*}
	 */
	start: function () {
		if (this._particle) {
			// Update the transform matrix before starting
			// otherwise some particles might read the old
			// matrix values if the start method was chained!
			this.updateTransform();

			this._quantityTimespan = this._quantityTimespan !== undefined ? this._quantityTimespan : 1000;
			this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
			this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
			this._currentDelta = 0;

			// Set the emitter started flag
			this._quantityProduced = 0;
			this._started = true;
		} else {
			this.log('Cannot start particle emitter because no particle class was specified with a call to particle()', 'error');
		}

		return this;
	},
	
	updateSettings: function () {
		this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
		this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
	},

	/**
	 * Stops the particle emitter. The current particles will
	 * continue to process until they reach their natural lifespan.
	 * @return {*}
	 */
	stop: function () {
		this._started = false;
		return this;
	},

	/**
	 * Stops the particle emitter. The current particles will be
	 * destroyed immediately.
	 *
	 * Note: We have removed stopAndKill because it's functionality requires
	 * keeping around a list of all particles ever created by the emitter. This
	 * leads to excessive memory usage since the garbage collector can't run.
	 *
	 * To get similar functionality, call stop() and wait for the particles to
	 * time out. They will get removed from the scene graph automatically. The
	 * only disadvantage is that you will have to wait for the particles to time
	 * out instead of destroying them immediately.
	 * 
	 * TODO: Reimplement the list of particles as a hash and remove particles
	 * from the hash when tweening is done (use the afterTween() callback). 
	 *
	 * @return {*}
	 */
	 /*
	stopAndKill: function () {
		this._started = false;

		// Loop the particles array and destroy all the particles
		var arr = this._particles,
			arrCount = arr.length;

		while (arrCount--) {
			arr[arrCount].destroy();
		}

		// Remove all references to the particles by
		// re-initialising the particles array
		this._particles = [];

		return this;
	},
*/
	/**
	 * Takes a base value and a variance range and returns a random
	 * value between the range, added to the base.
	 * @param {Number} base The base value.
	 * @param {Array} variance An array containing the two values of
	 * the variance range.
	 * @param {Boolean} floorIt If set to true, will cause the returned
	 * value to be passed through Math.floor().
	 * @return {Number} Returns the final value based upon the base
	 * value and variance range.
	 */
	baseAndVarianceValue: function (base, variance, floorIt) {
		base = base || 0;
		variance = variance || [0, 0];
		var variant = 0;

		if (floorIt) {
			variant = Math.floor(variance[0] + Math.random() * (variance[1] - variance[0]));
		} else {
			variant = (variance[0] + Math.random() * (variance[1] - variance[0]));
		}

		return base + variant;
	},

	vectorFromBaseMinMax: function (vectorData) {
		if (vectorData.min && vectorData.max) {
			var base = vectorData.base,
				min = vectorData.min,
				max = vectorData.max,
				newVector = {};

			newVector.x = base.x + (min.x + Math.random() * (max.x - min.x));
			newVector.y = base.y + (min.y + Math.random() * (max.y - min.y));
			newVector.z = base.z + (min.z + Math.random() * (max.z - min.z));

			return newVector;
		} else {
			// There was no variance data so return the base vector
			return vectorData.base;
		}
	},

	/**
	 * Creates and maintains the particles that this emitter is
	 * responsible for spawning and controlling.
	 * @param ctx
	 */
	tick: function (ctx) {
		this._currentDelta += ige._tickDelta;

		// Check if the emitter is mounted to anything and started, if not
		// then don't bother creating particles!
		if (this._parent && this._started) {
			if (!this._quantityMax || this._quantityProduced < this._quantityMax) {
				var particleCount,
					translateX,
					translateY,
					translateZ,
					//vectorAngle,
					//vectorPower,
					velocityVector,
					newVecX, newVecY,
					rotX, rotY,
					cosRot, sinRot,
					scaleX,
					scaleY,
					scaleZ,
					rotate,
					opacity,
					life,
					//linearForceAngle,
					//linearForcePower,
					linearForceVector,
					deathScaleX,
					deathScaleY,
					deathScaleZ,
					deathRotate,
					deathOpacity,
					tempParticle,
					tweens,
					scaleProps,
					i;

				if (this._currentDelta > this._quantityTimespan) {
					this._currentDelta = this._quantityTimespan;
				}

				if (this._currentDelta >= this._particlesPerTimeVector) {
					particleCount = ((this._currentDelta / this._particlesPerTimeVector)|0); // Bitwise floor
					this._currentDelta -= (this._particlesPerTimeVector * particleCount);

					// Loop the particle array and if no particle exists,
					// create one to fill the space. Basically this keeps
					// the emitters creating new particles until it is
					// stopped.
					if (particleCount) {
						while (particleCount--) {
							if (this._quantityMax) {
								this._quantityProduced ++;

								// If the number of particles produced is equal to or greater
								// than the max we should produce then exit the loop
								if (this._quantityProduced >= this._quantityMax) {
									this.stop();
									break;
								}
							}

							// Create the initial particle values based on
							// the emitter options values

							// Generate the particle's initial translate values
							translateX = this.baseAndVarianceValue(this._translateBaseX, this._translateVarianceX, true);
							translateY = this.baseAndVarianceValue(this._translateBaseY, this._translateVarianceY, true);
							translateZ = this.baseAndVarianceValue(this._translateBaseZ, this._translateVarianceZ, true);

							//translateX += this._worldMatrix.matrix[2];
							//translateY += this._worldMatrix.matrix[5];

							if (this._velocityVector) {
								// Generate the particle's initial vector angle and power
								velocityVector = this.vectorFromBaseMinMax(this._velocityVector);

								// Rotate the vector's point to match the current emitter rotation
								rotX = velocityVector.x;
								rotY = velocityVector.y;
								cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
								sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
								newVecX = rotX * cosRot - rotY * sinRot;
								newVecY = rotY * cosRot + rotX * sinRot;

								// Assign the rotated vector back again
								velocityVector.x = newVecX;
								velocityVector.y = newVecY;
							}

							//vectorAngle = this.baseAndVarianceValue(this._vectorAngleBase, this._vectorAngleVariance, true);
							//vectorPower = this.baseAndVarianceValue(this._vectorPowerBase, this._vectorPowerVariance, false);

							// Generate the particle's initial scale
							scaleX = this.baseAndVarianceValue(this._scaleBaseX, this._scaleVarianceX, false);
							scaleZ = scaleY = scaleX;
							if (!this._scaleLockAspect) {
								scaleY = this.baseAndVarianceValue(this._scaleBaseY, this._scaleVarianceY, false);
								scaleZ = this.baseAndVarianceValue(this._scaleBaseZ, this._scaleVarianceZ, false);
							}

							// Generate the particle's initial rotation
							rotate = this.baseAndVarianceValue(this._rotateBase, this._rotateVariance, true);

							// Generate the particle's initial opacity
							opacity = this.baseAndVarianceValue(this._opacityBase, this._opacityVariance, false);

							// Generate the particle's initial lifespan
							life = this.baseAndVarianceValue(this._lifeBase, this._lifeVariance, true);

							// Generate the particle's linear force vector angle and power
							if (this._linearForceVector) {
								linearForceVector = this.vectorFromBaseMinMax(this._linearForceVector);

								// Rotate the vector's point to match the current emitter rotation
								rotX = linearForceVector.x;
								rotY = linearForceVector.y;
								cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
								sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
								newVecX = rotX * cosRot - rotY * sinRot;
								newVecY = rotY * cosRot + rotX * sinRot;

								// Assign the rotated vector back again
								linearForceVector.x = newVecX;
								linearForceVector.y = newVecY;
							}

							//linearForceAngle = this.baseAndVarianceValue(this._linearForceAngleBase, this._linearForceAngleVariance);
							//linearForcePower = this.baseAndVarianceValue(this._linearForcePowerBase, this._linearForcePowerVariance, false);

							// Generate the particle's death scale
							if (typeof(this._deathScaleBaseX) !== 'undefined') {
								deathScaleX = this.baseAndVarianceValue(
									this._deathScaleBaseX,
									this._deathScaleVarianceX,
									false
								);
							}
							if (typeof(this._deathScaleBaseY) !== 'undefined' && !this._deathScaleLockAspect) {
								deathScaleY = this.baseAndVarianceValue(
									this._deathScaleBaseY,
									this._deathScaleVarianceY,
									false
								);
							}
							if (typeof(this._deathScaleBaseZ) !== 'undefined' && !this._deathScaleLockAspect) {
								deathScaleZ = this.baseAndVarianceValue(
									this._deathScaleBaseZ,
									this._deathScaleVarianceZ,
									false
								);
							}
							if (this._deathScaleLockAspect) {
								deathScaleZ = deathScaleY = deathScaleX;
							}

							// Generate the particle's death rotation
							if (typeof(this._deathRotateBase) !== 'undefined') {
								deathRotate = this.baseAndVarianceValue(
									this._deathRotateBase,
									this._deathRotateVariance,
									true
								);
							}

							// Generate the particle's death opacity
							if (typeof(this._deathOpacityBase) !== 'undefined') {
								deathOpacity = this.baseAndVarianceValue(
									this._deathOpacityBase,
									this._deathOpacityVariance,
									false
								);
							}

							// Create the particle entity
							tempParticle = new this._particle(this);

							// Add the current transform of the emitter to the final
							// particle transforms
							if (this._ignoreCamera) {
								translateX += this._translate.x;
								translateY += this._translate.y;
							} else {
								translateX += this._worldMatrix.matrix[2];
								translateY += this._worldMatrix.matrix[5];
							}
							translateZ += this._translate.z;

							scaleX *= this._scale.x;
							scaleY *= this._scale.y;
							scaleZ *= this._scale.z;

							deathScaleX *= this._scale.x;
							deathScaleY *= this._scale.y;
							deathScaleZ *= this._scale.z;

							// Apply all the transforms (don't do this in the initial
							// entity definition because some components may already
							// have initialised due to the particle template
							tempParticle.translateTo(translateX, translateY, translateZ);
							tempParticle.rotateTo(0, 0, Math.radians(rotate));
							tempParticle.scaleTo(scaleX, scaleY, scaleZ);
							tempParticle.opacity(opacity);

							if (this._applyDepthToParticles) { tempParticle.depth(this._depth); }
							if (this._applyLayerToParticles) { tempParticle.layer(this._layer); }

							if (typeof(velocityVector) === 'object') {
								tempParticle.velocity.vector3(velocityVector, false);
							}

							if (typeof(linearForceVector) === 'object') {
								tempParticle.velocity.linearForceVector3(linearForceVector, false);
							}

							tweens = [];
							if (typeof(deathRotate) !== 'undefined') {
								tweens.push(new IgeTween()
									.targetObj(tempParticle._rotate)
									.properties({z: Math.radians(deathRotate)})
									.duration(life));
							}
							if (typeof(deathOpacity) !== 'undefined') {
								tweens.push(new IgeTween()
									.targetObj(tempParticle.renderable)
									.properties({_opacity: deathOpacity})
									.duration(life));
								if (tempParticle.pixiRenderable) {
									tweens.push(new IgeTween()
										.targetObj(tempParticle.pixiRenderable)
										.properties({_opacity: deathOpacity})
										.duration(life)
									);
								}
							}

							scaleProps = {};
							if (typeof(deathScaleX) !== 'undefined') {
								scaleProps.x = deathScaleX;
							}
							if (typeof(deathScaleY) !== 'undefined') {
								scaleProps.y = deathScaleY;
							}
							if (typeof(deathScaleZ) !== 'undefined') {
								scaleProps.z = deathScaleZ;
							}

							if (scaleProps.x || scaleProps.y || scaleProps.z) {
								tweens.push(new IgeTween()
									.targetObj(tempParticle._scale)
									.properties(scaleProps)
									.duration(life));
							}

							if (typeof(life) === 'number') {
								tempParticle.lifeSpan(life);
							}

							// Add the particle to this emitter's particle array
							//this._particles.push(tempParticle);

							// Add the particle to the scene
							tempParticle.mount(this._particleMountTarget || this._parent);

							// Start the relevant tweens
							for (i = 0; i < tweens.length; i++) {
								tweens[i].start();
							}
						}
					}
				}
			}
		}

		IgeEntity.prototype.tick.call(this, ctx);
	},

	/**
	 * Returns an array of the current particle entities that this
	 * emitter has spawned.
	 * @return {Array} The array of particle entities the emitter spawned.
	 */
	 /*
	particles: function () {
		return this._particles;
	},
*/
	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;
		return str;

		// TODO: WRITE THIS FOR THIS CLASS - EPIC AMOUNT OF WORK HERE
		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '':
						str += ".text(" + this.text() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeParticleEmitter; }
;var IgeParticle = IgeEntity.extend({
	classId: 'IgeParticle',
	
	init: function (emitter) {
		this._emitter = emitter;
		IgeEntity.prototype.init.call(this);

		// Setup the particle default values
		this.addComponent(IgeVelocityComponent);
	},

	destroy: function () {
		// Remove ourselves from the emitter
		if (this._emitter !== undefined) {
			this._emitter._particles.pull(this);
		}
		IgeEntity.prototype.destroy.call(this);
	}
});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = IgeParticle; }
;/**
 * Creates a new camera that will be attached to a viewport.
 */
var IgeCamera = IgeEntity.extend({
	classId: 'IgeCamera',

	init: function (entity) {
		IgeEntity.prototype.init.call(this);

		this._trackRotateTarget = undefined;
		this._trackTranslateTarget = undefined;
		this._trackRotateSmoothing = undefined;
		this._trackTranslateSmoothing = undefined;

		// Store the viewport this camera is attached to
		this._entity = entity;
	},

	/**
	 * Gets / sets the rectangle that the camera translate
	 * will be limited to using an IgeRect instance.
	 * @param {IgeRect=} rect
	 * @return {*}
	 */
	limit: function (rect) {
		// TODO: Write the usage of this limit data, currently does nothing
		if (rect !== undefined) {
			this._limit = rect;
			return this._entity;
		}

		return this._limit;
	},

	/**
	 * Pan (tween) the camera to the new specified point in
	 * the specified time.
	 * @param {IgePoint3d} point The point describing the co-ordinates to pan to.
	 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
	 * @param {String=} easing Optional easing method name.
	 */
	panTo: function (point, durationMs, easing) {
		if (point !== undefined) {
			this._translate.tween()
				.properties({
					x: point.x,
					y: point.y,
					z: point.z
				})
				.duration(durationMs)
				.easing(easing)
				.start();
		}

		return this._entity;
	},

	/**
	 * Pan (tween) the camera by the new specified point in
	 * the specified time.
	 * @param {IgePoint3d} point The point describing the co-ordinates to pan by.
	 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
	 * @param {String=} easing Optional easing method name.
	 */
	panBy: function (point, durationMs, easing) {
		if (point !== undefined) {
			this._translate.tween()
				.properties({
					x: point.x + this._translate.x,
					y: point.y + this._translate.y,
					z: point.z + this._translate.z
				})
				.duration(durationMs)
				.easing(easing)
				.start();
		}

		return this._entity;
	},

	/**
	 * Tells the camera to track the movement of the specified
	 * target entity. The camera will center on the entity.
	 * @param {IgeEntity} entity
	 * @param {Number=} smoothing Determines how quickly the camera
	 * will track the target, the higher the number, the slower the
	 * tracking will be.
	 * @param {Boolean=} rounding Sets if the smoothing system is
	 * allowed to use floating point values or not. If enabled then
	 * it will not use floating point values.
	 * @return {*}
	 */
	trackTranslate: function (entity, smoothing, rounding) {
		if (entity !== undefined) {
			this.log('Camera on viewport ' + this._entity.id() + ' is now tracking translation target ' + entity.id());
			if (rounding !== undefined) {
				this._trackTranslateRounding = rounding;
			}
			
			if (smoothing !== undefined) {
				this._trackTranslateSmoothing = smoothing >= 1  ? smoothing : 0;
			}
			
			this._trackTranslateTarget = entity;
			return this._entity;
		}

		return this._trackTranslateTarget;
	},

	/**
	 * Gets / sets the translate tracking smoothing value.
	 * @param {Number=} val
	 * @return {*}
	 */
	trackTranslateSmoothing: function (val) {
		if (val !== undefined) {
			this._trackTranslateSmoothing = val;
			return this;
		}

		return this._trackTranslateSmoothing;
	},

	/**
	 * Gets / sets the translate tracking smoothing rounding
	 * either enabled or disabled. When enabled the translate
	 * smoothing value will be rounded so that floating point
	 * values are not used which can help when smoothing on a
	 * scene that has texture smoothing disabled so sub-pixel
	 * rendering doesn't work and objects appear to "snap"
	 * into position as the smoothing interpolates.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	trackTranslateRounding: function (val) {
		if (val !== undefined) {
			this._trackTranslateRounding = val;
			return this;
		}

		return this._trackTranslateRounding;
	},

	/**
	 * Stops tracking the current tracking target's translation.
	 */
	unTrackTranslate: function () {
		delete this._trackTranslateTarget;
	},

	/**
	 * Tells the camera to track the rotation of the specified
	 * target entity.
	 * @param {IgeEntity} entity
	 * @param {Number=} smoothing Determines how quickly the camera
	 * will track the target, the higher the number, the slower the
	 * tracking will be.
	 * @return {*}
	 */
	trackRotate: function (entity, smoothing) {
		if (entity !== undefined) {
			this.log('Camera on viewport ' + this._entity.id() + ' is now tracking rotation of target ' + entity.id());
			this._trackRotateSmoothing = smoothing >= 1 ? smoothing : 0;
			this._trackRotateTarget = entity;
			return this._entity;
		}

		return this._trackRotateTarget;
	},

	/**
	 * Gets / sets the rotate tracking smoothing value.
	 * @param {Number=} val
	 * @return {*}
	 */
	trackRotateSmoothing: function (val) {
		if (val !== undefined) {
			this._trackRotateSmoothing = val;
			return this;
		}

		return this._trackRotateSmoothing;
	},

	/**
	 * Stops tracking the current tracking target.
	 */
	unTrackRotate: function () {
		delete this._trackRotateTarget;
	},

	/**
	 * Translates the camera to the center of the specified entity so
	 * that the camera is "looking at" the entity.
	 * @param {IgeEntity} entity The entity to look at.
	 * @param {Number=} durationMs If specified, will cause the
	 * camera to tween to the location of the entity rather than
	 * snapping to it instantly.
	 * @param {String=} easing The easing method name to use if
	 * tweening by duration.
	 * @return {*}
	 */
	lookAt: function (entity, durationMs, easing) {
		if (entity !== undefined) {
			entity.updateTransform();

			if (!durationMs) {
				// Copy the target's world matrix translate data
				this._translate.x = Math.floor(entity._worldMatrix.matrix[2]);
				this._translate.y = Math.floor(entity._worldMatrix.matrix[5]);
			} else {
				this._translate.tween()
					.properties({
						x: Math.floor(entity._worldMatrix.matrix[2]),
						y: Math.floor(entity._worldMatrix.matrix[5]),
						z: 0
					})
					.duration(durationMs)
					.easing(easing)
					.start();
			}

			this.updateTransform();
		}

		return this;
	},
	
	update: function (ctx) {
		// Process any behaviours assigned to the camera
		this._processUpdateBehaviours(ctx);
					
		// Check if we are tracking the translate value of a target
		if (this._trackTranslateTarget) {
			var targetEntity = this._trackTranslateTarget,
				targetMatrix = targetEntity._worldMatrix.matrix,
				targetX = targetMatrix[2],
				targetY = targetMatrix[5],
				sourceX, sourceY, distX, distY, destinationX, destinationY;

			if (!this._trackTranslateSmoothing) {
				// Copy the target's world matrix translate data
				this.lookAt(this._trackTranslateTarget);
			} else {
				// Ease between the current and target values
				sourceX = this._translate.x;
				sourceY = this._translate.y;

				distX = Math.round(targetX - sourceX);
				distY = Math.round(targetY - sourceY);

				if (this._trackTranslateRounding) {
					destinationX = this._translate.x + Math.round(distX / this._trackTranslateSmoothing);
					destinationY = this._translate.y + Math.round(distY / this._trackTranslateSmoothing);
				} else {
					destinationX = this._translate.x + distX / this._trackTranslateSmoothing;
					destinationY = this._translate.y + distY / this._trackTranslateSmoothing;
				}

				// Check camera Limits
				if ( this._limit){
	
					if (destinationX < this._limit.x) {
						destinationX = this._limit.x;
					}
					if (destinationX > this._limit.x + this._limit.width) {
						destinationX = this._limit.x + this._limit.width;
					}
					if (destinationY < this._limit.y) {
						destinationY = this._limit.y;
					}
					if (destinationY > this._limit.y + this._limit.height) {
						destinationY = this._limit.y + this._limit.height;
					}
						
				}

				this._translate.x = destinationX;
				this._translate.y = destinationY;

			 } 
		}

		// Check if we are tracking the rotation values of a target
		if (this._trackRotateTarget) {
			var targetParentRZ = this._trackRotateTarget._parent !== undefined ? this._trackRotateTarget._parent._rotate.z : 0,
				targetZ = -(targetParentRZ + this._trackRotateTarget._rotate.z),
				sourceZ, distZ;

			if (!this._trackRotateSmoothing) {
				// Copy the target's rotate data
				this._rotate.z = targetZ;
			} else {
				// Interpolate between the current and target values
				sourceZ = this._rotate.z;
				distZ = targetZ - sourceZ;

				this._rotate.z += distZ / this._trackRotateSmoothing;
			}
		}

		this.updateTransform();
	},

	/**
	 * Process operations during the engine tick.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	tick: function (ctx) {
		// Process any behaviours assigned to the camera
		this._processTickBehaviours(ctx);
		
		// Updated local transform matrix and then transform the context
		this._localMatrix.transformRenderingContext(ctx);
	},

	/**
	 * Checks the current transform values against the previous ones. If
	 * any value is different, the appropriate method is called which will
	 * update the transformation matrix accordingly. This version of the
	 * method is specifically designed for cameras!
	 */
	updateTransform: function () {
		this._localMatrix.identity();

		// On cameras we do the rotation and scaling FIRST
		this._localMatrix.multiply(this._localMatrix._newRotate(this._rotate.z));
		this._localMatrix.multiply(this._localMatrix._newScale(this._scale.x, this._scale.y));

		// 2d translation - cameras are never in iso mode!
		this._localMatrix.multiply(this._localMatrix._newTranslate(-this._translate.x, -this._translate.y));

		if (this._parent) {
			this._worldMatrix.copy(this._parent._worldMatrix);
			this._worldMatrix.multiply(this._localMatrix);
		} else {
			this._worldMatrix.copy(this._localMatrix);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @private
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_trackTranslateTarget':
						str += ".trackTranslate(ige.$('" + this._trackTranslateTarget.id() + "'), " + this.trackTranslateSmoothing() + ")";
						break;
					case '_trackRotateTarget':
						str += ".trackRotate(ige.$('" + this._trackRotateTarget.id() + "'), " + this.trackRotateSmoothing() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeCamera; };/**
 * Creates a new viewport.
 */
var IgeViewport = IgeEntity.extend([
	{extension: IgeUiStyleExtension, overwrite: true},
	{extension: IgeUiPositionExtension, overwrite: true}
], {
	classId: 'IgeViewport',
	IgeViewport: true,

	init: function (options) {
		var width, height;
		
		this._alwaysInView = true;
		IgeEntity.prototype.init.call(this);

		this._mouseAlwaysInside = true;
		this._mousePos = new IgePoint3d(0, 0, 0);
		this._overflow = '';
		this._clipping = true;
		this._bornTime = undefined;

		// Set default options if not specified
		// TODO: Is this required or even used?
		if (options) {
			width = options.width;
			height = options.height;
			
			if (options && options.scaleToWidth && options.scaleToHeight) {
				// Store the w/h we want to lock to
				this._lockDimension = new IgePoint3d(options.scaleToWidth, options.scaleToHeight, 0);
			}
		}

		// Setup default objects
		this._bounds2d = new IgePoint3d(width || ige._bounds2d.x, height || ige._bounds2d.y, 0);
		this.camera = new IgeCamera(this);
		this.camera._entity = this;
		//this._drawMouse = true;

		this.addComponent(PixiViewportRenderableComponent);
	},

	/**
	 * Sets the minimum amount of world in pixels to display in width and height.
	 * When set, if the viewport's geometry is reduced below the minimum width or
	 * height, the viewport's camera is automatically scaled to ensure that the
	 * minimum area remains visible in the viewport.
	 * @param {Integer} width Width in pixels.
	 * @param {Integer} height Height in pixels.
	 * @returns {*}
	 */
	minimumVisibleArea: function (width, height) {
		// Store the w/h we want to lock to
		this._lockDimension = new IgePoint3d(width, height, 0);
		if (ige.isClient) {
			this._resizeEvent({});
		}
		
		return this;
	},

	/**
	 * Gets / sets the auto-size property. If set to true, the viewport will
	 * automatically resize to fill the entire scene.
	 * @param val
	 * @return {*}
	 */
	autoSize: function (val) {
		if (typeof(val) !== 'undefined') {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	/**
	 * Gets / sets the scene that the viewport will render.
	 * @param {IgeScene2d} scene
	 * @return {*}
	 */
	scene: function (scene) {
		if (typeof(scene) !== 'undefined') {
			this._scene = scene;
			this._children.push(scene);
			this.emit('sceneSet', scene);
			return this;
		}

		return this._scene;
	},

	/**
	 * Returns the viewport's mouse position.
	 * @return {IgePoint3d}
	 */
	mousePos: function () {
		// Viewport mouse position is calculated and assigned in the
		// IgeInputComponent class.
		return this._mousePos.clone();
	},
	
	mousePosWorld: function () {
		return this._transformPoint(this._mousePos.clone());
	},

	/**
	 * Gets the current rectangular area that the viewport is "looking at"
	 * in the world. The co-ordinates are in world space.
	 * @returns {IgeRect}
	 */
	viewArea: function () {
		var aabb = this.aabb(),
			camTrans = this.camera._translate,
			camScale = this.camera._scale,
			width = aabb.width * (1 / camScale.x),
			height = aabb.height * (1 / camScale.y);
		
		return new IgeRect(
			(camTrans.x - width / 2),
			(camTrans.y - height / 2),
			width,
			height
		);
	},

	/**
	 * Processes the updates before the render tick is called.
	 * @param ctx
	 */
	update: function (ctx, tickDelta) {
		// Check if we have a scene attached to this viewport
		if (this._scene) {
			// Store the viewport camera in the main ige so that
			// down the scenegraph we can choose to negate the camera
			// transform effects
			ige._currentCamera = this.camera;
			ige._currentViewport = this;

			this._scene._parent = this;

			this.camera.update(ctx, tickDelta);
			IgeEntity.prototype.update.call(this, ctx, tickDelta);
			
			if (this._scene.newFrame()) {
				this._scene.update(ctx, tickDelta);
			}
		}
	},

	/**
	 * Processes the actions required each render frame.
	 */
	tick: function (ctx, scene) {
		// Check if we have a scene attached to this viewport
		// TODO: Once other IGE subsystems have been systemized, we don't need the tick function anymore. For now, it
		// needs to stay in order to support streaming and mouse input events.
		if (this._scene) {
/*			// Store the viewport camera in the main ige so that
			// down the scenegraph we can choose to negate the camera
			// transform effects
			ige._currentCamera = this.camera;
			ige._currentViewport = this;

			this._scene._parent = this;

			// Render our scene data
			//ctx.globalAlpha = ctx.globalAlpha * this._parent._opacity * this._opacity;
			IgeEntity.prototype.tick.call(this, ctx);

			// Translate to the top-left of the viewport
			ctx.translate(
				-(this._bounds2d.x * this._origin.x) | 0,
				-(this._bounds2d.y * this._origin.y) | 0
			);

			// Clear the rectangle area of the viewport
			ctx.clearRect(0, 0, this._bounds2d.x, this._bounds2d.y);

			// Clip the context so we only draw "inside" the viewport area
			if (this._clipping || this._borderColor) {
				ctx.beginPath();
				ctx.rect(0, 0, this._bounds2d.x / ige._scale.x, this._bounds2d.y / ige._scale.x);

				// Paint a border if required
				if (this._borderColor) {
					ctx.strokeStyle = this._borderColor;
					ctx.stroke();
				}
				
				if (this._clipping) {
					ctx.clip();
				}
			}

			// Translate back to the center of the viewport
			ctx.translate(((this._bounds2d.x / 2) | 0) + ige._translate.x, ((this._bounds2d.y / 2) | 0) + ige._translate.y);
			*//*ctx.translate(ige._translate.x, ige._translate.y);*//*
			if (ige._scale.x !== 1 || ige._scale.y !== 1) {
				ctx.scale(ige._scale.x, ige._scale.y);
			}

			// Transform the context to the center of the viewport
			// by processing the viewport's camera tick method
			this.camera.tick(ctx);

			// Draw the scene
			ctx.save();*/
				this._scene.tick(ctx);
			/*ctx.restore();

			// Check if we should draw guides
			if (this._drawGuides && ctx === ige._ctx) {
				ctx.save();
				ctx.translate(-this._translate.x, -this._translate.y);
				this.paintGuides(ctx);
				ctx.restore();
			}
			
			// Check if we should draw bounds on this viewport
			// (usually for debug purposes)
			if (this._drawBounds && ctx === ige._ctx) {
				// Traverse the scenegraph and draw axis-aligned
				// bounding boxes for every object
				ctx.save();
				ctx.translate(-this._translate.x, -this._translate.y);
				this.paintAabbs(ctx, this._scene, 0);
				ctx.restore();
			}

			// Check if we should draw the mouse position on this
			// viewport (usually for debug purposes)
			if (this._drawMouse && ctx === ige._ctx) {
				ctx.save();
				var mp = this.mousePos(),
					text,
					mx,
					my,
					textMeasurement;

				// Re-scale the context to ensure that output is always 1:1
				ctx.scale(1 / this.camera._scale.x, 1 / this.camera._scale.y);

				// Work out the re-scale mouse position
				mx = Math.floor(mp.x * this.camera._scale.x);
				my = Math.floor(mp.y * this.camera._scale.y);

				ctx.fillStyle = '#fc00ff';
				ctx.fillRect(mx - 5, my - 5, 10, 10);

				text = this.id() + ' X: ' + mx + ', Y: ' + my;
				textMeasurement = ctx.measureText(text);
				ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				ctx.fillRect(Math.floor(mx - textMeasurement.width / 2 - 5), Math.floor(my - 25), Math.floor(textMeasurement.width + 10), 14);
				ctx.fillStyle = '#ffffff';
				ctx.fillText(text, mx - textMeasurement.width / 2, my - 15);
				ctx.restore();
			}
			
			if (this._drawViewArea) {
				ctx.save();
					var va = this.viewArea();
					ctx.rect(va.x, va.y, va.width, va.height);
					ctx.stroke();
				ctx.restore();
			}*/
		}
	},

	/**
	 * Returns the screen position of the viewport as an IgePoint3d where x is the
	 * "left" and y is the "top", useful for positioning HTML elements at the
	 * screen location of an IGE entity. The returned values indicate the center
	 * of the viewport on the screen.
	 * 
	 * This method assumes that the top-left
	 * of the main canvas element is at 0, 0. If not you can adjust the values
	 * yourself to allow for offset.
	 * @example #Get the screen position of the entity
	 *     var screenPos = entity.screenPosition();
	 * @return {IgePoint3d} The screen position of the entity.
	 */
	screenPosition: function () {
		return new IgePoint3d(
			Math.floor(this._worldMatrix.matrix[2] + ige._bounds2d.x2),
			Math.floor(this._worldMatrix.matrix[5] + ige._bounds2d.y2),
			0
		);
	},
	
	drawViewArea: function (val) {
		if (val !== undefined) {
			this._drawViewArea = val;
			return this;
		}
		
		return this._drawViewArea;
	},

	drawBoundsLimitId: function (id) {
		if (id !== undefined) {
			this._drawBoundsLimitId = id;
			return this;
		}

		return this._drawBoundsLimitId;
	},

	drawBoundsLimitCategory: function (category) {
		if (category !== undefined) {
			this._drawBoundsLimitCategory = category;
			return this;
		}

		return this._drawBoundsLimitCategory;
	},
	
	drawCompositeBounds: function (val) {
		if (val !== undefined) {
			this._drawCompositeBounds = val;
			return this;
		}
		
		return this._drawCompositeBounds;
	},
	
	drawGuides: function (val) {
		if (val !== undefined) {
			this._drawGuides = val;
			return this;
		}
		
		return this._drawGuides;
	},
	
	paintGuides: function (ctx) {
		var geom = ige._bounds2d;
		
		// Check draw-guides setting
		if (this._drawGuides) {
			ctx.strokeStyle = '#ffffff';
			
			ctx.translate(0.5, 0.5);
			
			// Draw guide lines in the center
			ctx.beginPath();
			ctx.moveTo(0, -geom.y2);
			ctx.lineTo(0, geom.y);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(-geom.x2, 0);
			ctx.lineTo(geom.x, 0);
			ctx.stroke();
		}
	},

	/**
	 * Draws the bounding data for each entity in the scenegraph.
	 * @param ctx
	 * @param rootObject
	 * @param index
	 */
	paintAabbs: function (ctx, rootObject, index) {
		var arr = rootObject._children,
			arrCount,
			obj,
			aabb,
			aabbC,
			bounds3dPoly,
			ga,
			r3d,
			xl1, xl2, xl3, xl4, xl5, xl6,
			bf1, bf2, bf3, bf4,
			tf1, tf2, tf3, tf4;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				obj = arr[arrCount];
				index++;

				if (obj._shouldRender !== false) {
					if (obj._classId !== 'IgeScene2d' && (!this._drawBoundsLimitId && !this._drawBoundsLimitCategory) || ((this._drawBoundsLimitId && (this._drawBoundsLimitId instanceof Array ? this._drawBoundsLimitId.indexOf(obj.id()) > -1 : this._drawBoundsLimitId === obj.id())) || (this._drawBoundsLimitCategory && this._drawBoundsLimitCategory === obj.category()))) {
						if (typeof(obj.aabb) === 'function') {
							// Grab the AABB and then draw it
							aabb = obj.aabb();

							if (this._drawCompositeBounds && obj.renderable._compositeCache) {
								aabbC = obj.compositeAabb();
								
								// Draw composite bounds
								ctx.strokeStyle = '#ff0000';
								ctx.strokeRect(aabbC.x, aabbC.y, aabbC.width, aabbC.height);
							}
							
							if (aabb) {
								if (obj._drawBounds || obj._drawBounds === undefined) {
									//if (!obj._parent || (obj._parent && obj._parent._mountMode !== 1)) {
										// Draw a rect around the bounds of the object transformed in world space
										/*ctx.save();
											obj._worldMatrix.transformRenderingContext(ctx);
											ctx.strokeStyle = '#9700ae';
											ctx.strokeRect(-obj._bounds2d.x2, -obj._bounds2d.y2, obj._bounds2d.x, obj._bounds2d.y);
										ctx.restore();*/
										
										// Draw individual bounds
										ctx.strokeStyle = '#00deff';
										ctx.strokeRect(aabb.x, aabb.y, aabb.width, aabb.height);
									//}

									// Check if the object is mounted to an isometric mount
									if (obj._parent && obj._parent._mountMode === 1) {
										bounds3dPoly = obj.bounds3dPolygon().aabb();
										ctx.save();
											ctx.strokeStyle = '#0068b8';
											ctx.strokeRect(bounds3dPoly.x, bounds3dPoly.y, bounds3dPoly.width, bounds3dPoly.height);
										ctx.restore();
										
										ctx.save();
											ctx.translate(
												bounds3dPoly.x + bounds3dPoly.width / 2,
												bounds3dPoly.y + bounds3dPoly.height / 2
											);
											//obj._transformContext(ctx);

											// Calculate the 3d bounds data
											r3d = obj._bounds3d;
											xl1 = new IgePoint3d(-(r3d.x / 2), 0, 0).toIso();
											xl2 = new IgePoint3d(+(r3d.x / 2), 0, 0).toIso();
											xl3 = new IgePoint3d(0, -(r3d.y / 2), 0).toIso();
											xl4 = new IgePoint3d(0, +(r3d.y / 2), 0).toIso();
											xl5 = new IgePoint3d(0, 0, -(r3d.z / 2)).toIso();
											xl6 = new IgePoint3d(0, 0, +(r3d.z / 2)).toIso();
											// Bottom face
											bf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											// Top face
											tf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();

											ga = ctx.globalAlpha;

											// Axis lines
											ctx.globalAlpha = 1;
											ctx.strokeStyle = '#ff0000';
											ctx.beginPath();
											ctx.moveTo(xl1.x, xl1.y);
											ctx.lineTo(xl2.x, xl2.y);
											ctx.stroke();
											ctx.strokeStyle = '#00ff00';
											ctx.beginPath();
											ctx.moveTo(xl3.x, xl3.y);
											ctx.lineTo(xl4.x, xl4.y);
											ctx.stroke();
											ctx.strokeStyle = '#fffc00';
											ctx.beginPath();
											ctx.moveTo(xl5.x, xl5.y);
											ctx.lineTo(xl6.x, xl6.y);
											ctx.stroke();

											ctx.strokeStyle = '#a200ff';

											if (obj.highlight()) {
												ctx.globalAlpha = 0.9;
											} else {
												ctx.globalAlpha = 0.6;
											}

											// Left face
											ctx.fillStyle = '#545454';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf4.x, bf4.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();

											// Right face
											ctx.fillStyle = '#282828';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf2.x, bf2.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();

											// Top face
											ctx.fillStyle = '#676767';
											ctx.beginPath();
											ctx.moveTo(tf1.x, tf1.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf1.x, tf1.y);
											ctx.fill();
											ctx.stroke();

											ctx.globalAlpha = ga;
										ctx.restore();
									}
								}

								if (this._drawBoundsData  && (obj._drawBounds || obj._drawBoundsData === undefined)) {
									ctx.globalAlpha = 1;
									ctx.fillStyle = '#f6ff00';
									ctx.fillText('ID: ' + obj.id() + ' ' + '(' + obj.classId() + ') ' + obj.layer() + ':' + obj.depth().toFixed(0), aabb.x + aabb.width + 3, aabb.y + 10);
									ctx.fillText('X: ' + obj._translate.x.toFixed(2) + ', ' + 'Y: ' + obj._translate.y.toFixed(2) + ', ' + 'Z: ' + obj._translate.z.toFixed(2), aabb.x + aabb.width + 3, aabb.y + 20);
									ctx.fillText('Num Children: ' + obj._children.length, aabb.x + aabb.width + 3, aabb.y + 40);
								}
							}
						}
					}

					this.paintAabbs(ctx, obj, index);
				}
			}
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		if (this._autoSize && this._parent) {
			this._bounds2d = this._parent._bounds2d.clone();
		}

		this._updateUiPosition();

		// Resize the scene
		if (this._scene) {
			this._scene._resizeEvent(event);
		}
		
		// Process locked dimension scaling
		if (this._lockDimension) {
			// Calculate the new camera scale
			var ratio = 1,
				tmpX,
				tmpY;
			
			if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
				// Scale using lowest ratio
				tmpX = this._bounds2d.x / this._lockDimension.x;
				tmpY = this._bounds2d.y / this._lockDimension.y;
				
				ratio = tmpX < tmpY ? tmpX : tmpY;
			} else {
				if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
					// Scale out to show height
					ratio = this._bounds2d.y / this._lockDimension.y;
				}
				
				if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
					// Scale out to show width
					ratio = this._bounds2d.x / this._lockDimension.x;
				}
				
				if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
					// Scale using lowest ratio
					tmpX = this._bounds2d.x / this._lockDimension.x;
					tmpY = this._bounds2d.y / this._lockDimension.y;
					
					ratio = tmpX < tmpY ? tmpX : tmpY;
				}
			}
			
			this.camera.scaleTo(ratio, ratio, ratio);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_autoSize':
						str += ".autoSize(" + this._autoSize + ")";
						break;
					case '_scene':
						str += ".scene(ige.$('" + this.scene().id() + "'))";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeViewport; };/**
 * Creates a new 2d scene.
 */
var IgeScene2d = IgeEntity.extend({
	classId: 'IgeScene2d',
	/**
	 * Controls whether or not the scene calls its children's resize event when
	 * its resize event is called.
	 * @type {Boolean}
	 * @memberof IgeScene2d
	 * @private
	 * @instance
	 */
	_resizeSceneChildren: true,

	init: function () {
		this._mouseAlwaysInside = true;
		this._alwaysInView = true;
		IgeEntity.prototype.init.call(this);

		this._shouldRender = true;
		this._autoSize = true;

		// Set the geometry of the scene to the main canvas
		// width / height - used when positioning UI elements
		this._bounds2d.x = ige._bounds2d.x;
		this._bounds2d.y = ige._bounds2d.y;
		
		this.streamSections(['transform', 'ignoreCamera']);

		this.addComponent(PixiRenderableComponent);
	},

	/**
	 * Gets / sets the stream room id. If set, any streaming entities that
	 * are mounted to this scene will only sync with clients that have been
	 * assigned to this room id.
	 * 
	 * @param {String} id The id of the room. 
	 * @returns {*}
	 */
	streamRoomId: function (id) {
		if (id !== undefined) {
			this._streamRoomId = id;
			return this;
		}
		
		return this._streamRoomId;
	},

	/**
	 * Overrides the default entity stream sections to also stream important
	 * data about scenes to the client.
	 * @param sectionId
	 * @param data
	 * @returns {*}
	 */
	streamSectionData: function (sectionId, data) {
		switch (sectionId) {
			case 'ignoreCamera':
				if (data !== undefined) {
					// Setter
					if (data === 'false') {
						this.ignoreCamera(false);
					} else {
						this.ignoreCamera(true);
					}
				} else {
					// Getter
					return String(this._ignoreCamera);
				}
				break;
			
			default:
				IgeEntity.prototype.streamSectionData.call(this, sectionId, data);
				break;
		}
	},

	/**
	 * Gets / sets the auto-size property. If set to true, the scene will
	 * automatically resize to the engine's canvas geometry.
	 * @param {Boolean=} val If true, will autosize the scene to match the
	 * main canvas geometry. This is enabled by default and is unlikely to
	 * help you if you switch it off.
	 * @return {*}
	 */
	autoSize: function (val) {
		if (typeof(val) !== 'undefined') {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	/**
	 * Gets / sets the _shouldRender property. If set to true, the scene's child
	 * object's tick methods will be called.
	 * @param {Boolean} val If set to false, no child entities will be rendered.
	 * @return {Boolean}
	 */
	shouldRender: function (val) {
		if (val !== undefined) {
			this._shouldRender = val;
			return this;
		}

		return this._shouldRender;
	},

	/**
	 * Gets / sets the flag that determines if the scene will ignore camera
	 * transform values allowing the scene to remain static on screen
	 * regardless of the camera transform.
	 * @param {Boolean=} val True to ignore, false to not ignore.
	 * @return {*}
	 */
	ignoreCamera: function (val) {
		if (val !== undefined) {
			this._ignoreCamera = val;
			return this;
		}

		return this._ignoreCamera;
	},
	
	update: function (ctx, tickDelta) {
		if (this._ignoreCamera) {
			// Translate the scene so it is always center of the camera
			var cam = ige._currentCamera;
			this.translateTo(cam._translate.x, cam._translate.y, cam._translate.z);
			this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
			this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);
			//this._localMatrix.multiply(ige._currentCamera._worldMatrix.getInverse());
		}
		
		IgeEntity.prototype.update.call(this, ctx, tickDelta);
	},

	/**
	 * Processes the actions required each render frame.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 */
	tick: function (ctx) {
		if (this._shouldRender) {
			IgeEntity.prototype.tick.call(this, ctx);
		}
	},

	/**
	 * Getter/setter for the resizeSceneChildren property.
	 * @param val {Boolean} Optional parameter. If set, this is the new
	 * resizeSceneChildren value.
	 * @returns {*} resizeSceneChildren value if no parameter is passed or this
	 * object if a parameter is passed to make setter chaining convenient.
	 * @memberof IgeScene2d
	 * @instance
	 */
	resizeSceneChildren: function(val) {
		if (val !== undefined) {
			this._resizeSceneChildren = val;
			return this;
		}
		return this._resizeSceneChildren;
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		// Set width / height of scene to match main ige (SCENES ARE ALWAYS THE FULL IGE SIZE!!)
		if (this._autoSize) {
			this._bounds2d = ige._bounds2d.clone();
		}

		if (this._resizeSceneChildren === false) {
			return;
		}

		// Resize any children
		var arr = this._children,
			arrCount = arr.length;

		while (arrCount--) {
			arr[arrCount]._resizeEvent(event);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_shouldRender':
						str += ".shouldRender(" + this.shouldRender() + ")";
						break;
					case '_autoSize':
						str += ".autoSize(" + this.autoSize() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeScene2d; }
;var IgeArray = function () {};
IgeArray.prototype = [];

// Empower the IgeArray with all the method calls of the an IgeEntity
for (var methodName in IgeEntity.prototype) {
	if (IgeEntity.prototype.hasOwnProperty(methodName)) {
		if (methodName !== 'init') {
			IgeArray.prototype[methodName] = function (methodName) {
				return function () {
					var c = this.length;
					for (var i = 0; i < c; i++) {
						this[i][methodName].apply(this[i], arguments);
					}
				}
			}(methodName);
		}
	}
}

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeArray; };var IgeUiTimeStream = IgeUiElement.extend({
	classId: 'IgeUiTimeStream',

	monitor: function (entity) {
		this._entity = entity;
	},

	tick: function (ctx) {
		// Draw timeline
		var i, text, xAdjust,
			arr, arrCount, arrItem,
			renderTime = ige._tickStart - ige.network.stream._renderLatency,
			deltaTime;

		IgeUiElement.prototype.tick.call(this, ctx);

		ctx.strokeStyle = '#fffc00';
		ctx.beginPath();
		ctx.moveTo(-200, -25.5);
		ctx.lineTo(200, -25.5);
		ctx.stroke();

		ctx.font = 'normal 10px Verdana';

		for (i = 0; i < 9; i++) {
			ctx.beginPath();
			if (((i - 2) * 10) === 0) {
				// This is the render point, change colour for this one
				ctx.strokeStyle = '#ff6600';
			} else {
				ctx.strokeStyle = '#ffffff';
			}
			ctx.moveTo(-200.5 + (i * 50), -30);
			ctx.lineTo(-200.5 + (i * 50), 30);
			ctx.stroke();

			text = -ige.network.stream._renderLatency + ((i - 2) * 10) + 'ms';
			xAdjust = ctx.measureText(text);
			ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -38);

			if (((i - 2) * 10) === 0) {
				text = 'Render Point';
				xAdjust = ctx.measureText(text);
				ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -52);
			}
		}

		if (this._entity) {
			arr = this._entity._timeStream;

			// Check if we have a time stream and data
			if (arr && arr.length) {
				arrCount = arr.length;

				for (i = 0; i < arrCount; i++) {
					arrItem = arr[i];

					deltaTime = arrItem[0] - renderTime;

					ctx.strokeRect(-105 + ((deltaTime / 10) * 50), -5, 10, 10);
				}
			}

			ige.client.custom2.value = this._entity._timeStreamDataDelta;
			ige.client.custom3.value = this._entity._timeStreamOffsetDelta;
			ige.client.custom4.value = this._entity._timeStreamCurrentInterpolateTime;
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiTimeStream; };//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);
;/**
 * The base engine class definition.
 */
var IgeEngine = IgeEntity.extend({
	classId: 'IgeEngine',

	init: function () {
		// Deal with some debug settings first
		if (igeConfig.debug) {
			if (!igeConfig.debug._enabled) {
				// Debug is not enabled so ensure that
				// timing debugs are disabled
				igeConfig.debug._timing = false;
			}
		}

		this._alwaysInView = true;

		this._id = 'ige';
		this.basePath = '';

		// Determine the environment we are executing in
		this.isServer = (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined');
		this.isClient = !this.isServer;

		// Load UUID library. On Node.js, the RNG comes from the Crypto module
		if (this.isServer) {
			this._uuid = rootRequire('node-uuid');
		}
		else {
			// Loaded from CoreConfig. On the client, the RNG depends on the browser
			this._uuid = uuid;
		}

		// Assign ourselves to the global variable
		ige = this;

		// Output our header
		console.log('------------------------------------------------------------------------------');
		console.log('* Powered by the Isogenic Game Engine ' + igeVersion + '                  *');
		console.log('* (C)opyright ' + new Date().getFullYear() + ' Irrelon Software Limited                                  *');
		console.log('* http://www.isogenicengine.com                                              *');
		console.log('------------------------------------------------------------------------------');
		
		IgeEntity.prototype.init.call(this);

		// Create storage
		this._textureStore = [];

		// Set the initial id as the current time in milliseconds. This ensures that under successive
		// restarts of the engine, new ids will still always be created compared to earlier runs -

		// Setup components
		this.addComponent(IgeInputComponent);
		this.addComponent(IgeTweenComponent);
		this.addComponent(IgeTimeComponent);

		this._requireScriptTotal = 0;
		this._requireScriptLoading = 0;
		this._loadingPreText = undefined; // The text to put in front of the loading percent on the loading progress screen
		this._enableUpdates = true;
		this._enableRenders = true;
		this._showSgTree = false;
		this._debugEvents = {}; // Holds debug event booleans for named events
		this._tickTime = 'NA'; // The time the tick took to process
		this._updateTime = 'NA'; // The time the tick update section took to process
		this._renderTime = 'NA'; // The time the tick render section took to process
		this._tickDelta = 0; // The time between the last tick and the current one
		this._fpsRate = 60; // Sets the frames per second to execute engine tick's at
		this._state = 0; // Currently stopped
		this._textureImageStore = {};
		this._texturesLoading = 0; // Holds a count of currently loading textures
		this._texturesTotal = 0; // Holds total number of textures loading / loaded
		this._dependencyQueue = []; // Holds an array of functions that must all return true for the engine to start
		this._drawCount = 0; // Holds the number of draws since the last frame (calls to drawImage)
		this._dps = 0; // Number of draws that occurred last tick
		this._dpf = 0;
		this._frames = 0; // Number of frames looped through since last second tick
		this._fps = 0; // Number of frames per second
		this._clientNetDiff = 0; // The difference between the server and client comms (only non-zero on clients)
		this._frameAlternator = false; // Is set to the boolean not of itself each frame
		this._viewportDepth = false;
		this._mousePos = new IgePoint3d(0, 0, 0);
		this._currentViewport = null; // Set in IgeViewport.js tick(), holds the current rendering viewport
		this._currentCamera = null; // Set in IgeViewport.js tick(), holds the current rendering viewport's camera
		this._currentTime = 0; // The current engine time
		this._register = {
			'ige': this
		}; // Holds a reference to every item in the scenegraph by it's ID
		this._categoryRegister = {}; // Holds reference to every item with a category
		this._groupRegister = {}; // Holds reference to every item with a group
		this._postTick = []; // An array of methods that are called upon tick completion
		this._timeSpentInTick = {}; // An object holding time-spent-in-tick (total time spent in this object's tick method)
		this._timeSpentLastTick = {}; // An object holding time-spent-last-tick (time spent in this object's tick method last tick)
		this._timeScale = 1; // The default time scaling factor to speed up or slow down engine time
		this._globalScale = new IgePoint3d(1, 1, 1);
		this._graphInstances = []; // Holds an array of instances of graph classes
		this._spawnQueue = []; // Holds an array of entities that are yet to be born

		// Set the context to a dummy context to start
		// with in case we are in "headless" mode and
		// a replacement context never gets assigned
		this._ctx = IgeDummyContext;
		this._headless = true;

		this.dependencyTimeout(30000); // Wait 30 seconds to load all dependencies then timeout

		// Add the textures loaded dependency
		this._dependencyQueue.push(this.texturesLoaded);
		//this._dependencyQueue.push(this.rendering.canvasReady);

		// Start a timer to record every second of execution
		this._secondTimer = setInterval(this._secondTick, 1000);
	},

	/**
	 * Returns an object from the engine's object register by
	 * the object's id. If the item passed is not a string id
	 * then the item is returned as is. If no item is passed
	 * the engine itself is returned.
	 * @param {String || Object} item The id of the item to return,
	 * or if an object, returns the object as-is.
	 */
	$: function (item) {
		if (typeof(item) === 'string') {
			return this._register[item];
		} else if (typeof(item) === 'object') {
			return item;
		}
		return undefined;
	},

	/**
	 * Returns an array of all objects that have been assigned
	 * the passed category name.
	 * @param {String} categoryName The name of the category to return
	 * all objects for.
	 */
	$$: function (categoryName) {
		return this._categoryRegister[categoryName] || new IgeArray();
	},

	/**
	 * Returns an array of all objects that have been assigned
	 * the passed group name.
	 * @param {String} groupName The name of the group to return
	 * all objects for.
	 */
	$$$: function (groupName) {
		return this._groupRegister[groupName] || new IgeArray();
	},

	/**
	 * Register an object with the engine object register. The
	 * register allows you to access an object by it's id with
	 * a call to ige.$(objectId).
	 * @param {Object} obj The object to register.
	 * @return {*}
	 */
	register: function (obj) {
		if (obj !== undefined) {
			if (!this._register[obj.id()]) {
				this._register[obj.id()] = obj;
				obj._registered = true;

				return this;
			} else {
				obj._registered = false;

				this.log('Cannot add object id "' + obj.id() + '" to scenegraph because there is already another object in the graph with the same ID!', 'error');
				return false;
			}
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine object register. The
	 * object will no longer be accessible via ige.$().
	 * @param {Object} obj The object to un-register.
	 * @return {*}
	 */
	unRegister: function (obj) {
		if (obj !== undefined) {
			// Check if the object is registered in the ID lookup
			if (this._register[obj.id()]) {
				delete this._register[obj.id()];
				obj._registered = false;
			}
		}

		return this;
	},

	/**
	 * Register an object with the engine category register. The
	 * register allows you to access an object by it's category with
	 * a call to ige.$$(categoryName).
	 * @param {Object} obj The object to register.
	 * @return {*}
	 */
	categoryRegister: function (obj) {
		if (obj !== undefined) {
			this._categoryRegister[obj._category] = this._categoryRegister[obj._category] || new IgeArray();
			this._categoryRegister[obj._category].push(obj);
			obj._categoryRegistered = true;
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine category register. The
	 * object will no longer be accessible via ige.$$().
	 * @param {Object} obj The object to un-register.
	 * @return {*}
	 */
	categoryUnRegister: function (obj) {
		if (obj !== undefined) {
			if (this._categoryRegister[obj._category]) {
				this._categoryRegister[obj._category].pull(obj);
				obj._categoryRegistered = false;
			}
		}

		return this;
	},

	/**
	 * Register an object with the engine group register. The
	 * register allows you to access an object by it's groups with
	 * a call to ige.$$$(groupName).
	 * @param {Object} obj The object to register.
	 * @param {String} groupName The name of the group to register
	 * the object in.
	 * @return {*}
	 */
	groupRegister: function (obj, groupName) {
		if (obj !== undefined) {
			this._groupRegister[groupName] = this._groupRegister[groupName] || new IgeArray();
			this._groupRegister[groupName].push(obj);
			obj._groupRegistered = true;
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine group register. The
	 * object will no longer be accessible via ige.$$$().
	 * @param {Object} obj The object to un-register.
	 * @param {String} groupName The name of the group to un-register
	 * the object from.
	 * @return {*}
	 */
	groupUnRegister: function (obj, groupName) {
		if (obj !== undefined) {
			if (groupName !== undefined) {
				if (this._groupRegister[groupName]) {
					this._groupRegister[groupName].pull(obj);

					if (!obj.groupCount()) {
						obj._groupRegister = false;
					}
				}
			} else {
				// Call the removeAllGroups() method which will loop
				// all the groups that the object belongs to and
				// automatically un-register them
				obj.removeAllGroups();
			}
		}

		return this;
	},
	
	sync: function (method, attrArr) {
		if (typeof(attrArr) === 'string') {
			attrArr = [attrArr];
		}
		
		this._syncArr = this._syncArr || [];
		this._syncArr.push({method: method, attrArr: attrArr});
		
		if (this._syncArr.length === 1) {
			// Start sync waterfall
			this._syncIndex = 0;
			this._processSync();
		}
	},
	
	_processSync: function () {
		var syncEntry;
		
		if (ige._syncIndex < ige._syncArr.length) {
			syncEntry = ige._syncArr[ige._syncIndex];
			
			// Add the callback to the last attribute
			syncEntry.attrArr.push(function () {
				ige._syncIndex++;
				setTimeout(ige._processSync, 1);
			});
			
			// Call the method
			syncEntry.method.apply(ige, syncEntry.attrArr);
		} else {
			// Reached end of sync cycle
			delete ige._syncArr;
			delete ige._syncIndex;
			
			ige.emit('syncComplete');
		}
	},

	/**
	 * Load a js script file into memory via a path or url. 
	 * @param {String} url The file's path or url.
	 * @param {Function=} callback Optional callback when script loads.
	 */
	requireScript: function (url, callback) {
		if (url !== undefined) {
			var self = this;
			
			// Add to the load counter
			self._requireScriptTotal++;
			self._requireScriptLoading++;
			
			// Create the script element
			var elem = document.createElement('script');
			elem.addEventListener('load', function () {
				self._requireScriptLoaded(this);
				
				if (callback) {
					setTimeout(function () { callback(); }, 100);
				}
			});
			
			// For compatibility with CocoonJS
			document.body.appendChild(elem);
			
			// Set the source to load the url
			elem.src = url;
			
			this.log('Loading script from: ' + url);
			this.emit('requireScriptLoading', url);
		}
	},

	/**
	 * Called when a js script has been loaded via the requireScript
	 * method.
	 * @param {Element} elem The script element added to the DOM.
	 * @private
	 */
	_requireScriptLoaded: function (elem) {
		this._requireScriptLoading--;
		
		this.emit('requireScriptLoaded', elem.src);
		
		if (this._requireScriptLoading === 0) {
			// All scripts have loaded, fire the engine event
			this.emit('allRequireScriptsLoaded');
		}
	},
	
	/**
	 * Load a css style file into memory via a path or url. 
	 * @param {String} url The file's path or url.
	 */
	requireStylesheet: function (url) {
		if (url !== undefined) {
			var self = this;
			
			// Load the engine stylesheet
			var css = document.createElement('link');
			css.rel = 'stylesheet';
			css.type = 'text/css';
			css.media = 'all';
			css.href = url;
			
			document.getElementsByTagName('head')[0].appendChild(css);
			
			this.log('Load css stylesheet from: ' + url);
		}
	},

	/**
	 * Adds a scenegraph class into memory.
	 * @param {String} className The name of the scenegraph class.
	 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
	 * @returns {*}
	 */
	addGraph: function (className, options) {
		if (className !== undefined) {
			var classObj = this.getClass(className),
				classInstance;
			
			if (classObj) {
				this.log('Loading SceneGraph data class: ' + className);
				classInstance = this.newClassInstance(className);
				
				// Make sure the graph class implements the required methods "addGraph" and "removeGraph"
				if (typeof(classInstance.addGraph) === 'function' && typeof(classInstance.removeGraph) === 'function') {
					// Call the class's graph() method passing the options in
					classInstance.addGraph(options);
					
					// Add the graph instance to the holding array
					this._graphInstances[className] = classInstance;
				} else {
					this.log('Could not load graph for class name "' + className + '" because the class does not implement both the require methods "addGraph()" and "removeGraph()".', 'error');
				}
			} else {
				this.log('Cannot load graph for class name "' + className + '" because the class could not be found. Have you included it in your server/clientConfig.js file?', 'error');
			}
		}
		
		return this;
	},
	
	/**
	 * Removes a scenegraph class into memory.
	 * @param {String} className The name of the scenegraph class.
	 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
	 * @returns {*}
	 */
	removeGraph: function (className, options) {
		if (className !== undefined) {
			var classInstance = this._graphInstances[className];
			
			if (classInstance) {
				this.log('Removing SceneGraph data class: ' + className);
				
				// Call the class's graph() method passing the options in
				classInstance.removeGraph(options);
				
				// Now remove the graph instance from the graph instance array
				delete this._graphInstances[className];
			} else {
				this.log('Cannot remove graph for class name "' + className + '" because the class instance could not be found. Did you add it via ige.addGraph() ?', 'error');
			}
		}
		
		return this;
	},

	/**
	 * Allows the update() methods of the entire scenegraph to
	 * be temporarily enabled or disabled. Useful for debugging.
	 * @param {Boolean=} val If false, will disable all update() calls. 
	 * @returns {*}
	 */
	enableUpdates: function (val) {
		if (val !== undefined) {
			this._enableUpdates = val;
			return this;
		}
		
		return this._enableUpdates;
	},

	/**
	 * Allows the tick() methods of the entire scenegraph to
	 * be temporarily enabled or disabled. Useful for debugging.
	 * @param {Boolean=} val If false, will disable all tick() calls. 
	 * @returns {*}
	 */
	enableRenders: function (val) {
		if (val !== undefined) {
			this._enableRenders = val;
			return this;
		}

		return this._enableRenders;
	},

	/**
	 * Enables or disables the engine's debug mode. Enabled by default.
	 * @param {Boolean=} val If true, will enable debug mode. 
	 * @returns {*}
	 */
	debugEnabled: function (val) {
		if (val !== undefined) {
			if (igeConfig.debug) {
				igeConfig.debug._enabled = val;
			}
			return this;
		}

		return igeConfig.debug._enabled;
	},
	
	/**
	 * Enables or disables the engine's debug timing system. The
	 * timing system will time all update and rendering code down
	 * the scenegraph and is useful for tracking long-running code
	 * but comes with a small performance penalty when enabled.
	 * Enabled by default.
	 * @param {Boolean=} val If true, will enable debug timing mode. 
	 * @returns {*}
	 */
	debugTiming: function (val) {
		if (val !== undefined) {
			if (igeConfig.debug) {
				igeConfig.debug._timing = val;
			}
			return this;
		}

		return igeConfig.debug._timing;
	},

	debug: function (eventName) {
		if (this._debugEvents[eventName] === true || this._debugEvents[eventName] === ige._frames) {
			debugger;
		}
	},

	debugEventOn: function (eventName) {
		this._debugEvents[eventName] = true;
	},

	debugEventOff: function (eventName) {
		this._debugEvents[eventName] = false;
	},

	triggerDebugEventFrame: function (eventName) {
		this._debugEvents[eventName] = ige._frames;
	},

	/**
	 * Sets the opacity of every object on the scenegraph to
	 * zero *except* the one specified by the given id argument.
	 * @param {String} id The id of the object not to hide.
	 */
	hideAllExcept: function (id) {
		var i,
			arr = this._register;

		for (i in arr) {
			if (i !== id) {
				arr[i].opacity(0);
			}
		}
	},

	/**
	 * Calls the show() method for every object on the scenegraph.
	 */
	showAll: function () {
		var i,
			arr = this._register;

		for (i in arr) {
			arr[i].show();
		}
	},

	/**
	 * Sets the frame rate at which new engine steps are fired.
	 * Setting this rate will override the default requestAnimFrame()
	 * method as defined in IgeBase.js and on the client-side, will
	 * stop usage of any available requestAnimationFrame() method
	 * and will use a setTimeout()-based version instead.
	 * @param {Number} fpsRate
	 */
	setFps: function (fpsRate) {
		if (fpsRate !== undefined) {
			// Override the default requestAnimFrame handler and set
			// our own method up so that we can control the frame rate
			if (this.isServer) {
				// Server-side implementation
				requestAnimFrame = function(callback, element){
					setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
				};
			} else {
				// Client-side implementation
				window.requestAnimFrame = function(callback, element){
					setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
				};
			}
		}
	},

	showStats: function () {
		this.log('showStats has been removed from the ige in favour of the new editor component, please remove this call from your code.');
	},

	/**
	 * Defines a class in the engine's class repository.
	 * @param {String} id The unique class ID or name.
	 * @param {Object} obj The class definition.
	 */
	defineClass: function (id, obj) {
		igeClassStore[id] = obj;
	},

	/**
	 * Retrieves a class by it's ID that was defined with
	 * a call to defineClass().
	 * @param {String} id The ID of the class to retrieve.
	 * @return {Object} The class definition.
	 */
	getClass: function (id) {
		return igeClassStore[id];
	},

	/**
	 * Returns true if the class specified has been defined.
	 * @param {String} id The ID of the class to check for.
	 * @returns {*}
	 */
	classDefined: function (id) {
		return Boolean(igeClassStore[id]);
	},

	/**
	 * Generates a new instance of a class defined with a call
	 * to the defineClass() method. Passes the options
	 * parameter to the new class during it's constructor call.
	 * @param id
	 * @param options
	 * @return {*}
	 */
	newClassInstance: function (id, options) {
		return new igeClassStore[id](options);
	},

	/**
	 * Checks if all engine start dependencies have been satisfied.
	 * @return {Boolean}
	 */
	dependencyCheck: function () {
		var arr = this._dependencyQueue,
			arrCount = arr.length;

		while (arrCount--) {
			if (!this._dependencyQueue[arrCount]()) {
				return false;
			}
		}

		return true;
	},

	/**
	 * Gets / sets the flag that determines if viewports should be sorted by depth
	 * like regular entities, before they are processed for rendering each frame.
	 * Depth-sorting viewports increases processing requirements so if you do not
	 * need to stack viewports in a particular order, keep this flag false.
	 * @param {Boolean} val
	 * @return {Boolean}
	 */
	viewportDepth: function (val) {
		if (val !== undefined) {
			this._viewportDepth = val;
			return this;
		}

		return this._viewportDepth;
	},

	/**
	 * Sets the number of milliseconds before the engine gives up waiting for dependencies
	 * to be satisfied and cancels the startup procedure.
	 * @param val
	 */
	dependencyTimeout: function (val) {
		this._dependencyCheckTimeout = val;
	},

	/**
	 * Updates the loading screen DOM elements to show the update progress.
	 */
	updateProgress: function () {
		// TODO: Remove this fudge factor and make the progress bar more accurate
		var fudgeFactor = 0.15;
		// Check for a loading progress bar DOM element
		if (typeof(document) !== 'undefined' && document.getElementById) {
			var elem = document.getElementById('loadingProgressBar'),
				textElem = document.getElementById('loadingText');
			
			if (elem) {
				var percentage = Math.max(0, Math.floor((100 / this._texturesTotal) * (this._texturesTotal -
					this._texturesLoading) - fudgeFactor * 100));
				// Calculate the width from progress
				var totalWidth = parseInt(elem.parentNode.offsetWidth);
				var currentWidth = Math.floor(percentage / 100 * totalWidth);
				
				// Set the current bar width
				elem.style.width = currentWidth + 'px';
				
				if (textElem) {
					if (this._loadingPreText === undefined) {
						// Fill the text to use
						this._loadingPreText = textElem.innerHTML;
					}
					textElem.innerHTML = this._loadingPreText + ' ' + percentage + '%';
				}
			}
		}
	},

	/**
	 * Adds one to the number of textures currently loading.
	 */
	textureLoadStart: function (url, textureObj) {
		this._texturesLoading++;
		this._texturesTotal++;
		
		this.updateProgress();
		
		this.emit('textureLoadStart', textureObj);
	},

	/**
	 * Subtracts one from the number of textures currently loading and if no more need
	 * to load, it will also call the _allTexturesLoaded() method.
	 */
	textureLoadEnd: function (url, textureObj) {
		var self = this;
		
		if (!textureObj._destroyed) {
			// Add the texture to the _textureStore array
			this._textureStore.push(textureObj);
		}

		// Decrement the overall loading number
		this._texturesLoading--;
		
		this.updateProgress();
		
		this.emit('textureLoadEnd', textureObj);

		// If we've finished...
		if (this._texturesLoading === 0) {
			// All textures have finished loading
			this.updateProgress();
			
			setTimeout(function () {
				self._allTexturesLoaded();
			}, 100);
		}
	},

	/**
	 * Returns a texture from the texture store by it's url.
	 * @param {String} url
	 * @return {IgeTexture}
	 */
	textureFromUrl: function (url) {
		var arr = this._textureStore,
			arrCount = arr.length,
			item;

		while (arrCount--) {
			item = arr[arrCount];
			if (item._url === url) {
				return item;
			}
		}
	},

	/**
	 * Checks if all textures have finished loading and returns true if so.
	 * @return {Boolean}
	 */
	texturesLoaded: function () {
		return ige._texturesLoading === 0;
	},

	/**
	 * Emits the "texturesLoaded" event.
	 * @private
	 */
	_allTexturesLoaded: function () {
		if (!this._loggedATL) {
			this._loggedATL = true;
			this.log('All textures have loaded');
		}

		// Fire off an event about this
		this.emit('texturesLoaded');
	},

	/**
	 * Generates a timestamp-based UUID according to: 
	 * https://github.com/broofa/node-uuid#uuidv1options--buffer--offset
	 * @return {String}
	 */
	newIdHex: function () {
		return this._uuid.v1();
	},

	/**
	 * Generates a new 16-character hexadecimal ID based on
	 * the passed string. Will always generate the same ID
	 * for the same string.
	 * @param {String} str A string to generate the ID from.
	 * @return {String}
	 */
	newIdFromString: function (str) {
		if (str !== undefined) {
			var id,
				val = 0,
				count = str.length,
				i;

			for (i = 0; i < count; i++) {
				val += str.charCodeAt(i) * Math.pow(10, 17);
			}

			id = (val).toString(16);

			// Check if the ID is already in use
			while (ige.$(id)) {
				val += Math.pow(10, 17);
				id = (val).toString(16);
			}

			return id;
		}
	},

	/**
	 * Starts the engine.
	 * @param callback
	 */
	start: function (callback) {
		if (!ige._state) {
			// Check if we are able to start based upon any registered dependencies
			if (ige.dependencyCheck()) {
				// Start the engine
				ige.log('Starting engine...');
				ige._state = 1;

				requestAnimFrame(ige.engineStep);

				ige.log('Engine started');

				// Fire the callback method if there was one
				if (typeof(callback) === 'function') {
					callback(true);
				}
			} else {
				// Get the current timestamp
				var curTime = new Date().getTime();

				// Record when we first started checking for dependencies
				if (!ige._dependencyCheckStart) {
					ige._dependencyCheckStart = curTime;
				}

				// Check if we have timed out
				if (curTime - ige._dependencyCheckStart > this._dependencyCheckTimeout) {
					this.log('Engine start failed because the dependency check timed out after ' + (this._dependencyCheckTimeout / 1000) + ' seconds', 'error');
					if (typeof(callback) === 'function') {
						callback(false);
					}
				} else {
					// Start a timer to keep checking dependencies
					setTimeout(function () { ige.start(callback); }, 200);
				}
			}
		}
	},

	// Remove the loading screen on the client. Should be called when the game is
	// ready to be seen by players.
	removeLoadingScreen: function () {
		if (document.getElementsByClassName && document.getElementsByClassName('igeLoading')) {
			var arr = document.getElementsByClassName('igeLoading'),
				arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount].parentNode.removeChild(arr[arrCount]);
			}
		}
	},

	/**
	 * Stops the engine.
	 * @return {Boolean}
	 */
	stop: function () {
		// If we are running, stop the engine
		if (this._state) {
			this.log('Stopping engine...');
			this._state = 0;

			return true;
		} else {
			return false;
		}
	},

	/**
	 * Gets / sets the _autoSize property. If set to true, the engine will listen
	 * for any change in screen size and resize the front-buffer (canvas) element
	 * to match the new screen size.
	 * @param val
	 * @return {Boolean}
	 */
	autoSize: function (val) {
		if (val !== undefined) {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	pixelRatioScaling: function (val) {
		if (val !== undefined) {
			this._pixelRatioScaling = val;
			return this;
		}

		return this._pixelRatioScaling;
	},

	/**
	 * Clears the entire canvas.
	 */
	clearCanvas: function () {
		if (this._ctx) {
			// Clear the whole canvas
			this._ctx.clearRect(
				0,
				0,
				this._canvas.width,
				this._canvas.height
			);
		}
	},

	/**
	 * Removes the engine's canvas from the DOM.
	 */
	removeCanvas: function () {
		// Stop listening for input events
		if (this.input) {
			this.input.destroyListeners();
		}

		// Remove event listener
		window.removeEventListener('resize', this._resizeEvent);

		if (this._createdFrontBuffer) {
			// Remove the canvas from the DOM
			document.body.removeChild(this._canvas);
		}

		// Clear internal references
		delete this._canvas;
		delete this._ctx;
		this._ctx = IgeDummyContext;
		this._headless = true;
	},

	/**
	 * Opens a new window to the specified url. When running in a
	 * native wrapper, will load the url in place of any existing
	 * page being displayed in the native web view.
	 * @param url
	 */
	openUrl: function (url) {
		if (url !== undefined) {

			if (ige.cocoonJs && ige.cocoonJs.detected) {
				// Open URL via CocoonJS webview
				ige.cocoonJs.openUrl(url);
			} else {
				// Open via standard JS open window
				window.open(url);
			}
		}
	},

	/**
	 * Loads the specified URL as an HTML overlay on top of the
	 * front buffer in an iFrame. If running in a native wrapper,
	 * will load the url in place of any existing page being
	 * displayed in the native web view.
	 *
	 * When the overlay is in use, no mouse or touch events will
	 * be fired on the front buffer. Once you are finished with the
	 * overlay, call hideOverlay() to re-enable interaction with
	 * the front buffer.
	 * @param {String=} url
	 */
	showWebView: function (url) {
		if (ige.cocoonJs && ige.cocoonJs.detected) {
			// Open URL via CocoonJS webview
			ige.cocoonJs.showWebView(url);
		} else {
			// Load the iFrame url
			var overlay = document.getElementById('igeOverlay');

			if (!overlay) {
				// No overlay was found, create one
				overlay = document.createElement('iframe');

				// Setup overlay styles
				overlay.id = 'igeOverlay';
				overlay.style.position = 'absolute';
				overlay.style.border = 'none';
				overlay.style.left = '0px';
				overlay.style.top = '0px';
				overlay.style.width = '100%';
				overlay.style.height = '100%';

				// Append overlay to body
				document.body.appendChild(overlay);
			}

			// If we have a url, set it now
			if (url !== undefined) {
				overlay.src = url;
			}

			// Show the overlay
			overlay.style.display = 'block';
		}

		return this;
	},

	/**
	 * Hides the web view overlay.
	 * @return {*}
	 */
	hideWebView: function () {
		if (ige.cocoonJs && ige.cocoonJs.detected) {
			// Hide the cocoonJS webview
			ige.cocoonJs.hideWebView();
		} else {
			var overlay = document.getElementById('igeOverlay');
			if (overlay) {
				overlay.style.display = 'none';
			}
		}

		return this;
	},

	/**
	 * Evaluates javascript sent from another frame.
	 * @param js
	 */
	layerCall: function (js) {
		if (js !== undefined) {
			eval(js);
		}
	},

	/**
	 * Returns the mouse position relative to the main front buffer. Mouse
	 * position is set by the ige.input component (IgeInputComponent)
	 * @return {IgePoint3d}
	 */
	mousePos: function () {
		return this._mousePos.clone();
	},

	/**
	 * Walks the scenegraph and returns an array of all entities that the mouse
	 * is currently over, ordered by their draw order from drawn last (above other
	 * entities) to first (underneath other entities).
	 */
	mouseOverList: function (obj, entArr) {
		var arr,
			arrCount,
			mp,
			mouseTriggerPoly,
			first = false;
		
		if (!obj) {
			obj = ige;
			entArr = [];
			first = true;
		}
		
		if (obj === ige) {
			// Loop viewports
			arr = obj._children;
	
			if (arr) {
				arrCount = arr.length;
	
				// Loop our children
				while (arrCount--) {
					if (arr[arrCount]._scene) {
						if (arr[arrCount]._scene._shouldRender) {
							this.mouseOverList(arr[arrCount]._scene, entArr);
						}
					}
				}
			}
		} else {
			// Check if the mouse is over this entity
			mp = this.mousePosWorld();

			if (mp && obj.aabb) {
				// Trigger mode is against the AABB
				mouseTriggerPoly = obj.aabb(); //this.localAabb();
				
				// Check if the current mouse position is inside this aabb
				if (mouseTriggerPoly.xyInside(mp.x, mp.y)) {
					entArr.push(obj);
				}
			}
			
			// Check if the entity has children
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					this.mouseOverList(arr[arrCount], entArr);
				}
			}
		}
		
		if (first) {
			entArr.reverse();
		}
		
		return entArr;
	},

	/**
	 * Handles the screen resize event.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		// TODO: Make this the entry point for any window resize event. The engine will catch those events and then
		// tell the relevant subsystems that they should resize.
		if (ige.isClient) {
			this.rendering._resizeEvent(event);
		}

		if (ige._showSgTree) {
			var sgTreeElem = document.getElementById('igeSgTree');

			canvasBoundingRect = this.rendering._canvasPosition();

			sgTreeElem.style.top = (parseInt(canvasBoundingRect.top) + 5) + 'px';
			sgTreeElem.style.left = (parseInt(canvasBoundingRect.left) + 5) + 'px';
			sgTreeElem.style.height = (ige._bounds2d.y - 30) + 'px';
		}

		ige._resized = true;
	},

	/**
	 * Toggles full-screen output of the main ige canvas. Only works
	 * if called from within a user-generated HTML event listener.
	 */
	toggleFullScreen: function () {
		var elem = this._canvas;
		
		if (elem.requestFullscreen) {
			elem.requestFullscreen();
		} else if (elem.mozRequestFullScreen) {
			elem.mozRequestFullScreen();
		} else if (elem.webkitRequestFullscreen) {
			elem.webkitRequestFullscreen();
		}
	},

	/**
	 * Adds a new watch expression to the watch list which will be
	 * displayed in the stats overlay during a call to _statsTick().
	 * @param {*} evalStringOrObject The expression to evaluate and
	 * display the result of in the stats overlay, or an object that
	 * contains a "value" property.
	 * @returns {Integer} The index of the new watch expression you
	 * just added to the watch array.
	 */
	watchStart: function (evalStringOrObject) {
		this._watch = this._watch || [];
		this._watch.push(evalStringOrObject);

		return this._watch.length - 1;
	},

	/**
	 * Removes a watch expression by it's array index.
	 * @param {Number} index The index of the watch expression to
	 * remove from the watch array.
	 */
	watchStop: function (index) {
		this._watch = this._watch || [];
		this._watch.splice(index, 1);
	},

	/**
	 * Sets a trace up on the setter of the passed object's
	 * specified property. When the property is set by any
	 * code the debugger line is activated and code execution
	 * will be paused allowing you to step through code or
	 * examine the call stack to see where the property set
	 * originated.
	 * @param {Object} obj The object whose property you want
	 * to trace.
	 * @param {String} propName The name of the property you
	 * want to put the trace on.
	 * @param {Number} sampleCount The number of times you
	 * want the trace to break with the debugger line before
	 * automatically switching off the trace.
	 * @param {Function=} callbackEvaluator Optional callback
	 * that if returns true, will fire debugger. Method is passed
	 * the setter value as first argument.
	 */
	traceSet: function (obj, propName, sampleCount, callbackEvaluator) {
		obj.___igeTraceCurrentVal = obj.___igeTraceCurrentVal || {};
		obj.___igeTraceCurrentVal[propName] = obj[propName];
		obj.___igeTraceMax = sampleCount || 1;
		obj.___igeTraceCount = 0;

		Object.defineProperty(obj, propName, {
			get: function () {
				return obj.___igeTraceCurrentVal[propName];
			},
			set: function (val) {
				if (callbackEvaluator){ 
					if (callbackEvaluator(val)) {
						debugger;
					}
				} else {
					debugger;
				}
				
				obj.___igeTraceCurrentVal[propName] = val;
				obj.___igeTraceCount++;

				if (obj.___igeTraceCount === obj.___igeTraceMax) {
					// Maximum amount of trace samples reached, turn off
					// the trace system
					ige.traceSetOff(obj, propName);
				}
			}
		});
	},

	/**
	 * Turns off a trace that was created by calling traceSet.
	 * @param {Object} object The object whose property you want
	 * to disable a trace against.
	 * @param {String} propName The name of the property you
	 * want to disable the trace for.
	 */
	traceSetOff: function (object, propName) {
		Object.defineProperty(object, propName, {set: function (val) { this.___igeTraceCurrentVal[propName] = val; }});
	},

	/**
	 * Finds the first Ige* based class that the passed object
	 * has been derived from.
	 * @param obj
	 * @return {*}
	 */
	findBaseClass: function (obj) {
		if (obj && obj._classId) {
			if (obj._classId.substr(0, 3) === 'Ige') {
				return obj._classId;
			} else {
				if (obj.__proto__._classId) { 
					return this.findBaseClass(obj.__proto__);
				} else {
					return '';
				}
			}
		} else {
			return '';
		}
	},

	/**
	 * Returns an array of all classes the passed object derives from
	 * in order from current to base.
	 * @param obj
	 * @param arr
	 * @return {*}
	 */
	getClassDerivedList: function (obj, arr) {
		if (!arr) {
			arr = [];
		} else {
			if (obj._classId) {
				arr.push(obj._classId);
			}
		}
		
		if (obj.__proto__._classId) {
			this.getClassDerivedList(obj.__proto__, arr);
		}
		
		return arr;
	},
	
	spawnQueue: function (ent) {
		if (ent !== undefined) {
			this._spawnQueue.push(ent);
			return this;
		}
		
		return this._spawnQueue;
	},

	/**
	 * Is called every second and does things like calculate the current FPS.
	 * @private
	 */
	_secondTick: function () {
		var self = ige;

		// Store frames per second
		self._fps = self._frames;

		// Store draws per second
		self._dps = self._dpf * self._fps;

		// Zero out counters
		self._frames = 0;
		self._drawCount = 0;
	},
	
	/**
	 * Gets / sets the current time scalar value. The engine's internal
	 * time is multiplied by this value and it's default is 1. You can set it to
	 * 0.5 to slow down time by half or 1.5 to speed up time by half. Negative
	 * values will reverse time but not all engine systems handle this well
	 * at the moment.
	 * @param {Number=} val The time scale value.
	 * @returns {*}
	 */
	timeScale: function (val) {
		if (val !== undefined) {
			this._timeScale = val;
			return this;
		}

		return this._timeScale;
	},

	/**
	 * Increments the engine's interal time by the passed number of milliseconds.
	 * @param {Number} val The number of milliseconds to increment time by.
	 * @param {Number=} lastVal The last internal time value, used to calculate
	 * delta internally in the method.
	 * @returns {Number}
	 */
	incrementTime: function (val, lastVal) {
		if (!this._pause) {
			if (!lastVal) { lastVal = val; }
			this._currentTime += ((val - lastVal) * this._timeScale);
		}
		return this._currentTime;
	},

	/**
	 * Get the current time from the engine.
	 * @return {Number} The current time.
	 */
	currentTime: function () {
		return this._currentTime;
	},

	/**
	 * Gets / sets the pause flag. If set to true then the engine's
	 * internal time will no longer increment and will instead stay static.
	 * @param val
	 * @returns {*}
	 */
	pause: function (val) {
		if (val !== undefined) {
			this._pause = val;
			return this;
		}
		
		return this._pause;
	},

	/**
	 * Gets / sets the option to determine if the engine should
	 * schedule it's own ticks or if you want to manually advance
	 * the engine by calling tick when you wish to.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	useManualTicks: function (val) {
		if (val !== undefined) {
			this._useManualTicks = val;
			return this;
		}

		return this._useManualTicks;
	},

	/**
	 * Schedules a manual tick.
	 */
	manualTick: function () {
		if (this._manualFrameAlternator !== this._frameAlternator) {
			this._manualFrameAlternator = this._frameAlternator;
			requestAnimFrame(this.engineStep);
		}
	},

	/**
	 * Gets / sets the option to determine if the engine should
	 * render on every tick or wait for a manualRender() call.
	 * @param {Boolean=} val True to enable manual rendering, false
	 * to disable.
	 * @return {*}
	 */
	useManualRender: function (val) {
		if (val !== undefined) {
			this._useManualRender = val;
			return this;
		}

		return this._useManualRender;
	},

	/**
	 * Manually render a frame on demand. This is used in conjunction
	 * with the ige.useManualRender(true) call which will cause the
	 * engine to only render new graphics frames from the scenegraph
	 * once this method is called. You must call this method every time
	 * you wish to update the graphical output on screen.
	 * 
	 * Calling this method multiple times during a single engine tick
	 * will NOT make it draw more than one frame, therefore it is safe
	 * to call multiple times if required by different sections of game
	 * logic without incurring extra rendering cost.
	 */
	manualRender: function () {
		this._manualRender = true;
	},

	/**
	 * Called each frame to traverse and render the scenegraph.
	 */
	engineStep: function (timeStamp, ctx) {
		/* TODO:
			Make the scenegraph process simplified. Walk the scenegraph once and grab the order in a flat array
			then process updates and ticks. This will also allow a layered rendering system that can render the
			first x number of entities then stop, allowing a step through of the renderer in realtime.
		 */
		var	self = ige,
			ptArr = self._postTick,
			ptCount = ptArr.length,
			ptIndex,
			unbornQueue,
			unbornCount,
			unbornIndex,
			unbornEntity;

		// Scale the timestamp according to the current
		// engine's time scaling factor
		self.incrementTime(timeStamp, self._timeScaleLastTimestamp);

		self._timeScaleLastTimestamp = timeStamp;
		timeStamp = Math.floor(self._currentTime);

		if (self._state) {

			// Check if we were passed a context to work with
			if (ctx === undefined) {
				ctx = self._ctx;
			}

			// Alternate the boolean frame alternator flag
			self._frameAlternator = !self._frameAlternator;

			// If the engine is not in manual tick mode...
			if (!ige._useManualTicks) {
				// Schedule a new frame
				requestAnimFrame(self.engineStep);
			} else {
				self._manualFrameAlternator = !self._frameAlternator;
			}

			// Get the current time in milliseconds
			self._tickStart = timeStamp;

			// Adjust the tickStart value by the difference between
			// the server and the client clocks (this is only applied
			// when running as the client - the server always has a
			// clientNetDiff of zero)
			self._tickStart -= self._clientNetDiff;

			if (!self.lastTick) {
				// This is the first time we've run so set some
				// default values and set the delta to zero
				self.lastTick = 0;
				self._tickDelta = 0;
			} else {
				// Calculate the frame delta
				self._tickDelta = self._tickStart - self.lastTick;
			}
			
			// Check for unborn entities that should be born now
			unbornQueue = ige._spawnQueue;
			unbornCount = unbornQueue.length;
			for (unbornIndex = unbornCount - 1; unbornIndex >= 0; unbornIndex--) {
				unbornEntity = unbornQueue[unbornIndex];
				
				if (ige._currentTime >= unbornEntity._bornTime) {
					// Now birth this entity
					unbornEntity.mount(ige.$(unbornEntity._birthMount));
					unbornQueue.splice(unbornIndex, 1);
				}
			}

			// Update the scenegraph
			if (self._enableUpdates) {
				self.updateEntityGraph(ctx);
			}

			// Render the scenegraph
			if (self._enableRenders) {
				if (!self._useManualRender) {
					self.renderEntityGraph(ctx);
				} else {
					if (self._manualRender) {
						self.renderEntityGraph(ctx);
						self._manualRender = false;
					}
				}
			}

			// Call post-tick methods
			for (ptIndex = 0; ptIndex < ptCount; ptIndex++) {
				ptArr[ptIndex]();
			}

			// Record the lastTick value so we can
			// calculate delta on the next tick
			self.lastTick = self._tickStart;
			self._frames++;
			self._dpf = self._drawCount;
			self._drawCount = 0;

			// Call the input system tick to reset any flags etc
			self.input.tick();
		}

		self._resized = false;
	},
	
	updateEntityGraph: function (ctx) {
		var arr = this._children,
			arrCount,
			tickDelta = ige._tickDelta;

		// Process any behaviours assigned to the engine
		this._processUpdateBehaviours(ctx, tickDelta);

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount].update(ctx, tickDelta);
			}
		}
	},

	renderEntityGraph: function (ctx) {
		// Process any behaviours assigned to the engine
		this._processTickBehaviours(ctx);

		// Depth-sort the viewports
		if (this._viewportDepth) {
			this.depthSortChildren();
		}

		ctx.save();
		ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
		//ctx.scale(this._globalScale.x, this._globalScale.y);

		// Process the current engine tick for all child objects
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;
			while (arrCount--) {
				ctx.save();
				arr[arrCount].tick(ctx);
				ctx.restore();
			}
		}

		ctx.restore();
	},

	traverseEntityGraph: function(preRecursion, postRecursion) {
		this.traverseChildren(this._children, preRecursion, postRecursion);
		//console.log('Finished traversing entity graph.');
	},

	traverseChildren: function(children, preRecursion, postRecursion) {
		if (!children  || children.length === 0) {
			return;
		}
		for (var i = children.length - 1; i >= 0; i--) {
			var child = children[i];
			// Don't render children that were born this update because they are not ready yet
			if (child._newBorn) {
				continue;
			}
			var continueRecursing = preRecursion(child);
			var nextChildren = child._children;
			if (child instanceof IgeViewport) {
				nextChildren = [child._scene];
			}

			if (!child._alive) {
				continue;
			}

			if (continueRecursing) {
				this.traverseChildren(nextChildren, preRecursion, postRecursion);
			}
			postRecursion(child);
		}
	},

	fps: function () {
		return this._fps;
	},

	dpf: function () {
		return this._dpf;
	},

	dps: function () {
		return this._dps;
	},

	analyseTiming: function () {
		if (igeConfig.debug._timing) {

		} else {
			this.log('Cannot analyse timing because the igeConfig.debug._timing flag is not enabled so no timing data has been recorded!', 'warning');
		}
	},

	saveSceneGraph: function (item) {
		var arr, arrCount, i;

		if (!item) {
			item = this.getSceneGraphData();
		}

		if (item.obj.stringify) {
			item.str = item.obj.stringify();
		} else {
			console.log('Class ' + item.classId + ' has no stringify() method! For object: ' + item.id, item.obj);
		}
		arr = item.items;

		if (arr) {
			arrCount = arr.length;

			for (i = 0; i < arrCount; i++) {
				this.saveSceneGraph(arr[i]);
			}
		}

		return item;
	},

	/**
	 * Walks the scene graph and outputs a console map of the graph.
	 */
	sceneGraph: function (obj, currentDepth, lastDepth) {
		var depthSpace = '',
			di,
			timingString,
			arr,
			arrCount;

		if (currentDepth === undefined) { currentDepth = 0; }

		if (!obj) {
			// Set the obj to the main ige instance
			obj = ige;
		}

		for (di = 0; di < currentDepth; di++) {
			depthSpace += '----';
		}

		if (igeConfig.debug._timing) {
			timingString = '';

			timingString += 'T: ' + ige._timeSpentInTick[obj.id()];
			if (ige._timeSpentLastTick[obj.id()]) {
				if (typeof(ige._timeSpentLastTick[obj.id()].ms) === 'number') {
					timingString += ' | LastTick: ' + ige._timeSpentLastTick[obj.id()].ms;
				}

				if (typeof(ige._timeSpentLastTick[obj.id()].depthSortChildren) === 'number') {
					timingString += ' | ChildDepthSort: ' + ige._timeSpentLastTick[obj.id()].depthSortChildren;
				}
			}

			console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView + ' Timing(' + timingString + ')');
		} else {
			console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView);
		}

		currentDepth++;

		if (obj === ige) {
			// Loop the viewports
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					if (arr[arrCount]._scene) {
						if (arr[arrCount]._scene._shouldRender) {
							if (igeConfig.debug._timing) {
								timingString = '';
	
								timingString += 'T: ' + ige._timeSpentInTick[arr[arrCount].id()];
								if (ige._timeSpentLastTick[arr[arrCount].id()]) {
									if (typeof(ige._timeSpentLastTick[arr[arrCount].id()].ms) === 'number') {
										timingString += ' | LastTick: ' + ige._timeSpentLastTick[arr[arrCount].id()].ms;
									}
	
									if (typeof(ige._timeSpentLastTick[arr[arrCount].id()].depthSortChildren) === 'number') {
										timingString += ' | ChildDepthSort: ' + ige._timeSpentLastTick[arr[arrCount].id()].depthSortChildren;
									}
								}
	
								console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView + ' Timing(' + timingString + ')');
							} else {
								console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView);
							}
							this.sceneGraph(arr[arrCount]._scene, currentDepth + 1);
						}
					}
				}
			}
		} else {
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					this.sceneGraph(arr[arrCount], currentDepth);
				}
			}
		}
	},

	/**
	 * Walks the scenegraph and returns a data object of the graph.
	 */
	getSceneGraphData: function (obj, noRef) {
		var item, items = [], tempItem, tempItem2, tempCam,
			arr, arrCount;

		if (!obj) {
			// Set the obj to the main ige instance
			obj = ige;
		}

		item = {
			text: '[' + obj._classId + '] ' + obj.id(),
			id: obj.id(),
			classId: obj.classId()
		};

		if (!noRef) {
			item.parent = obj._parent;
			item.obj = obj;
		} else {
			if (obj._parent) {
				item.parentId = obj._parent.id();
			} else {
				item.parentId = 'sceneGraph';
			}
		}

		if (obj === ige) {
			// Loop the viewports
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					tempItem = {
						text: '[' + arr[arrCount]._classId + '] ' + arr[arrCount].id(),
						id: arr[arrCount].id(),
						classId: arr[arrCount].classId()
					};

					if (!noRef) {
						tempItem.parent = arr[arrCount]._parent;
						tempItem.obj = arr[arrCount];
					} else {
						if (arr[arrCount]._parent) {
							tempItem.parentId = arr[arrCount]._parent.id();
						}
					}
					
					if (arr[arrCount].camera) {
						// Add the viewport camera as an object on the scenegraph
						tempCam = {
							text: '[IgeCamera] ' + arr[arrCount].id(),
							id: arr[arrCount].camera.id(),
							classId: arr[arrCount].camera.classId()
						};
						
						if (!noRef) {
							tempCam.parent = arr[arrCount];
							tempCam.obj = arr[arrCount].camera;
						} else {
							tempCam.parentId = arr[arrCount].id();
						}
	
						if (arr[arrCount]._scene) {
							tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
							tempItem.items = [tempCam, tempItem2];
						}
					} else {
						if (arr[arrCount]._scene) {
							tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
							tempItem.items = [tempItem2];
						}
					}
					
					items.push(tempItem);
				}
			}
		} else {
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					tempItem = this.getSceneGraphData(arr[arrCount], noRef);
					items.push(tempItem);
				}
			}
		}

		if (items.length > 0) {
			item.items = items;
		}

		return item;
	},
	
	_childMounted: function (child) {
		if (child.IgeViewport) {
			// The first mounted viewport gets set as the current
			// one before any rendering is done
			if (!ige._currentViewport) {
				ige._currentViewport = child;
				ige._currentCamera = child.camera;
			}
		}
		
		IgeEntity.prototype._childMounted.call(this, child);
	},

	destroy: function () {
		// Stop the engine and kill any timers
		this.stop();

		// Remove the front buffer (canvas) if we created it
		if (this.isClient) {
			this.removeCanvas();
		}

		// Call class destroy() super method
		IgeEntity.prototype.destroy.call(this);

		this.log('Engine destroy complete.');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEngine; }
;;/**
 * Cosmos game constants should be stored in this central location
 */
var Constants = {
	/*
	 * This is the ratio between thrusts as they actually are in the code and
	 * thrusts as they are presented to the user.
	 */
	THRUST_DISPLAY_RATIO: 10000,

	fps: {
		CLIENT_FPS: 30,
		SERVER_FPS: 20
	},

	visibleArea: {
		MAXIMUM_WIDTH: 1920,
		MAXIMUM_HEIGHT: 1200
	},

	minimapArea: {
		MAXIMUM_WIDTH: 1920 * 2,
		MAXIMUM_HEIGHT: 1200 * 2
	},

	//constant properties of the background tiles
	GRID_SQUARE_SIZE: {
		X: 1024,
		Y: 1024
	},

	NUM_BACKGROUND_SQUARES: {
		X: 7,
		Y: 7
	},

	//this is a constant offset that we apply to the whole background
	BACKGROUND_OFFSET: {
		X: -3000,
		Y: -3000
	},

	NUM_BACKGROUND_OVERLAY_SQUARES: {
		X: 8,
		Y: 8
	},

	GRID_SQUARE_OVERLAP: 1, // I think we only need a tiny overlap to get rid of the gaps in safari

	SECOND_OVERLAY_ROTATION: Math.PI / 4
};

Constants.UPDATE_TIME = {
	CLIENT: 1000 / Constants.fps.CLIENT_FPS,
	SERVER: 1000 / Constants.fps.SERVER_FPS
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Constants; }
;var Inspector = IgeEventingClass.extend({
	classId: 'Inspector',
	componentId: 'inspector',

	element: undefined,
	button: undefined,

	block: undefined,
	blockInspector: undefined,
	blockInspectorName: undefined,
	blockInspectorType: undefined,
	blockInspectorTextureImg: undefined,
	blockInspectorTextureCanvas: undefined,
	blockInspectorCurrentHealth: undefined,
	blockInspectorMaxHealth: undefined,
	blockInspectorEnergyUsage: undefined,
	blockInspectorDamage: undefined,
	blockInspectorThrust: undefined,
	blockInspectorDescription: undefined,

	init: function() {
		var self = this;
		var hud = $('#hud');
		if (hud.length === 0) {
			self.log('HUD has not been initialized.', 'error');
			return;
		}

		HUDComponent.loadHtml(Inspector.UI_ROOT + 'inspector.html', function(html) {
			hud.append(html);

			self.element = $('#inspector');
			self.button = self.element.find('.button').first();

			self.blockInspector = self.element.find('#block-inspector');
			self.blockInspectorName = self.blockInspector.find('#block-name');

			self.blockInspectorType = self.blockInspector.find('#block-type');

			self.blockInspectorTextureImg = self.blockInspector.find('img.block-texture');
			self.blockInspectorTextureCanvas = self.blockInspector.find('canvas.block-texture');
			// Sets the height and width of the canvas equal to its CSS height and width
			self.blockInspectorTextureCanvas[0].width = self.blockInspectorTextureCanvas.width();
			self.blockInspectorTextureCanvas[0].height = self.blockInspectorTextureCanvas.height();

			self.blockInspectorCurrentHealth = self.blockInspector.find('#block-current-health');
			self.blockInspectorMaxHealth = self.blockInspector.find('#block-max-health');
			self.blockInspectorEnergyUsage = self.blockInspector.find('#block-energy-usage');
			self.blockInspectorDamage = self.blockInspector.find('#block-damage');
			self.blockInspectorThrust = self.blockInspector.find('#block-thrust');
			self.blockInspectorDescription = self.blockInspector.find('.description').first();

			ige.on('cosmos:block.mousedown', function(block) {
				self.inspect(block);
			});

			/*ige.on('cosmos:background.mousedown', function() {
				self.hide();
			});*/

			ige.emit('cosmos:hud.subcomponent.loaded', self);
		});
	},

	inspect: function(block) {
		var self = this;
		if (this.block && this.healthChangeListener) {
			this.block.off('cosmos:block.hp.changed', this.healthChangeListener);
		}
		this.block = block;
		this.blockInspectorName.text(block.displayName());
		this.blockInspectorType.text(block.type.text);
		this.blockInspectorDescription.text(block.description.text);

		this.blockInspector.find('.block-stat').hide();
		if (block.health instanceof Health) {
			this.blockInspector.find('#block-stat-health').show();
			this.blockInspectorCurrentHealth.text(block.health.value);
			this.blockInspectorMaxHealth.text(block.health.max);

			this.healthChangeListener = block.on('cosmos:block.hp.changed', function(hp) {
				// TODO: Change the color of the health text based on the percentage of health that is left
				self.blockInspectorCurrentHealth.text(Math.round(hp));
				if (hp <= 0) {
					self.blockInspector.hide();
				}
			});
		}

		if (block.damageSource instanceof DamageSource) {
			this.blockInspector.find('#block-stat-damage').show();
			this.blockInspectorDamage.text(block.damageSource.dps);
		}

		if (block.thrust instanceof Thrust) {
			this.blockInspector.find('#block-stat-thrust').show();

			/*
			 * Note that Constants.THRUST_DISPLAY_RATIO is the ratio between thrusts
			 * as they actually are in the code and
			 * thrusts as they are presented to the user.
			 */
			this.blockInspectorThrust.text(Constants.THRUST_DISPLAY_RATIO * block.thrust.value);
		}

		if (block instanceof Part) {
			this.blockInspectorTextureImg.show();
			this.blockInspectorTextureCanvas.hide();
			var img = this.blockInspectorTextureImg[0];
			img.src = "/assets/sprites/" + block.iconFrame;
		}
		else {
			this.blockInspectorTextureCanvas.show();
			this.blockInspectorTextureImg.hide();
			var canvas = this.blockInspectorTextureCanvas[0];

			// Clears the canvas
			canvas.width = canvas.width;
			var ctx = canvas.getContext("2d");
			var scaleWidth = canvas.width / block._bounds2d.x;
			var scaleHeight = canvas.height / block._bounds2d.y;
			ctx.scale(scaleWidth, scaleHeight);
			ctx.translate(block._bounds2d.x2, block._bounds2d.y2);
			block.texture().render(ctx, block);
		}

		this.blockInspector.show();
	},

	hide: function() {
		this.blockInspector.hide();
	},

	loadHtml: function (url, callback) {
		$.ajax({
			url: url,
			success: callback,
			dataType: 'html'
		});
	}
});

Inspector.UI_ROOT = '/components/inspector/';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Inspector; }
;/**
 * An {@link IgeEntity} that serves as a caching layer for the rendering of the {@link Block}s that are part of a
 * larger construct like a {@link BlockGrid} or a {@link ConstructionZoneOverlay}.
 * @class
 * @typedef {RenderContainer}
 * @namespace
 */
var RenderContainer = IgeEntity.extend({
	classId: 'RenderContainer',

	init: function () {
		IgeEntity.prototype.init.call(this);
		//this.updateChildren(true);

		this.addComponent(PixiRenderableComponent);

		this.compositeCache(true);
	},

	/**
	 * Invalidates the cache and updates all children. This function must be called anytime a change is made to one of
	 * the {@link Block}s in a {@link BlockGrid} or the rendering will not update to reflect the change.
	 * @memberof RenderContainer
	 * @instance
	 */
	refresh: function () {
		//this.updateChildrenNeeded(true);
		this.cacheDirty(true);
	}

});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = RenderContainer; }
;/**
 * An {@link IgeEntity} which helps to display the construction hints to users when they click on the construct button.
 * @class
 * @typedef {ConstructionOverlay}
 * @namespace
 */
var ConstructionOverlay = IgeEntity.extend({
	classId: 'ConstructionOverlay',

	/**
	 * A reference to the {@link BlockStructure} object that this {@link ConstructionOverlay} is displaying an overlay
	 * for.
	 * @type {BlockStructure}
	 * @memberof ConstructionOverlay
	 * @private
	 * @instance
	 */
	_structure: undefined,

	init: function(structure) {
		IgeEntity.prototype.init.call(this);
		this._structure = structure;

		this.addComponent(ConstructionOverlayRenderableComponent);

		this.mouseDown(this._mouseDownHandler);

		var self = this;
		ige.on('capbar cap selected', function(classId) {
			if (classId === 'ConstructCap') {
				if (self._structure === ige.client.player.currentShip() || !(self._structure instanceof Ship)) {
					self.refresh();
					self.show();
				}
			} else {
				self.hide();
			}
		});

		ige.on('capbar cap cleared', function(classId) {
			if (classId === 'ConstructCap') {
				self.hide();
			}
		});

		// If construct capability enabled, show the construction zones
		if (ige.client.state.selectedCap() === 'construct') {
			this.refresh();
			this.show();
		}
		else {
			this.hide();
		}
	},

	gridHeight: function() {
		return this._structure.gridHeight() + 2 * this._blockHeight;
	},

	gridWidth: function() {
		return this._structure.gridWidth() + 2 * this._blockWidth;
	},

	lowerBound: function() {
		var structureLowerBound = this._structure.lowerBound();
		return {
			x: structureLowerBound.x - this._blockWidth,
			y: structureLowerBound.y - this._blockHeight
		};
	},

	overlayForBlock: function(block) {
		var blockWidth = 1;
		var blockHeight = 1;

		if (block) {
			blockWidth = block.gridData.width;
			blockHeight = block.gridData.height;
		}

		this._blockWidth = blockWidth;
		this._blockHeight = blockHeight;

		this._computeConstructionLocations(blockWidth, blockHeight);
		this.renderable.renderConstructionLocations();
	},

	refresh: function() {
		// Don't even bother refreshing if we're not even displaying the construction zones.
		if (ige.client.state.selectedCap() !== 'construct') {
			return;
		}

		// TODO: This doesn't work consistently because cargo is written in a bit of a funny way.
		// Will need to play with this to get larger blocks working in construction mode.
		this.overlayForBlock(
			cosmos.blocks.instances[ige.hud.leftToolbar.windows.cargo.selectedType]
		);
	},

	upperBound: function() {
		var structureUpperBound = this._structure.upperBound();
		return {
			x: structureUpperBound.x + this._blockWidth,
			y: structureUpperBound.y + this._blockHeight
		}
	},

	/**
	 * Convolves a filter with the BlockStructure to produce a matrix of locations where
	 * construction zones should be placed.
	 * @param blockWidth
	 * @param blockHeight
	 * @private
	 */
	_computeConstructionLocations: function(blockWidth, blockHeight) {
		var filter = ConstructionOverlay.constructionFilter(blockWidth, blockHeight);

		var filterWidth = blockWidth + 2;
		var filterHeight = blockHeight + 2;
		var width = this._structure.gridWidth() + 2 * (blockWidth);
		var height = this._structure.gridHeight() + 2 * (blockHeight);
		var result = Array.prototype.new2DArray(width, height, 0);

		var lowerBound = this._structure.lowerBound();
		var resultLowerBound = {
			x: lowerBound.x - blockWidth,
			y: lowerBound.y - blockHeight
		};

		for (var x = 0; x < width; x++) {
			for (var y = 0; y < height; y++) {
				// The corners will never work, so don't bother checking them.
				if ((x === 0 && y === 0)
					|| (x === 0 && y === height - 1)
					|| (x === width - 1 && y === 0)
					|| (x === width - 1 && y === height - 1))
				{
					continue;
				}

				var sum = 0;
				for (var filterX = 0; filterX < filterWidth; filterX++) {
					for (var filterY = 0; filterY < filterHeight; filterY++) {
						var value = this._structure.has(
							new IgePoint2d(
									resultLowerBound.x + x + filterX - 1,
									resultLowerBound.y + y + filterY - 1
							)
						) ? 1 : 0;
						sum += filter[filterX][filterY] * value;
					}
				}

				if (sum > 0) {
					for (var blockX = 0; blockX < blockWidth; blockX++) {
						for (var blockY = 0; blockY < blockHeight; blockY++) {
							var indexX = x + blockX;
							var indexY = y + blockY;
							if (indexX < width && indexY < height) {
								result[indexX][indexY] = 1;
							}
						}
					}
				}
			}
		}

		this.width(width * Block.WIDTH);
		this.height(height * Block.HEIGHT);
		this._constructionLocations = result;
	},

	/**
	 * Handles clicks on this object.
	 * @param event {Object} The event object associated with the click.
	 * @param control {Object} The control object associated with the click.
	 * @memberof ConstructionOverlay
	 * @private
	 */
	_mouseDownHandler: function(event, control) {
		if (this.renderable._hidden) {
			return;
		}

		var clickLocation = this._structure.gridLocationForEvent(event, control);

		var location = {
			x: clickLocation.x - this.lowerBound().x,
			y: clickLocation.y - this.lowerBound().y
		};

		// Don't continue if the location is out of our acceptable bounds.
		if (location.x < 0 || location.y < 0
			|| location.x >= this.gridWidth() || location.y >= this.gridHeight())
		{
			return;
		}

		// A 1 in a construction location means it was a valid location.
		if (this._constructionLocations && this._constructionLocations[location.x][location.y]) {
			// Don't let this mouse click bubble down.
			control.stopPropagation();
		}
		else {
			return;
		}

		// Send constructionZoneClicked message to server
		var data = {
			blockGridId: this._parent.id(),
			// Translate overlay coordinates into BlockGrid coordinates
			row: location.y + this._structure.lowerBound().y - 1,
			col: location.x + this._structure.lowerBound().x - 1
		};

		if (ige.isClient && ige.client !== undefined && ige.client.state !== undefined) {
			ige.client.state.currentCapability().tryPerformAction(this, event, data);
		}
	}
});

/**
 * Generates a filter matrix that has values to be convolved with a matrix representing whether or
 * not blocks exist in a BlockStructure.
 * @param blockWidth
 * @param blockHeight
 * @returns {Array}
 */
ConstructionOverlay.constructionFilter = function(blockWidth, blockHeight) {
	var width = blockWidth + 2;
	var height = blockHeight + 2;
	var filter = Array.prototype.new2DArray(width, height);

	// Set the corners to 0.
	filter[0][0] = 0;
	filter[0][height - 1] = 0;
	filter[width - 1][0] = 0;
	filter[width - 1][height - 1] = 0;

	// Set the top and bottom sides to 1.
	for (var col = 1; col < width - 1; col++) {
		filter[col][0] = 1;
		filter[col][height - 1] = 1;
	}

	// Set the left and right sides to 1.
	for (var row = 1; row < height - 1; row++) {
		filter[0][row] = 1;
		filter[width - 1][row] = 1;
	}

	// The value we place at the locations that the block would occupy.
	var negationValue = -(blockWidth * 2 + blockHeight * 2 + 1);

	for (var col = 1; col < width - 1; col++) {
		for (var row = 1; row < height - 1; row++) {
			filter[col][row] = negationValue;
		}
	}

	return filter;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = ConstructionOverlay; }
;/**
 * This class is the superclass of all blocks, and it contains all of the basic logic for the blocks. The
 * Block class is abstract, so should not be instantiated. Subclasses of the Block extend functionality and
 * override abstract methods.
 *
 * @class
 * @typedef {Object} Block
 * @namespace
 */
var Block = IgeEntity.extend({
	classId: 'Block',

	// #ifdef SERVER
	/**
	 * Queue for block actions that need to be sent to the client.
	 */
	_actions: undefined,
	// #endif

	/**
	 * An object used as a map to store data about the various effects on a {@link Block}. The map keys are the effect
	 * types, and the values are typically objects. Each value can be specific to the effect, since different effects
	 * have different state needs.
	 * @type {Object}
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_effects: undefined,

	/**
	 * A flag that determines whether or not this {@link Block} is currently being mined or not. The default value is
	 * false, and when the value is false this {@link Block} is not currently being mined.
	 * @type {boolean}
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_isBeingMined: false,

	/**
	 * Construct a new block
	 * Note that subclasses of Block are expected to have their own textures.
	 * @param data {Object} an optional dictionary containing initialization information.
	 * @memberof Block
	 * @instance
	 */
	init: function(data) {
		var self = this;
		IgeEntity.prototype.init.call(this);

		data = data || {};

		var isAbstractClass = this.classId() === "Part"
			|| this.classId() === "Armor"
			|| this.classId() === "EngineBlock"
			|| this.classId() === "ThrusterBlock"
			|| this.classId() === "Weapon"
			|| this.classId() === "Laser"
			|| this.classId() === "Resource"
			// TODO: The Element class won't be abstract soon!
			|| this.classId() === "Element"
			|| this.classId() === "DeconstructionIndicator";//TODO this isn't really an abstract class...

		if (data.health) {
			this.addComponent(Health, data.health);
		}
		else if (!isAbstractClass) {
			this.log("No health found for " + this.classId() + ". Health component is mandatory" +
				" for all blocks.", "error");
		}

		if (data.type) {
			this.addComponent(Type, data.type);
		}
		else if (!isAbstractClass) {
			this.log("No type found for " + this.classId() + ". The type component is mandatory" +
				" for all blocks.", "error");
		}

		if (data.description) {
			this.addComponent(Description, data.description);
		}
		else if (!isAbstractClass) {
			this.log("No description found for " + this.classId() + ". The description component " +
				"is mandatory for all blocks.", "error");
		}

		if (data.recipe) {
			this.addComponent(Recipe, data.recipe);
		}

		/* === Grid Data === */
		// Default value for grid height and width is 1.
		var myGridData = {width: 1, height: 1};

		// If a height and width is passed for an element, that height and width will be used.
		if (this.classId() === "Element") {
			myGridData.width = data.gridWidth || myGridData.width;
			myGridData.height = data.gridHeight || myGridData.height;
		}

		// If a height and width is defined in the configuration files for this block, that will
		// be used.
		else if (GridDimensions[this.classId()]) {
			myGridData = GridDimensions[this.classId()];
		}

		this.addComponent(GridData, myGridData);

		// Use an even number so values don't have to become approximate when we divide by two
		this.width(Block.WIDTH * this.gridData.width).height(Block.HEIGHT * this.gridData.height);

		this.backgroundAlpha = this.backgroundAlpha || 1;
		if (!this.backgroundColor) {
			this.backgroundAlpha = 0;
		}

		this.borderAlpha = this.borderAlpha || 1;
		if (!this.borderColor) {
			this.borderAlpha = 0;
		}

		this.iconScale = this.iconScale || 1;

		this.addComponent(PixiRenderableComponent, {createDisplayObject: function() {
			var displayObject = new PIXI.DisplayObjectContainer();

			if (self.iconFrame) {
				var icon = PIXI.Sprite.fromFrame(self.iconFrame);

				icon.width = self.width() * self.iconScale;
				icon.height = self.height() * self.iconScale;

				icon.position.x = (self.width() - icon.width) / 2 - Block.WIDTH / 2;
				icon.position.y = (self.height() - icon.height) / 2 - Block.HEIGHT / 2;

				displayObject.addChild(icon);
			}
			else if (self.backgroundColor || self.borderColor) {
				var graphic = new PIXI.Graphics();
				graphic.beginFill(self.backgroundColor, self.backgroundAlpha);
				graphic.lineStyle(Block.BORDER_WIDTH, self.borderColor, self.borderAlpha);
				graphic.drawRect(
						Block.BORDER_WIDTH / 2,
						Block.BORDER_WIDTH / 2,
						self.width() - Block.BORDER_WIDTH,
						self.height() - Block.BORDER_WIDTH
				);
				graphic.endFill();

				graphic.position.x = -self.width() / 2;
				graphic.position.y = -self.height() / 2;

				displayObject.addChild(graphic);
			}

			return displayObject;
		}});

		if (ige.isServer) {
			this.addComponent(TLPhysicsFixtureComponent);
		}
		else {
			this.texture(ige.client.textures.block);

			this._effects = {};

			// Enable caching so that the smart textures aren't reevaluated every time.
			//this.compositeCache(true);
			//this.cacheSmoothing(true);
		}
	},

	/*
	 * When the mouse hovers over a block, add the deconstructionIndicator effect
	 * IF the block is part of the player's current ship
	 * AND the player is in construction mode.
	 * Note that this handler is called by ship.js and it's *not* actually plugged
	 * directly into IGE's input handler system
	 * The reason for this is that IGE's mouse over and mouse out are axis-aligned
	 */
	_mouseOverHandler: function (event, control) {
		if (
			// You can only deconstruct your own ship
			this.gridData.grid === ige.client.player.currentShip() &&
			// You can only deconstruct in Construct mode
			ige.client.state.currentCapability().classId() === ConstructCapability.prototype.classId())
		{
			this.addEffect({type: 'deconstructionIndicator'});
		}
	},

	/*
	 * When the mouse leaves a block, remove the deconstructionIndicator effect
	 * Note that this handler is called by ship.js and it's *not* actually plugged
	 * directly into IGE's input handler system
	 * The reason for this is that IGE's mouse over and mouse out are axis-aligned
	 */
	_mouseOutHandler: function (event, control) {
		if (this.gridData.grid === ige.client.player.currentShip()) {
			this.removeEffect({type: 'deconstructionIndicator'});
		}
	},

	actions: function(newActions) {
		if (newActions !== undefined) {
			this._actions = newActions;
			return this;
		}

		return this._actions;
	},

	dataFromConfig: function(data, classId) {
		data = data || {};
		classId = classId || this.classId();
		if (Healths[classId] !== undefined) {
			data.health = Healths[classId];
		}

		if (Types[classId] !== undefined) {
			data.type = Types[classId];
		}

		if (Descriptions[classId] !== undefined) {
			data.description = Descriptions[classId];
		}

		if (Recipes[classId] !== undefined) {
			data.recipe = Recipes[classId];
		}

		return data;
	},

	displayName: function() {
		var tokens = this.classId().match(/([A-Z]?[^A-Z]*)/g).slice(0, -1);
		var displayName = "";
		for (var i = 0; i < tokens.length - 1; i++) {
			var token = tokens[i];
			displayName += token + " ";
		}
		return displayName;
	},

	hp: function() {
		return this.health.value;
	},

	/**
	 * Processes actions that must occur when a {@link Block} is clicked.
	 * @param event {Object} Object containing information about the event that was fired. DO NOT TRUST THIS. This is
	 * currently sent down from the {@link BlockGrid} and the values in the event are not changed so that they are
	 * with respect to the {@link Block}.
	 * @param control {Object} The control object associated with the event that was fired.
	 * @memberof Block
	 * @instance
	 */
	mouseDown: function(event, control) {
		// TODO: Extend when clientState supports multiple current capabilities
		if (ige.client.state !== undefined) {
			var data = undefined;
			ige.client.state.currentCapability().tryPerformAction(this, event, data);
		}
	},

	/**
	 * Called just after this {@link Block} has been placed in a {@link BlockGrid}.
	 * @memberof BlockGrid
	 * @instance
	 */
	onPut: function() {
		if (ige.isClient) {
			this.addEffect({type: 'healthBar'});
		}
	},

	/**
	 * Called just before this {@link Block} is removed from a {@link BlockGrid}. Default is just a stub since the
	 * basic {@link Block} does nothing when removed from a {@link BlockGrid}. Override this function in subclasses of
	 * the {@link Block} if needed.
	 * @memberof BlockGrid
	 * @instance
	 */
	onRemove: function() {
		if (ige.isClient) {
			this.removeEffect({type: 'healthBar'});
			this.removeEffect({type: 'deconstructionIndicator'});
		}
	},

	remove: function() {
		if (this.gridData.grid) {
			this.gridData.grid.remove(this.gridData.loc);
		}
	},

	/**
	 * Adds an effect to this {@link Block}. Also takes care of making sure that an effects mount is created for this
	 * {@link Block} if one does not already exist. It is expected that all subclasses call this function at the
	 * beginning of their own addEffect function.
	 * @param effect {Object} An effect object containing information for the type of effect, the source block
	 * (block on which to mount the effect), and an optional target block for effects like the laser.
	 * @memberof Block
	 * @instance
	 */
	addEffect: function(effect) {
		switch (effect.type) {
			case 'glow':
				this._addGlowEffect(effect);
				break;
			case 'miningParticles':
				this._addMiningParticles();
				break;
			case 'healthBar':
				this._addHealthBar();
				break;
			case 'deconstructionIndicator':
				this._addDeconstructionIndicator();
				break;
		}
	},

	onDeath: function(player) {
		var loc = this.gridData.loc;
		var grid = this.gridData.grid;

		this.actions().push({
			action: "remove",
			loc: {
				x: loc.x,
				y: loc.y
			}
		});

		// Drop block server side, then send drop msg to client
		grid.drop(player, new IgePoint2d(loc.x, loc.y));
		if (grid.count() === 0) {
			grid.destroy();
		}
	},

	process: function(data) {
		if (data.component) {
			if (this[data.component] === undefined) {
				this.log("Block#process: received data for undefined component: " + data.component,
					"error");
			}

			this[data.component].process(data);
		}
		else {
			this.log("Block#process: received data without component.", "error");
		}
	},

	/**
	 * Removes an effect from this {@link Block}. Also takes care of making sure that the effects mount is destroyed
	 * if there are no more effects on this {@link Block}. It is expected that all subclasses call this function at
	 * the end of their own removeEffect function.
	 * @param effect {Object} An effect object containing information for the type of effect, the source block
	 * (block on which to mount the effect), and an optional target block for effects like the laser.
	 * @memberof Block
	 * @instance
	 */
	removeEffect: function(effect) {
		switch (effect.type) {
			case 'glow':
				this._removeGlowEffect();
				break;
			case 'miningParticles':
				this._removeMiningParticles();
				break;
			case 'healthBar':
				this._removeHealthBar();
				break;
			case "deconstructionIndicator":
				this._removeDeconstructionIndicator();
				break;
		}
	},

	/**
	 * Checks whether or not this {@link Block} has any effects. It is imperative that all effects code clean up after
	 * itself by deleting its key from the {@link Block#_effects|_effects} map when no longer needed, since this code
	 * checks how many keys are in that map.
	 * @returns {boolean}
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_hasEffects: function() {
		return Object.keys(this._effects).length === 0;
	},

	/**
	 * Adds a glow effect to this {@link Block}.
	 * @param effect {Object} An effect object that has all of the information about a {@link GlowEffect} object.
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_addGlowEffect: function(effect) {
		if (this._effects['glow'] !== undefined) {
			this._effects['glow'].destroy();
		}

		var effectsCenter = this._effectsCenter();

		this._effects['glow'] = new GlowEffect(effect);
		this._mountEffect(this._effects['glow'], false);
	},

	_effectsAboveContainer: function() {
		return this.gridData.grid.effectsAboveContainer();
	},

	_effectsBelowContainer: function() {
		return this.gridData.grid.effectsBelowContainer();
	},

	_effectsCenter: function() {
		return BlockGrid.coordinatesForBlock(this);
	},

	_mountEffect: function(effect, above) {
		var effectsCenter = this._effectsCenter();

		var container = above ? this._effectsAboveContainer() : this._effectsBelowContainer();

		effect.translateTo(effectsCenter.x, effectsCenter.y, 0).mount(container);
	},

	/**
	 * Removes the glow effect from this {@link Block}.
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_removeGlowEffect: function() {
		if (this._effects['glow'] !== undefined) {
			this._effects['glow'].destroy();
			delete this._effects['glow'];
		}
	},

	/**
	 * Adds the mining particles effect to this {@link Block}. At some point, multiple ships will be able to mine a
	 * {@link Block} at once, so the mining particles effects state includes a counter so we know when we should really
	 * remove this effect.
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_addMiningParticles: function() {
		if (this._effects['miningParticles'] === undefined) {
			this._effects['miningParticles'] = {
				counter: 0,
				particleEmitter: undefined
			};
		}

		this._effects['miningParticles'].counter++;
		if (!this._effects['miningParticles'].particleEmitter) {
			this._effects['miningParticles'].particleEmitter = new BlockParticleEmitter();
			this._mountEffect(this._effects['miningParticles'].particleEmitter, true);
		}
	},

	_addHealthBar: function() {
		if (this._effects['healthBar'] === undefined) {
			this._effects['healthBar'] = new HealthBar(this);
			this._mountEffect(this._effects['healthBar'], true);
		}
	},

	_addDeconstructionIndicator: function() {
		if (this._effects['deconstructionIndicator'] === undefined) {
			this._effects['deconstructionIndicator'] = new DeconstructionIndicator(this);
			this._mountEffect(this._effects['deconstructionIndicator'], true);
		}
	},

	/**
	 * Removes mining particles effect from this {@link Block}. If there are multiple people mining this {@link Block},
	 * then the counter in the mining particles effect state may not go down to zero during this call, in which case
	 * we will not actually remove the mining particles effect (because somebody else is still mining!).
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_removeMiningParticles: function() {
		this._effects['miningParticles'].counter--;

		if (this._effects['miningParticles'].counter === 0) {
			this._effects['miningParticles'].particleEmitter.destroy();
			delete this._effects['miningParticles'];
		}
	},

	/**
	 * Removes the health bar from block. This is not usually called because when
	 * the block (and any effects) are destroyed when the hp is 0.
	 * @memberof Block
	 * @private
	 * @instance
	 */
	_removeHealthBar: function() {
		this._effects['healthBar'].destroy();
		delete this._effects['healthBar'];
	},

	_removeDeconstructionIndicator: function() {
		if (this._effects['deconstructionIndicator']) {
			this._effects['deconstructionIndicator'].destroy();
			delete this._effects['deconstructionIndicator'];
		}
	},

	/**
	 * Getter/setter for the {@link Block#_blockGrid|_blockGrid} parameter. MUST be set! Many things depend on this.
	 * @param newBlockGrid {BlockGrid} Optional parameter. The new {@link BlockGrid} to associate with this
	 * {@link Block}.
	 * @returns {*} The current {@link BlockGrid} associated with this {@link Block} if the getter is called, or this
	 * object if the setter is called to make setter chaining convenient.
	 * @memberof Block
	 * @instance
	 */
	blockGrid: function() {
		return this.gridData.grid;
	},

	/**
	 * Getter/setter for the {@link Block#_row|_row} property.
	 * @param val {number} Optional parameter. If set, this is the new row value for this {@link Block}.
	 * @returns {*} The current row if no parameter is passed or this object if a parameter is passed to make setter
	 * chaining convenient.
	 * @memberof Block
	 * @instance
	 */
	row: function(val) {
		if (val !== undefined) {
			this._row = val;
			return this;
		}
		return this._row;
	},

	/**
	 * Getter/setter for the {@link Block#_col|_col} property.
	 * @param val {number} Optional parameter. If set, this is the new col value for this {@link Block}.
	 * @returns {*} The current col if no parameter is passed or this object if a parameter is passed to make setter
	 * chaining convenient.
	 * @memberof Block
	 * @instance
	 */
	col: function(val) {
		if (val !== undefined) {
			this._col = val;
			return this;
		}
		return this._col;
	},

	/**
	 * Decreases the block's health by the amount passed.
	 * @param amount {number} The amount of health that this {@link Block} should lose.
	 * @memberof Block
	 * @instance
	 */
	takeDamage: function(amount, player) {
		this.health.decrease(amount);

		this.emit('cosmos:block.hp.changed', this.hp());

		if (this.health.value <= 0 && ige.isServer) {
			this.onDeath(player);
		}
	},

	/**
	 * Getter/setter for the {@link Block#_isBeingMined|_isBeingMined} property. This flag is set to true on the server
	 * when mining begins. Currently, this is done so that blocks can't be mined by two players and get doubly removed
	 * from the {@link BlockGrid}.
	 * @param bool {boolean}
	 * @return {*}
	 * @memberof Block
	 * @instance
	 */
	isBeingMined: function(bool) {
		if (bool !== undefined) {
			this._isBeingMined = bool;
			return this;
		}
		return this._isBeingMined;
	},

	toJSON: function() {
		return {
			id: this.id(),
			type: this.classId(),
			gridData: this.gridData.toJSON()
		}
	},

	worldCoordinates: function() {
		if (this.gridData.grid) {
			return this.gridData.grid.worldCoordinatesForBlock(this);
		}

		return null;
	}
});

Block.BORDER_WIDTH = 2;

/**
 * Constant for the width of a {@link Block} as drawn in the world.
 * @constant {number}
 * @memberof Block
 */
Block.WIDTH = 26;
/**
 * Constant for the height of a {@link Block} as drawn in the world.
 * @constant {number}
 * @memberof Block
 */
Block.HEIGHT = 26;
/**
 * How long (in milliseconds) it takes for a ship with a single laser to decrease a block's HP by 1.
 * Note that even though MINING_INTERVAL is the same for all blocks,
 * blocks take different amounts of time to completely mine because they have different amounts of HP.
 * @constant {number}
 * @memberof Block
 */
Block.MINING_INTERVAL = 100;
/**
 * The amount of spacing between a {@link Block}'s health bar and the sides of the {@link Block} when the {@link Block}
 * is rendered. This value is measured in pixels.
 * @constant {number}
 * @memberof Block
 */
Block.HEALTH_BAR_MARGIN = 3;
/**
 * The height of the displayed health bar for a {@link Block}. This value is measured in pixels.
 * @constant {number}
 * @memberof Block
 */
Block.HEALTH_BAR_HEIGHT = 4;

Block.displayNameFromClassId = function(classId) {
	var tokens = classId.match(/([A-Z]?[^A-Z]*)/g).slice(0, -1);
	var displayName = "";
	for (var i = 0; i < tokens.length - 1; i++) {
		var token = tokens[i];
		if (i != 0) {
			displayName += " ";
		}
		displayName += token;
	}
	return displayName;
};

/**
 * Given a class ID, returns a new instance of the {@link Block} type associated with that class ID.
 * @param type {string} The class ID of the type of {@link Block} we want created.
 * @returns {Block} An instance of the {@link Block} type requested through classId.
 * @memberof Block
 */
Block.fromType = function(type) {
	if (cosmos.blocks.constructors[type] === undefined) {
		return undefined;
	}
	return new cosmos.blocks.constructors[type]();
};

Block.fromJSON = function(json) {
	var block;
	// In this case, we have received information about a block that already exists in the game.
	// Just use that block instead, and make sure to remove it from any grid that it is currently
	// a part of.
	// This currently occurs frequently when blocks are moved from a BlockGrid to a Drop. The Drop
	// will ask for a block that is already in a BlockGrid to be added to itself.
	if (ige.$(json.id) instanceof Block) {
		block = ige.$(json.id);
		block.remove();
	}
	else if (json.type === "Element") {
		block = new Element({
			resource: json.resource,
			purity: json.purity,
			gridWidth: json.gridData.width,
			gridHeight: json.gridData.height
		});
	}
	else {
		block = Block.fromType(json.type);
	}

	block.id(json.id);
	block.gridData.loc = new IgePoint2d(json.gridData.loc.x, json.gridData.loc.y);
	return block;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Block;
}
;var GridData = IgeClass.extend({
	classId: 'GridData',
	componentId: 'gridData',

	loc: undefined,
	grid: undefined,

	width: undefined,
	height: undefined,

	init: function(entity, data) {
		this.width = data.width;
		this.height = data.height;
	},

	bounds: function() {
		return {
			left: this.loc.x,
			top: this.loc.y,
			right: this.loc.x + this.width - 1,
			bottom: this.loc.y + this.height - 1
		};
	},

	toJSON: function() {
		return {
			loc: {
				x: this.loc.x,
				y: this.loc.y
			},
			width: this.width,
			height: this.height
		};
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = GridData;
}
;var SparseGrid = IgeClass.extend({
	classId: 'SparseGrid',

	_count: undefined,
	_grid: undefined,
	_lowerBound: undefined,
	/**
	 * Flag to indicate whether or not the SparseGrid is currently in the middle of a put operation.
	 * Helpful to differentiate whether or not remove was called directly or if it was the result
	 * of a put call.
	 */
	_putting: undefined,
	_upperBound: undefined,

	init: function(data) {
		this._grid = {};
		this._count = 0;
		this._colCounts = {};
		this._lowerBound = new IgePoint2d(0, 0);
		this._putting = false;
		this._upperBound = new IgePoint2d(0, 0);
	},

	count: function() {
		return this._count;
	},

	/*
	Loops through all of the blocks in a rectangle with upper left corner loc and dimensions width and height.
	Runs func on each block in this rectangle.
	*/
	each: function(func, loc, width, height) {
		if (typeof(func) !== "function") {
			this.log("SparseGrid#each: passed func value is not a function.", "warning");
			return null;
		}

		if (!IgePoint2d.validatePoint(loc)) {
			// If location is not provided, iterate over all items in the grid. This is a separate
			// loop because iterating over the keys is slightly more efficient in this case.
			for (var x in this._grid) {
				if (this._grid.hasOwnProperty(x)) {
					for (var y in this._grid[x]) {
						if (func(this._grid[x][y]) === true) {
							return true;
						}
					}
				}
			}
			return false;
		}

		if (width === undefined) {
			this.log("SparseGrid#each: no width parameter provided.", "warning");
			return null;
		}

		if (height === undefined) {
			this.log("SparseGrid#each: no height parameter provided.", "warning");
			return null;
		}

		for (var x = loc.x; x < loc.x + width; x++) {
			// If the specified column doesn't exist, then there's no reason to iterate over it
			if (!this._hasX(x)) {
				continue;
			}

			for (var y = loc.y; y < loc.y + height; y++) {
				var object = this._grid[x][y];
				if (object !== undefined) {
					// func can return false to indicate that we should stop iterating
					if (func(object) === true) {
						return true;
					}
				}
			}
		}

		return false;
	},

	/**
	 * Given a {@link Block}, returns the neighboring locations to the {@link Block} that do not have other blocks.
	 * @param block {Block} The {@link Block} to get the emptying neighboring locations for.
	 * @returns {Array} A list of location objects, which are of the format {row: number, col: number}. Each location
	 * represents a location neighboring the given {@link Block} that did not have a neighbor.
	 * @memberof BlockGrid
	 * @private
	 * @instance
	 */
	emptyNeighboringLocations: function(object) {
		var emptyNeighboringLocations = [];
		var neighboringLocations = this.neighboringLocationsForObject(object);

		var self = this;
		_.forEach(neighboringLocations, function(loc) {
			if (self.has(loc)) {
				emptyNeighboringLocations.push(loc);
			}
		});

		return emptyNeighboringLocations;
	},

	fromJSON: function(ObjectClass, json) {
		var self = this;
		_.forOwn(json, function(row, x) {
			_.forOwn(row, function(objectJSON, y) {
				var object = ObjectClass.fromJSON(objectJSON);
				self.put(object, object.gridData.loc, false);
			});
		});
	},

	get: function(loc, width, height) {
		if (!IgePoint2d.validatePoint(loc)) {
			this.log("SparseGrid#get: no valid loc provided.", "warning");
			return null;
		}

		// If no width and height are provided, just get the location provided.
		width = width || 1;
		height = height || 1;

		var objects = [];
		var objectsSet = {};

		this.each(function(object) {
			if (!objectsSet[object.id()]) {
				objectsSet[object.id()] = true;
				objects.push(object);
			}
		}, loc, width, height);

		return objects;
	},

	has: function(loc, width, height) {
		if (!IgePoint2d.validatePoint(loc)) {
			this.log("SparseGrid#has: no valid loc provided.", "warning");
			return false;
		}

		// If no width and height are provided, just check the location provided.
		width = width || 1;
		height = height || 1;

		// The each function will return true to indicate that it looped through everything and
		// false to indicate that it finished early (due to our stopping it).
		var brokeEarly = this.each(function(object) {
			// Return true to stop the iterator early.
			return true;
		}, loc, width, height);

		// If we broke early, then it must have been because we found an object, so return true.
		// Otherwise, we didn't find any objects, so return false.
		return brokeEarly;
	},

	hasNeighbors: function(loc, width, height) {
		var neighboringLocations = this.neighboringLocations(loc, width, height);

		var ret = false;
		var self = this;
		_.forEach(neighboringLocations, function(neighboringLocation) {
			if (self.has(neighboringLocation)) {
				ret = true;
			}
		});
		return ret;
	},

	hasNeighboringOpenLocations: function(loc, width, height) {
		var neighboringOpenLocations = this.neighboringOpenLocations(loc, width, height);
		return neighboringOpenLocations.length > 0;
	},

	gridHeight: function() {
		if (this.count() === 0) {
			return 0;
		}
		return this._upperBound.y - this._lowerBound.y + 1;
	},

	gridWidth: function() {
		if (this.count() === 0) {
			return 0;
		}
		return this._upperBound.x - this._lowerBound.x + 1;
	},

	lowerBound: function() {
		return this._lowerBound.clone();
	},

	neighboringLocations: function(loc, width, height) {
		// TODO: Validate the location, width, and height.
		var neighboringLocations = [];

		width = width || 1;
		height = height || 1;

		var topY = loc.y - 1;
		var bottomY = loc.y + height;
		var leftX = loc.x - 1;
		var rightX = loc.x + width;

		for (var x = leftX + 1; x <= rightX - 1; x++) {
			neighboringLocations.push(new IgePoint2d(x, topY));
			neighboringLocations.push(new IgePoint2d(x, bottomY));
		}

		for (var y = topY + 1; y <= bottomY - 1; y++) {
			neighboringLocations.push(new IgePoint2d(leftX, y));
			neighboringLocations.push(new IgePoint2d(rightX, y));
		}

		return neighboringLocations;
	},

	neighboringLocationsForObject: function(object) {
		// TODO: Validate that the object has the GridData component.
		return this.neighboringLocations(object.gridData.loc, object.gridData.width,
			object.gridData.height);
	},

	neighboringOpenLocations: function(loc, width, height) {
		var neighboringLocations = this.neighboringLocations(loc, width, height);
		var neighboringOpenLocations = [];

		var self = this;
		_.forEach(neighboringLocations, function(neighboringLocation) {
			if (!self.has(neighboringLocation)) {
				neighboringOpenLocations.push(neighboringLocation);
			}
		});

		return neighboringOpenLocations;
	},

	neighboringOpenLocationsForObject: function(object) {
		return this.neighboringOpenLocations(object.gridData.loc);
	},

	objectHasNeighboringOpenLocations: function(object) {
		// TODO: Validate that the object has the GridData component.
		return this.hasNeighboringOpenLocations(object.gridData.loc, object.gridData.width,
			object.gridData.height);
	},

	put: function(object, loc, replace) {
		if (object === undefined) {
			this.log("SparseGrid#put: no object parameter to put.", "warning");
			return null;
		}

		if (!IgePoint2d.validatePoint(loc)) {
			this.log("SparseGrid#put: no valid loc provided.", "warning");
			return null;
		}

		if (replace === undefined) {
			this.log("SparseGrid#put: no replace value provided.", "warning");
			return null;
		}

		if (!(object.gridData instanceof GridData)) {
			this.log("SparseGrid#put: object does not have grid data component.", "warning");
			return null;
		}

		if (object.gridData.grid !== undefined) {
			this.log("SparseGrid#put: attempt to add object that has already been added to a grid.",
				"warning");
			return null;
		}

		this._putting = true;

		var width = object.gridData.width;
		var height = object.gridData.height;

		var previousObjects = [];


		// Not allowed to replace blocks
		if (!replace) {
			// If there is are any blocks in the area that we want to occupy, we cannot place
			// because replacement is not allowed.
			if (this.has(loc, width, height)) {
				return null;
			}
		}
		// Allowed to replace blocks
		else {
			// Remove all of the objects currently occupying the area that we want to place in.
			previousObjects = this.remove(loc, width, height);
		}

		// Update the location of the object.
		object.gridData.loc = loc;
		object.gridData.grid = this;

		this._updateBoundsPut(object);

		// Place the object in the grid.
		this._setObject(object);

		this._putting = false;

		return previousObjects;
	},

	relativeLocation: function(loc) {
		return loc.minusPoint(this._lowerBound);
	},

	remove: function(loc, width, height) {
		if (!IgePoint2d.validatePoint(loc)) {
			this.log("SparseGrid#remove: no valid loc provided.", "warning");
			return null;
		}

		// If no width and height are provided, just remove the location provided.
		width = width || 1;
		height = height || 1;

		var previousObjects = this.get(loc, width, height);

		var extremeBounds = {
			left: Number.MAX_VALUE,
			top: Number.MAX_VALUE,
			right: -Number.MAX_VALUE,
			bottom: -Number.MAX_VALUE
		};

		var self = this;
		_.forEach(previousObjects, function(previousObject) {
			self._unsetObject(previousObject);
			if (previousObject.onRemove) {
				previousObject.onRemove();
			}
			previousObject.gridData.grid = undefined;

			var bounds = previousObject.gridData.bounds();

			extremeBounds.left = Math.min(extremeBounds.left, bounds.left);
			extremeBounds.top = Math.min(extremeBounds.top, bounds.top);
			extremeBounds.right = Math.max(extremeBounds.right, bounds.right);
			extremeBounds.bottom = Math.max(extremeBounds.bottom, bounds.bottom);
		});

		this._updateBoundsRemove(extremeBounds);

		return previousObjects;
	},

	toJSON: function() {
		var objects = this.get(this._lowerBound, this.gridWidth(), this.gridHeight());

		var json = {};

		_.forEach(objects, function(object) {
			var loc = object.gridData.loc;
			if (json[loc.x] === undefined) {
				json[loc.x] = {};
			}

			json[loc.x][loc.y] = object.toJSON();
		});

		return json;
	},

	upperBound: function() {
		return this._upperBound.clone();
	},

	_createX: function(x) {
		this._grid[x] = {};
		this._colCounts[x] = 0;
	},

	_hasX: function(x) {
		return this._grid[x] !== undefined;
	},

	_set: function(object, x, y) {
		// If the specified column doesn't exist yet, create it because otherwise
		// grid[loc.x][loc.y] will throw an exception.
		if (!this._hasX(x)) {
			this._createX(x);
		}

		this._grid[x][y] = object;

		// Increase the col count for this x value so that we can tell when a grid column is empty.
		this._colCounts[x]++;
	},

	_setObject: function(object) {
		var x = object.gridData.loc.x;
		var y = object.gridData.loc.y;

		// Loop through and place a reference to the object at each location it will occupy.
		for (var dx = 0; dx < object.gridData.width; dx++) {
			for (var dy = 0; dy < object.gridData.height; dy++) {
				this._set(object, x + dx, y + dy);
			}
		}

		// Update the global count.
		this._count++;
	},

	_unset: function(x, y) {
		// Remove the object at the specified location.
		delete this._grid[x][y];

		// Update the number of items in the specified column.
		this._colCounts[x]--;

		// Clean up memory for the column if it is now empty.
		if (this._colCounts[x] === 0) {
			delete this._grid[x];
			delete this._colCounts[x];
		}
	},

	_unsetObject: function(object) {
		var x = object.gridData.loc.x;
		var y = object.gridData.loc.y;

		// Loop through and unset all of the references to the object that we are removing.
		for (var dx = 0; dx < object.gridData.width; dx++) {
			for (var dy = 0; dy < object.gridData.height; dy++) {
				this._unset(x + dx, y + dy);
			}
		}

		// Update the global count.
		this._count--;
	},

	_updateBoundsPut: function(object) {
		var left = object.gridData.loc.x;
		var top = object.gridData.loc.y;
		var right = left + object.gridData.width - 1;
		var bottom = top + object.gridData.height - 1;

		if (this.count() === 0) {
			this._lowerBound = object.gridData.loc.clone();
			this._upperBound = new IgePoint2d(right, bottom);
			return;
		}

		this._lowerBound.x = Math.min(this._lowerBound.x, left);
		this._lowerBound.y = Math.min(this._lowerBound.y, top);

		this._upperBound.x = Math.max(this._upperBound.x, right);
		this._upperBound.y = Math.max(this._upperBound.y, bottom);
	},

	_updateBoundsRemove: function(extremeBounds) {
		if (this.count() === 0) {
			return;
		}

		if (extremeBounds.left === this._lowerBound.x || extremeBounds.right === this._upperBound.x) {
			this._updateHorizontalBounds();
		}

		if (extremeBounds.top === this._lowerBound.y || extremeBounds.top === this._upperBound.y) {
			this._updateVerticalBounds();
		}
	},

	_updateHorizontalBounds: function() {
		this._upperBound.x = -Number.MAX_VALUE;
		this._lowerBound.x = Number.MAX_VALUE;
		var self = this;
		_.forOwn(this._grid, function(col, key) {
			var num = parseInt(key);
			self._upperBound.x = Math.max(self._upperBound.x, num);
			self._lowerBound.x = Math.min(self._lowerBound.x, num);
		});
	},

	_updateVerticalBounds: function() {
		this._upperBound.y = -Number.MAX_VALUE;
		this._lowerBound.y = Number.MAX_VALUE;
		var self = this;
		_.forOwn(this._grid, function(col, key) {
			_.forOwn(col, function(val, key) {
				var num = parseInt(key);
				self._upperBound.y = Math.max(self._upperBound.y, num);
				self._lowerBound.y = Math.min(self._lowerBound.y, num);
			})
		});
	}
});

SparseGrid.fromJSON = function(ObjectClass, json) {
	var grid = new SparseGrid();

	grid.fromJSON(ObjectClass, json);

	return grid;
};

if (typeof(module) !== "undefined" && typeof(module.exports) !== "undefined") { module.exports = SparseGrid; }
;var BlockGridFixtureDebugContainer = IgeEntity.extend({
	classId: "BlockGridFixtureDebugContainer",

	init: function(data) {
		IgeEntity.prototype.init.call(this, data);

		this.addComponent(PixiRenderableComponent);
	}
});

if (typeof(module) !== "undefined" && typeof(module.exports) !== "undefined") {
	module.exports = BlockGridFixtureDebugContainer;
};var BlockGrid = IgeEntity.extend({
	classId: 'BlockGrid',

	// #ifdef SERVER
	/**
	 * Actions to be streamed to the clients.
	 */
	_actions: undefined,
	// Default body definition. Should not be written to!
	_defaultBodyDef: {
		bodyType: 'DYNAMIC',
		bodyCategory: '',
		linkedId: '',
		x: 0.0,
		y: 0.0,
		angle: 0.0,
		linearDamping: 3,
		angularDamping: 10,
		bullet: false
	},
	_physicsContainer: undefined,
	_physicsOffset: undefined,

	/**
	 * A hash whose keys are clientIds and values are Booleans.
	 * This is used in _streamControlFunc to determine if this entity has been
	 * streamed to a particular client. If an entity is not visible and has
	 * previously been streamed, then we know to send an _entityInvalid command
	 * to the client.
	 * @type {Object}
	 * @memberof BlockGrid
	 * @private
	 * @instance
	 */
	_previouslyStreamed: undefined,
	// #else
	/**
	 * Container for effects that need to appear above this BlockGrid.
	 */
	_effectsAboveContainer: undefined,
	/**
	 * Container for effects that need to appear below this BlockGrid.
	 */
	_effectsBelowContainer: undefined,
	/**
	 * Container for rendering child entities (i.e. Blocks).
	 */
	_renderContainer: undefined,
	// #endif

	init: function(data) {
		data = data || {};
		IgeEntity.prototype.init.call(this, data);

		this.implement(SparseGrid);
		SparseGrid.prototype.init.call(this, data);

		// TODO why should this entity have width and height of 0?
		this.width(0);
		this.height(0);

		this._physicsOffset = {x: 0, y: 0};

		this.addComponent(PixiRenderableComponent);

		this.streamSections(["transform", "actions"]);

		// #ifdef CLIENT
		if (ige.isClient) {
			// All containers have height and width 0, since their heights and widths do not need
			// to be kept up to date. Keeping the height and width 0 makes things slightly easier
			// to reason about because translating a container now feels more like translating a
			// point.
			this._effectsAboveContainer = new IgeEntity()
				.addComponent(PixiRenderableComponent)
				.depth(this.depth() + 1)
				// The _effectsAboveContainer can have width and height of 0 because it doesn't need to intercept any clicks
				// The BlockGrid intercepts all clicks.
				.width(0)
				.height(0)
				.mount(this);

			this._effectsBelowContainer = new IgeEntity()
				.addComponent(PixiRenderableComponent)
				.depth(this.depth() - 1)
				// The _effectsBelowContainer can have width and height of 0 because it doesn't need to intercept any clicks
				// The BlockGrid intercepts all clicks.
				.width(0)
				.height(0)
				.mount(this);

			// Create the render container and mount it to this entity.
			this._renderContainer = new RenderContainer()
				.depth(this.depth())
				// The renderContainer can have width and height of 0 because it doesn't need to intercept any clicks
				// The BlockGrid intercepts all clicks.
				.width(0)
				.height(0)
				.mount(this);

			if (data !== undefined) {
				// Hydrate this BlockGrid from JSON sent from the server.
				this.fromJSON(Block, data);
			}

			this.mouseDown(this._mouseDownHandler);
		}
		// #else
		else {
			// Initialize the actions
			this._actions = [];

			this.addComponent(TLPhysicsBodyComponent, data.physicsBody);

			// Specify initial starting location of physics body
			if (data && data.translate) {
				this.physicsBody.bodyDef['x'] = data.translate.x;
				this.physicsBody.bodyDef['y'] = data.translate.y;
			}

			// Add the BlockGrid's default body properties without overwriting
			// existing properties
			this.physicsBody.registerDefaultBodyDef(this._defaultBodyDef);
			this.physicsBody.newBody();

			// Used by streamControlFunc to help determine when to stream this entity to a client.
			this._previouslyStreamed = {};
			this.streamControl(this._streamControlFunc.bind(this));

		}
		// #endif
	},

	actions: function() {
		return this._actions;
	},

	// #ifdef CLIENT
	/**
	 * Adds an effect to a {@link Block} in this {@link BlockGrid}
	 * @param effect {Object} An effect object containing information for the type of effect, the source block
	 * (block on which to mount the effect), and an optional target block for effects like the laser.
	 * @memberof BlockGrid
	 * @instance
	 */
	addEffect: function(effect) {
		var block = this.get(new IgePoint2d(effect.sourceBlock.col, effect.sourceBlock.row))[0];
		block.addEffect(effect);
	},
	// #endif

	// #ifdef SERVER
	/**
	 * Removes a block or area of blocks from a BlockGrid and places it in a new drop at its current
	 * location.
	 * @param player The player who owns this drop. Undefined here means that anyone can pick up
	 * the drop.
	 * @param loc The location in the grid that should be dropped.
	 * @param width The width of the area that should be dropped. Defaults to 1 if no value is
	 * provided.
	 * @param height The height of the area that should be dropped. Defaults to 1 if no value is
	 * provided.
	 * @returns {null}
	 */
	drop: function(player, loc, width, height) {
		if (!IgePoint2d.validatePoint(loc)) {
			this.log("BlockGrid#drop: invalid location parameter.", "warning");
			return null;
		}

		width = width || 1;
		height = height || 1;

		var owner = (player !== undefined) ? player.currentShip() : undefined;
		var theta = this.rotate().z();
		var dropped = this.remove(loc, width, height);

		var self = this;
		_.forEach(dropped, function(drop) {
			// Don't drop bridge blocks!
			if (drop instanceof BridgeBlock) {
				return;
			}

			var dropCoordinates = self.worldCoordinatesForBlock(drop);
			var newDrop = new Drop({
					owner: owner,
					translate: {x: dropCoordinates.x, y: dropCoordinates.y}
				})
				.block(drop)
				.streamMode(1)
				.mount(ige.server.spaceGameScene);
		});
	},
	// #endif

	// #ifdef CLIENT
	effectsAboveContainer: function() {
		return this._effectsAboveContainer;
	},
	// #endif

	// #ifdef CLIENT
	effectsBelowContainer: function() {
		return this._effectsBelowContainer;
	},
	// #endif

	/**
	 * DON'T USE THIS FOR ANYTHING WHERE PERFORMANCE IS CRITICAL.
	 * Resets this BlockGrid's internal state to represent the grid that is represented by the provided {@link Block}
	 * matrix, which is a matrix of {@link Block}s. undefined is used to indicate that a space in the matrix is empty.
	 * @param blockMatrix {Array} An array of arrays that holds {@link Block objects}. undefined is used to indicate
	 * that a space in the blockMatrix is empty. The blockMatrix must be a rectangular matrix (every row has the same
	 * number of columns and every column has the same number of rows, but the total number of rows and total number
	 * of columns is not required to be the same).
	 * @param checkForNeighbors {boolean} Whether or not we should validate that each {@link Block} will be
	 * attached to the existing structure in this {@link BlockGrid}. Default behavior is to check for neighbors.
	 * @return {BlockGrid} Return this object to make function chaining convenient.
	 * @memberof BlockGrid
	 * @instance
	 */
	fromBlockMatrix: function(blockMatrix, checkForNeighbors) {
		for (var row = 0; row < blockMatrix.length; row++) {
			for (var col = 0; col < blockMatrix[row].length; col++) {
				if (blockMatrix[row][col]) {
					this.put(blockMatrix[row][col], new IgePoint2d(col, row), false);
				}
			}
		}

		return this;
	},

	/**
	 * DON'T USE THIS FOR ANYTHING WHERE PERFORMANCE IS CRITICAL.
	 * Resets this BlockGrid's internal state to represent the grid that is represented by the provided block type
	 * matrix, which is a matrix of class ID's where each class ID represents a block type in the grid.
	 * This is used for de-serializing a BlockGrid object.
	 * @param blockTypeMatrix {Array} An array of arrays that holds classId's for Block objects. undefined is used to
	 * indicate that a space in the blockTypeMatrix does not include a Block. The blockTypeMatrix must be a rectangular
	 * matrix (every row has the same number of columns and every column has the same number of rows, but the total number
	 * of rows and total number of columns is not required to be the same).
	 * @param checkForNeighbors {boolean} Whether or not we should validate that each {@link Block} will be
	 * attached to the existing structure in this {@link BlockGrid}. Default behavior is to check for neighbors.
	 * @returns {BlockGrid} Return this object to make function chaining convenient.
	 * @memberof BlockGrid
	 * @instance
	 */
	fromBlockTypeMatrix: function(blockTypeMatrix, checkForNeighbors, startRow, startCol) {
		startRow = startRow || 0;
		startCol = startCol || 0;

		for (var col = 0; col < blockTypeMatrix.length; col++) {
			for (var row = 0; row < blockTypeMatrix[col].length; row++) {
				if (blockTypeMatrix[col][row]) {
					this.put(
						Block.fromType(blockTypeMatrix[col][row]),
						new IgePoint2d(startCol + col, startRow + row),
						false
					);
				}
			}
		}

		return this;
	},

	/**
	 * Process actions on {@link Block}s client-side.
	 * @param data {Object} An object representing the action sent from the server.
	 * @memberof BlockGrid
	 * @instance
	 */
	processActionClient: function(data) {
		// If an ID is provided, it should be the ID of a block that must perform some action.
		if (data.id) {
			var block = ige.$(data.id);

			if (!block) {
				return;
			}

			if (!(block instanceof Block)) {
				this.log('BlockGrid#processActionClient: non-block entity ID received: '
					+ block.classId(), 'error');
			}

			block.process(data);
		}
		// Otherwise, this is an action intended for the Grid itself, like a put or a remove.
		else {
			switch (data.action) {
				case 'remove':
					var block = ige.$(data.blockId)
					if (block) {
						this.remove(new IgePoint2d(block.gridData.loc.x, block.gridData.loc.y));

						if (this.count() === 0) {
							this.destroy();
						}
					}

					break;
				case 'put':
					var block = Block.fromJSON(data.block);
					// TODO: Move this metrics tracking code elsewhere
					/*ige.client.metrics.track(
						'cosmos:construct.existing',
						{'type': block.classId()});*/
					this.put(block, new IgePoint2d(block.gridData.loc.x, block.gridData.loc.y), true);
					ige.emit('cosmos:BlockGrid.processActionClient.put', [block.classId(), this]);
					break;
				default:
					this.log('Cannot process block action ' + data.action + ' because no such action exists.', 'warning');
			}
		}
	},

	/**
	 * Process actions on {@link Block}s server-side.
	 * @param data {Object} An object representing the action sent from the client.
	 * @param player {Player} The player that triggered the block action.
	 * @returns {boolean} True if the action was successfully processed. False otherwise.
	 * @memberof BlockGrid
	 * @instance
	 */
	processBlockActionServer: function(data, player) {
		var self = this;

		switch (data.action) {
			case 'remove':
				var result = self.remove(ige.$(data.blockId).gridData.loc);

				if (result) {
					if (this.count() === 0) {
						this.destroy();
					}

					self.actions().push(data);
				}

				return result;
			case 'add':
				var location = new IgePoint2d(data.col, data.row);

				// Blocks added as the result of a query from a client must be added to an existing
				// contiguous structure.
				if (this.hasNeighbors(location)) {
					var block = Block.fromType(data.selectedType);
					// If put returns null, it means there was already a block at the requested
					// location.
					if (self.put(block, new IgePoint2d(data.col, data.row), false) === null) {
						return false;
					}
					self.actions().push({
						action: "put",
						block: block.toJSON()
					});
					return true;
				}
				else {
					return false;
				}
			default:
				return false;
		}
	},

	/**
	 * Places a block in the BlockGrid at the specified location.
	 * @param block The block to place.
	 * @param location The location to place the block at.
	 * @param replace If true, then the BlockGrid will replace any existing Blocks. If false, the
	 * BlockGrid will not replace existing blocks.
	 * @returns {*} A list of blocks that were replaced if replacement is on. An empty list if
	 * replacement is not. Returns null in the event of an error.
	 */
	put: function(block, location, replace) {
		// Validate parameters
		if (!block) {
			this.log("Invalid block passed to BlockGrid#put.", "warning");
			return null;
		}

		if (!IgePoint2d.validatePoint(location)) {
			this.log("Invalid location passed to BlockGrid#put.", "warning");
			return null;
		}

		var previousBlocks = SparseGrid.prototype.put.call(this, block, location, replace);

		// If previous blocks was null, then this block was placed on top of another block without
		// replacement.
		if (previousBlocks === null) {
			return null;
		}

		block.actions(this.actions());

		this.width(this.gridWidth() * Block.WIDTH);
		this.height(this.gridHeight() * Block.HEIGHT);

		// #ifdef SERVER
		if (ige.isServer) {
			this._addFixture(block);
		}
		// #else
		else {
			this._mountToRenderContainer(block);
		}
		// #endif

		this._translateContainers();

		block.onPut();

		if (ige.isClient) {
			this._renderContainer.refresh(true);
		}

		return previousBlocks;
	},

	/**
	 * Removes the object the specified location or the objects in the specified area.
	 * @param location The top left corner of the area to remove blocks from.
	 * @param width The width of the area to remove from. Defaults to 1 if no parameter is passed.
	 * @param height The height of the area to remove from. Defaults to 1 if no parameter is passed.
	 * @returns {*} A list of the blocks that were removed. May return null to indicate an error
	 * has occurred.
	 */
	remove: function(location, width, height) {
		// Validate parameters
		if (!IgePoint2d.validatePoint(location)) {
			this.log("Invalid location passed to BlockGrid#remove.", "warning");
			return null;
		}

		var removedBlocks = SparseGrid.prototype.remove.call(this, location, width, height);

		this.width(this.gridWidth() * Block.WIDTH);
		this.height(this.gridHeight() * Block.HEIGHT);

		this._translateContainers();

		var self = this;
		_.forEach(removedBlocks, function(block) {
			// #ifdef SERVER
			if (ige.isServer) {
				self.physicsBody.destroyFixture(block);
				block.actions(null);
			}
			// #else
			else {
				block.unMount();
			}
			// #endif
		});

		if (ige.isClient && !this._putting) {
			this._renderContainer.refresh();
		}

		return removedBlocks;
	},

	/**
	 * Removes an effect from a {@link Block} in this {@link BlockGrid}
	 * @param effect {Object} An effect object containing information for the type of effect, the source block
	 * (block on which to mount the effect), and an optional target block for effects like the laser.
	 * @memberof BlockGrid
	 * @instance
	 */
	removeEffect: function(effect) {
		var block = this.get(new IgePoint2d(effect.sourceBlock.col, effect.sourceBlock.row))[0];

		block.removeEffect(effect);
	},

	streamCreateData: function() {
		return this.toJSON();
	},

	/**
	 * Overrides the IgeEntityBox2d default streamSectionData function. This has been done to
	 * provide support for streaming a custom point and have the client interpolate that point.
	 * @param sectionId
	 * @param data
	 * @param bypassTimeStream
	 * @returns {string}
	 */
	streamSectionData: function(sectionId, data, bypassTimeStream) {
		switch (sectionId) {
			case 'transform':
				// If data has been provided, then we are on the client and need to handle values
				// passed to us by the server. In this case, the IgeEntityBox2d already knows what
				// to do and does some complex things to make interpolation work. Don't want to get
				// into that, so just let it do the work.
				if (data) {
					IgeEntity.prototype.streamSectionData
						.call(this, sectionId, data, bypassTimeStream);
				}
				// Otherwise, we are on the server and are being asked to produce values to pass
				// to the client. We want to send the physics position of this entity to the client.
				// That way the client can independently compute where things should go. This was
				// necessary to solve a problem where stream data from the server with old values
				// would render any attempt to translate the entity on the client completely
				// useless.
				else {
					var translate = new IgePoint3d(
						this.physicsBody.x,
						this.physicsBody.y,
						this._translate.z
					);

					return translate.toString(this._streamFloatPrecision) + ',' +
						this._scale.toString(this._streamFloatPrecision) + ',' +
						this._rotate.toString(this._streamFloatPrecision) + ',';
				}
				break;
			case 'actions':
				if (ige.isClient) {
					//console.log("BlockGrid#streamSectionData");
				}
				// Receiving actions data from the server.
				if (data) {
					var actions = JSON.parse(data);
					//console.log("BlockGrid#streamSectionData: actions client: " + actions.length + " actions");
					var self = this;
					_.forEach(actions, function(action) {
						self.processActionClient(action);
					});
				}
				// Generating actions data on the server.
				else {
					var actionsJson = JSON.stringify(this._actions);
					if (this._actions.length > 0) {
						//console.log("BlockGrid#streamSectionData: actions server: " + actionsJson);
					}
					while (this._actions.length > 0) {
						this._actions.pop();
					}

					return actionsJson;
				}
				break;
			// We don't care about any other stream sections.
			// We'll let IgeEntityBox2d handle them.
			default:
				return IgeEntity.prototype.streamSectionData
					.call(this, sectionId, data, bypassTimeStream);
				break;
		}
	},

	toBlockTypeMatrix: function() {
		var blockTypeMatrix = [];
		var upperBound = this.upperBound();
		var lowerBound = this.lowerBound();

		for (var x = lowerBound.x; x <= upperBound.x; x++) {
			var column = [];
			for (var y = lowerBound.y; y <= upperBound.y; y++) {
				var blocks = this.get(new IgePoint2d(x, y));
				if (blocks.length === 0) {
					column.push(undefined);
				}
				else {
					column.push(blocks[0].classId());
				}
			}
			blockTypeMatrix.push(column);
		}

		return blockTypeMatrix;
	},

	worldCoordinatesForBlock: function(block) {
		var relBlockLoc = new IgePoint2d(
			block.gridData.loc.x,
			block.gridData.loc.y
		);

		relBlockLoc.thisMinusPoint(this.lowerBound());

		// Scale up by the width and height of a 1x1 block
		relBlockLoc.thisMultiply(Block.WIDTH, Block.HEIGHT);

		relBlockLoc.thisAddPoint(new IgePoint2d(block._bounds2d.x2, block._bounds2d.y2));
		relBlockLoc.thisMinusPoint(new IgePoint2d(this._bounds2d.x2, this._bounds2d.y2));

		var rotatedLocalCoordinates = MathUtils.rotate(relBlockLoc, this.rotate().z());

		var entityCenter = new IgePoint2d(
			this.translate().x(),
			this.translate().y()
		);

		return entityCenter.addPoint(rotatedLocalCoordinates);
	},

	_addFixture: function(block) {
		// #ifdef SERVER
		if (ige.isServer) {
			// Update the block's physicsFixture component's fixtureDef
			this._updateFixtureDef(block);

			// Add a new fixture based on the new fixture def
			this.physicsBody.newFixture(block);
		}
		// #endif
	},

	_updateFixtureDef: function(block) {
		var coordinates = BlockGrid.coordinatesForBlock(block);
		var fixtureDef = block.physicsFixture.fixtureDef;
		 block.physicsFixture.fixtureDef = {
			fixtureCategory: fixtureDef.fixtureCategory || '',
			friction: fixtureDef.fixtureCategory || BlockGrid.BLOCK_FIXTURE_FRICTION,
			restitution: fixtureDef.restitution || BlockGrid.BLOCK_FIXTURE_RESTITUTION,
			density: fixtureDef.density || BlockGrid.BLOCK_FIXTURE_DENSITY,
			isSensor: fixtureDef.isSensor || false,
			shapeType: fixtureDef.shapeType || 'BOX',
			hwidth: fixtureDef.hwidth || (block.gridData.width * Block.WIDTH) / 2 -
				(2 * BlockGrid.BLOCK_FIXTURE_PADDING),
			hheight: fixtureDef.hheight || (block.gridData.height * Block.HEIGHT) / 2 -
				(2 * BlockGrid.BLOCK_FIXTURE_PADDING),
			x: fixtureDef.x || coordinates.x + BlockGrid.BLOCK_FIXTURE_PADDING,
			y: fixtureDef.y || coordinates.y + BlockGrid.BLOCK_FIXTURE_PADDING,
			angle: fixtureDef.angle || 0.0,
			categoryBits: this.physicsBody.fixtureFilter.categoryBits,
			maskBits: this.physicsBody.fixtureFilter.maskBits,
			groupIndex: this.physicsBody.fixtureFilter.groupIndex
		}
	},

	/**
	 * Given a mouse click, determines what location in the grid has been pressed in grid-relative
	 * coordinates.
	 * Does this by:
	 * 1. Unrotating the click coordinate
	 * 2. Comparing the unrotated click coordinate to where the blocks would be if the BlockGrid were not rotated
	 * @param event {Object} The event data for the click event.
	 * @param control {Object} The control data for the click event.
	 * @returns {IgePoint2d} The location that was clicked.
	 * @memberof BlockGrid
	 * @private
	 * @instance
	 */
	gridLocationForEvent: function(event, control) {
		// event.igeBaseX and event.igeBaseY give coordinates relative to the clicked entity's origin (center)

		// The position of the click in world coordinates
		var mousePosWorld = this.mousePosWorld();

		var worldX = mousePosWorld.x;
		var worldY = mousePosWorld.y;

		// The coordinates of the center of the axis-aligned bounding box of the render container in
		// world coordinates
		var aabb = this.aabb();
		var aabbX = aabb.x + aabb.width / 2;
		var aabbY = aabb.y + aabb.height / 2;

		// Translate the mouse position to a reference system where the center of the axis-aligned
		// bounding box is the center
		var aabbRelativeX = worldX - aabbX;
		var aabbRelativeY = worldY - aabbY;

		// This is the BlockGrid's rotation, not the render container's, since the render container does
		// not rotate with respect to its parent.
		// Negative because we want to reverse the rotation.
		var theta = -this._rotate.z;

		// The unrotated coordinates for comparison against an unrotated grid with respect to the center of the
		// entity
		// This uses basic trigonometry. See http://en.wikipedia.org/wiki/Rotation_matrix.
		var unrotated = MathUtils.rotate(new IgePoint2d(aabbRelativeX, aabbRelativeY), theta);

		// Height and width of the grid area //TODO refactor all of these operations to be vector operations
		var width = this.width();
		var height = this.height();

		// Coordinates for the top left corner of the grid area
		var topLeftCornerX = -width / 2;
		var topLeftCornerY = -height / 2;

		// Coordinates of the unrotated clicked point with respect to the top left of the grid area
		// This is just so calculations are a little bit easier
		var gridX = unrotated.x - topLeftCornerX;
		var gridY = unrotated.y - topLeftCornerY;

		var x = Math.floor(gridX / Block.WIDTH) + this.lowerBound().x;
		var y = Math.floor(gridY / Block.HEIGHT) + this.lowerBound().y;

		return new IgePoint2d(x, y);
	},

	_blockForClick: function(event, control) {
		var location = this.gridLocationForEvent(event, control);

		return this.get(location)[0];
	},

	_mountToRenderContainer: function(block) {
		var coordinates = BlockGrid.coordinatesForBlock(block);
		// Attach the block to the render container.
		block.mount(this._renderContainer);
		// Move the block within the render container to the right location.
		block.translateTo(coordinates.x, coordinates.y, 0);
	},

	/**
	 * Determines which {@link Block} in the {@link BlockGrid} was clicked and then passes the clicked {@link Block} to
	 * the {@link BlockGrid#_blockClickHandler}, which can be overriden by subclasses.
	 * @param event {Object} Information about the event that was fired.
	 * @param control {Object} Information about the control that was used when the event was fired. (Not really sure
	 * what this is.)
	 * @memberof BlockGrid
	 * @private
	 * @instance
	 */
	_mouseDownHandler: function(event, control) {
		var block = this._blockForClick(event, control);

		// Check if we have clicked on a valid block, if so we want to stop the
		// click propagation so we don't construct a block at this location
		if (block === undefined) {
			return;
		}
		else {
			control.stopPropagation();
		}

		ige.emit('cosmos:block.mousedown', block);
		this._blockClickHandler(block, event, control);
	},

	_blockClickHandler: function(block, event, control) {

	},

	/**
	 * Overrides superclass function. This function makes it possible for the client to mirror the
	 * calculations done on the server so that the two stay in sync all the time and no jumping
	 * occurs.
	 * @param dataArr
	 * @private
	 */
	_setTransformFromStreamData: function(dataArr) {
		// This will set our location to the physics location that is being streamed.
		IgeEntity.prototype._setTransformFromStreamData.call(this, dataArr);

		var rotatedPhysicsOffset = MathUtils.rotate(this._physicsOffset, this.rotate().z());

		// This will translate the entity to the computed physics offset on the client.
		this.translateBy(rotatedPhysicsOffset.x, rotatedPhysicsOffset.y, 0);
	},

	// #ifdef SERVER
	/**
	 * Controls whether or not this entity is streamed to a particular client.
	 * @param clientId {String} The client in question.
	 * @return {Boolean} True if the entity should be streamed to the client
	 * associated with the clientId.
	 * {@link BlockGrid}.
	 * @memberof BlockGrid
	 * @private
	 * @instance
	 */
	_streamControlFunc: function(clientId) {
		var player = ige.server.players[clientId];

		// TODO: Make a proper entity preloader to stop jittering when BlockGrids
		// are created on screen
		if (player === undefined || player.currentShip() === undefined) {
			this._previouslyStreamed[clientId] = false;
			return false;
		}

		// Checks if the entity is visible to the player. This means that the
		// player's visible rectangle intersects with this entity's aabb rectangle.
		var playerWorldPosition = player.currentShip().worldPosition();
		var width = Constants.minimapArea.MAXIMUM_WIDTH;
		var height = Constants.minimapArea.MAXIMUM_HEIGHT;
		var viewableRect = new IgeRect(
				playerWorldPosition.x - width / 2,
				playerWorldPosition.y - height / 2,
			width,
			height);
		if (viewableRect.intersects(this.aabb())) {
			this._previouslyStreamed[clientId] = true;
			return true;
		}
		else {
			if (this._previouslyStreamed[clientId] === true) {
				this._previouslyStreamed[clientId] = false;
				// Invalidate the stream data for this entity. The server has an
				// optimization where it doesn't send a streamData update to the client
				// if the previous streamData is the same. This is problematic because
				// when this entity is in view again, we want the server to send an
				// streamData update to the client.
				// We can force the server to update by invalidating the cached
				// streamData.
				ige.network.stream._streamClientData[this.id()][clientId] = 'INVALID';
				ige.network.stream.queueCommand('_entityInvalid', this.id(), clientId);
			}
			return false;
		}
	},
	// #endif

	/**
	 * When a BlockGrid's bounds grow or shrink, we must translate the containers inside of it and
	 * the physics offset so that things look like they didn't move to users. This is because height
	 * and width changes to an entity increase the bounds of the entity on all sides, and those
	 * bounds must be accurate and tight in order to efficiently capture mouse clicks.
	 * @private
	 */
	_translateContainers: function() {
		var topLeftCoordinates = BlockGrid.coordinatesForLocation(this.lowerBound());
		this._oldGridCenter = this._gridCenter;

		// This is the center of the tight bounding box around the blocks in the grid in a
		// coordinate system where (0, 0) is the origin. For convenience, blocks are placed where
		// you would expect them to be based on their coordinates, and then the entire coordinate
		// frame is shifted to match where the BlockGrid is located.
		this._gridCenter = {
			x: topLeftCoordinates.x - Block.WIDTH / 2 + (this.gridWidth() * Block.WIDTH) / 2,
			y: topLeftCoordinates.y - Block.HEIGHT / 2 + (this.gridHeight() * Block.HEIGHT) / 2
		};

		// Do nothing if nothing has changed.
		if (this._oldGridCenter && this._oldGridCenter.x === this._gridCenter.x
			&& this._oldGridCenter.y === this._gridCenter.y) {
			return;
		}

		this._physicsOffset = this._gridCenter;

		// #ifdef SERVER
		if (ige.isServer) {
			if (this._oldGridCenter) {
				var physicsTranslation = {
					x: this._gridCenter.x - this._oldGridCenter.x,
					y: this._gridCenter.y - this._oldGridCenter.y
				};

				var theta = this.rotate().z();

				var rotatedEntityTranslation = MathUtils.rotate(physicsTranslation, theta);

				this.translate().x(this.translate().x() + rotatedEntityTranslation.x);
				this.translate().y(this.translate().y() + rotatedEntityTranslation.y);
			}
		}
		// #else
		else {
			this._effectsAboveContainer.translateTo(-this._gridCenter.x, -this._gridCenter.y, 0);
			this._effectsBelowContainer.translateTo(-this._gridCenter.x, -this._gridCenter.y, 0);
			this._renderContainer.translateTo(-this._gridCenter.x, -this._gridCenter.y, 0);

			if (this._oldGridCenter) {
				var renderTranslation = {
					x: -this._gridCenter.x - (-this._oldGridCenter.x),
					y: -this._gridCenter.y - (-this._oldGridCenter.y)
				};

				var entityTranslation = {
					x: -renderTranslation.x,
					y: -renderTranslation.y
				};

				var theta = this.rotate().z();

				var rotatedEntityTranslation = MathUtils.rotate(entityTranslation, theta);

				this.translateBy(rotatedEntityTranslation.x, rotatedEntityTranslation.y, 0);
			}
		}
		// #endif
	}
});

/**
 * The default density value of a fixture created for a {@link Block}.
 * @constant {number}
 * @memberof BlockGrid
 */
BlockGrid.BLOCK_FIXTURE_DENSITY = 1.0;
/**
 * The default friction value of a fixture created for a {@link Block}.
 * @constant {number}
 * @memberof BlockGrid
 */
BlockGrid.BLOCK_FIXTURE_FRICTION = 0.5;
/**
 * The default restitution value of a fixture created for a {@link Block}.
 * @constant {number}
 * @memberof BlockGrid
 */
BlockGrid.BLOCK_FIXTURE_RESTITUTION = 0.5;
/**
 * The default padding value of a fixture create for a {@link Block}. Padding defines the difference in space between
 * the rendered {@link Block} and the fixture for that {@link Block}.
 * @constant {number}
 * @memberof BlockGrid
 */
BlockGrid.BLOCK_FIXTURE_PADDING = .1;

BlockGrid.coordinatesForBlock = function(block) {
	var loc = new IgePoint2d(block.gridData.loc.x, block.gridData.loc.y);

	var coordinates = BlockGrid.coordinatesForLocation(loc);

	// Because we need to return the center of the block. For larger blocks, this requires
	// adding as many half blocks as one minus the width of the block.
	coordinates.x += (block.gridData.width - 1) * Block.WIDTH / 2;
	// Because we need to return the center of the block. For larger blocks, this requires
	// adding as many half blocks as one minus the height of the block.
	coordinates.y += (block.gridData.height - 1) * Block.HEIGHT / 2;

	return coordinates;
};

BlockGrid.coordinatesForLocation = function(loc) {
	return {
		// Translates to the horizontal center of the location.
		x: Block.WIDTH * loc.x,
		// Translates to the vertical center of the location.
		y: Block.HEIGHT * loc.y
	}
};

if (typeof(module) !== "undefined" && typeof(module.exports) !== "undefined") {
	module.exports = BlockGrid;
}
;/**
 * The BlockStructure extends the {@link BlockGrid} to provide functionality (like mining and constructing) for
 * structures made out of blocks in the game (e.g. ships, asteroids, etc.).
 * It is necessary that this functionality be separated out from the {@link BlockGrid} because the {@link BlockGrid}
 * is meant to act as just a data structure and nothing else.
 * @class
 * @typedef {BlockGrid} BlockStructure
 * @namespace
 */
var BlockStructure = BlockGrid.extend({
	classId: 'BlockStructure',

	/**
	 * Construction zone overlay for showing and hiding locations that players can click on in order to place a block
	 * on an existing structure.
	 * @type {ConstructionOverlay}
	 * @memberof BlockStructure
	 * @private
	 * @instance
	 */
	_constructionOverlay: undefined,
	/**
	 * Controls whether or not the Construction Overlay should be refreshed.
	 */
	_enableRefresh: undefined,
	/**
	 * Controls whether or not Construction Overlay is refreshed during streamSectionData.
	 */
	_needsRefresh: undefined,

	init: function(data) {
		data = data || {};

		if (ige.isServer) {
			data.physicsBody = data.physicsBody || {};

			// These are default values for the category and mask of a BlockStructure.
			// Subclasses can override these by setting their own.
			data.physicsBody.fixtureFilter = data.physicsBody.fixtureFilter || {
				categoryBits: data.physicsBody.categoryBits
					|| BlockStructure.BOX2D_CATEGORY_BITS,
				maskBits: data.physicsBody.maskBits
					|| (0xffff & ~(1 << Drop.BOX2D_CATEGORY_BITS))
			}
		}

		BlockGrid.prototype.init.call(this, data);

		this._enableRefresh = true;

		if (ige.isClient) {
			this._constructionOverlay = new ConstructionOverlay(this)
				.mount(this);
		}
	},

	processActionClient: function(data) {
		if (data.action === "remove" || data.action === "put") {
			this._needsRefresh = true;
		}

		BlockGrid.prototype.processActionClient.call(this, data);
	},

	put: function(block, location, replace) {
		var refresh = this._enableRefresh;
		this._enableRefresh = false;
		var result = BlockGrid.prototype.put.call(this, block, location, replace);
		this._enableRefresh = refresh;

		this._refreshConstructionOverlay();
		return result;
	},

	remove: function(location, width, height) {
		var result = BlockGrid.prototype.remove.call(this, location, width, height);

		this._refreshConstructionOverlay();

		return result;
	},

	streamSectionData: function(sectionId, data, bypassTimeStream) {
		if (data) {
			if (sectionId === "actions") {
				var refresh = this._enableRefresh;
				this._enableRefresh = false;

				// Reset this to false before the BlockGrid processes all of the packets.
				this._needsRefresh = false;
				BlockGrid.prototype.streamSectionData.call(this, sectionId, data, bypassTimeStream);
				this._enableRefresh = refresh;

				// If after processing all of the packets, needsRefresh has been set to true, then
				// an add or remove has occurred, so we must refresh the overlay.
				if (this._needsRefresh) {
					this._refreshConstructionOverlay();
				}
			}
			else {
				BlockGrid.prototype.streamSectionData.call(this, sectionId, data, bypassTimeStream);
			}
		}
		else {
			return BlockGrid.prototype.streamSectionData.call(this, sectionId, data,
				bypassTimeStream);
		}


	},

	/**
	 * Overrides {@link BlockGrid#_blockClickHandler}. Does logical checks to make sure that a {@link Block} can be
	 * clicked before passing the click event down to the {@link Block} itself.
	 * @param block {Block} The {@link Block} that has been clicked.
	 * @param event {Object} The event data about the click. SHOULD NOT BE TRUSTED FOR POSITIONAL DATA because the
	 * {@link BlockGrid} does not update these before passing them down.
	 * @param control {Object} The control object associated with the click.
	 * @memberof BlockStructure
	 * @private
	 * @instance
	 * @todo Don't make the assumption that mouseDown on a {@link BlockStructure} means mining a {@link Block}.
	 */
	_blockClickHandler: function(block, event, control) {
		block.mouseDown(event, control);
	},

	_refreshConstructionOverlay: function() {
		if (ige.isClient && this._constructionOverlay && this._enableRefresh) {
			this._constructionOverlay.refresh();
		}
	}
});

BlockStructure.BOX2D_CATEGORY_BITS = 0x0008;


if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = BlockStructure;
}
;var GeneratedBlockStructure = BlockStructure.extend({
	classId: 'GeneratedBlockStructure',

	_numLayers: undefined,
	_blockDistribution: undefined,
	_symmetric: undefined,

	init: function(data) {
		BlockStructure.prototype.init.call(this, data);

		if (data === undefined) {
			data = {};
		}

		this._numLayers = data.numLayers;
		this._blockDistribution = data.blockDistribution;
		this._symmetric = data.symmetric;

		if (ige.isServer) {
			this.addComponent(RespawnableComponent, {
				minRespawnTime: GeneratedBlockStructure.MIN_RESPAWN_TIME,
				maxRespawnTime: GeneratedBlockStructure.MAX_RESPAWN_TIME,
				respawnAction: GameInit.spawnStructure.bind(
					GameInit,
					this._numLayers,
					this._blockDistribution,
					this._symmetric
				)
			});
		}
	},

	remove: function(loc, width, height) {
		if (ige.isServer) {
			this.respawn.resetTimeout();
		}
		return BlockStructure.prototype.remove.call(this, loc, width, height);
	}
});

/**
 * Minimum time it takes to respawn this structure.
 * @type {number}
 */
GeneratedBlockStructure.MIN_RESPAWN_TIME = 60 * 1000 * 2; // 2 minutes

/**
 * Maximum time it takes to respawn this structure.
 * @type {number}
 */
GeneratedBlockStructure.MAX_RESPAWN_TIME = 60 * 1000 * 52; // 52 minutes

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = GeneratedBlockStructure; }
;/**
 * Subclass of the {@link BlockGrid} class. The Drop class is used to represent a dropped {@link Block} which can be
 * picked up by a player. It understand which player caused it to be dropped in the first place and handles both the
 * physics and appearance of Drops in the game. Also see {@link GameInit#initPhysics}.
 * @class
 * @typedef {Object} Drop
 * @namespace
 */
var Drop = BlockGrid.extend({
	classId: 'Drop',

	/**
	 * The owner of this {@link Drop}, i.e. the ship that caused the drop to occur. While the owner property is set,
	 * nobody but the owner of the {@link Drop} may pick it up. When the owner property is not set, anybody can pick it
	 * up.
	 * @type {IgeEntityBox2d}
	 * @memberof Drop
	 * @private
	 * @instance
	 */
	_owner: undefined,
	/**
	 * The object that this {@link Drop} is currently moving towards. If not set, this {@link Drop} is not moving.
	 * When an object that can pick up this {@link Drop} gets close to it, the {@link Drop} will accelerate towards it!
	 * @type {IgeEntityBox2d}
	 * @memberof Drop
	 * @private
	 * @instance
	 */
	_attractedTo: undefined,

	init: function(opts) {
		opts = opts || {};
		var self = this;
		// To change owner after initialization, use setOwner()
		this._owner = opts.owner;
		this.category(Drop.BOX2D_CATEGORY_BITS);

		if (ige.isServer) {
			opts.physicsBody = {};
			opts.physicsBody.bodyDef = {
				bodyCategory: Drop.BOX2d_CATEGORY,
				linkedId: opts.owner.id()
			};
			opts.physicsBody.fixtureFilter = {
				categoryBits: Drop.BOX2D_CATEGORY_BITS,
				maskBits: Ship.ATTRACTOR_BOX2D_CATEGORY_BITS | Ship.BOX2D_CATEGORY_BITS
			};
		}

		BlockGrid.prototype.init.call(this, opts);

		this.depth(Drop.DEPTH);
		this.height(Block.HEIGHT);
		this.width(Block.WIDTH);

		if (ige.isClient) {
			this.texture(ige.client.textures.drop);
			var effect = NetworkUtils.effect('glow', this.block());
			effect.height = this.block().height();
			effect.width = this.block().width();
			this.block().addEffect(effect);
		}
		else {
			setTimeout(function() {
				if (self.alive()) {
					self.setOwner(undefined);
				}
			}, Drop.OWNERSHIP_PERIOD)
		}
	},

	/**
	 * Getter/setter for the {@link Drop#_block|_block} property.
	 * @param newBlock {Block?} Optional parameter. If supplied, the new value for the {@link Drop#_block|_block}
	 * property to set. Otherwise, the getter has been called.
	 * @returns {Block|Drop} If the newBlock parameter is not supplied, returns the current {@link Block} in this
	 * {@link Drop}. Otherwise, returns this {@link Drop} to make setter chaining convenient.
	 * @memberof Drop
	 * @instance
	 */
	block: function(newBlock) {
		if (newBlock === undefined) {
			return this.get(new IgePoint2d(0, 0))[0];
		}

		if (this.get(new IgePoint2d(0, 0)).length > 0) {
			this.log("Tried to replace the existing block in a Drop.", "error");
			return;
		}

		this.put(newBlock, new IgePoint2d(0, 0), true);
		newBlock.health.value = newBlock.health.max;
		return this;
	},

	getOwner: function() {
		return this._owner;
	},

	setOwner: function (newOwner) {
		this._owner = newOwner;
		this.physicsBody.setLinkedId(newOwner);
		return this;
	},

	/**
	 * Checks whether or not the provided {@link IgeEntityBox2d} is the same as this {@link Drop}'s owner.
	 * @param entity {IgeEntityBox2d} The entity to check against this {@link Drop}'s owner.
	 * @returns {boolean} True if the provided entity is the same as this {@link Drop}'s owner. False otherwise.
	 * @memberof Drop
	 * @instance
	 * TODO have this function use the owner() function instead of referenceing _owner
	 */
	isOwner: function(entity) {
		if (this._owner === undefined) {
			return true;
		}

		if (this._owner.classId() === "Player" && entity.classId() === "Player") {
			return this._owner.currentShip() === entity.currentShip();
		}

		return this._owner === entity;
	},

	getAttractedTo: function() {
		return this._attractedTo;
	},

	setAttractedTo: function(newAttraction) {
		this._attractedTo = newAttraction;
		return;
	},

	/**
	 * Overrides the superclass ({@link BlockGrid}) update function. Custom functionality moves this {@link Drop}
	 * towards its attraction target if there is one.
	 * @memberof Drop
	 * @instance
	 */
	update: function(ctx) {
		if (ige.isServer) {
			if (this.getAttractedTo() !== undefined) {
				// If the attractedTo entity is destroyed, remove the reference
				if (ige.$(this.getAttractedTo().id()) === undefined) {
					this.setAttractedTo(undefined);
					return;
				}

				// Attract the block grid to another body. For example, small asteroids
				// are attracted to player ships.
				var attractor = this.getAttractedTo();
				this.physicsBody.attractTo(attractor, attractor.attractionStrength());
		}


			//This is just a little bit larger than the background image. That's why I chose this size.
			var MAX_X = 7000;
			var MAX_Y = 7000;
			var x = this.translate().x();
			var y = this.translate().y();

			if (x > MAX_X || x < -MAX_X) {
				this.translateTo(-x, y, 0);
			}
			if (y > MAX_Y || y < -MAX_Y) {
				this.translateTo(x, -y, 0);
			}
		}

		BlockGrid.prototype.update.call(this, ctx);
	}
});

/**
 * The Box2D category of all {@link Drop} objects. Used by Box2D to determine what to do in certain collision scenarios.
 * @constant {string}
 * @default
 * @memberof Drop
 */
Drop.BOX2D_CATEGORY_BITS = 0x0004;

/**
 * The amount of time in milliseconds that a drop can only be picked up by its owner. After this amount of time, any
 * player may pick up the drop.
 * @constant {number}
 * @default
 * @memberof Drop
 */
Drop.OWNERSHIP_PERIOD = 10000;

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Drop; }
;/**
 * This class is supposed to be instantiated exactly once on each client.
 * Subclass of the {@link Block} class.
 * @class
 * @typedef {DeconstructionIndicator}
 * @namespace
 */
var DeconstructionIndicator = Block.extend({
	classId: 'DeconstructionIndicator',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x11FF0000;
			this.borderColor = 0xFF0000;

			this.iconFrame = "ConstructionZone.png";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = DeconstructionIndicator;
}
;/**
 * Subclass of the {@link Block}. A Part is an abstract super class for all
 * {@link Block} types that would be used on a player's ship or man-made
 * structures (e.g. {@link RedLaserBlock}, {@link EngineBlock}).
 * @class
 * @typedef {Part}
 * @namespace
 */
var Part = Block.extend({
	classId: 'Part',

	init: function(data) {
		data = this.dataFromConfig(data);
		Block.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Part; }
;/**
 * Subclass of the {@link Part} class. The {@link EngineBlock} class represents a {@link Block} that propels a ship.
 * Having more engine blocks allows you to (1) accelerate more rapidly and (2) travel at a greater maximum speed.
 * @class
 * @typedef {EngineBlock}
 * @namespace
 */
var EngineBlock = Part.extend({
	classId: 'EngineBlock',

	init: function (data) {
		Part.prototype.init.call(this, data);
	},

	/**
	 * Overrides the superclass onAdded function. Makes sure that all engines that are on players ships have particle
	 * effects when they are added to a {@link Player} {@link BlockGrid}.
	 * @memberof EngineBlock
	 * @instance
	 */
	onPut: function() {
		Part.prototype.onPut.call(this);

		if (!ige.isServer && this.blockGrid().classId() === 'Ship') {
			this.addEffect(NetworkUtils.effect('engineParticles', this));
		}
	},

	/**
	 * Overrides the superclass onRemoved function. Makes sure that engine particle effects are properly removed and
	 * cleaned up when this {@link EngineBlock} is removed from a {@link Player}.
	 * @memberof EngineBlock
	 * @instance
	 */
	onRemove: function() {
		if (!ige.isServer && this.blockGrid().classId() === 'Ship') {
			this.removeEffect(NetworkUtils.effect('engineParticles', this));
		}
	},

	/**
	 * Overrides the superclass addEffect function. The EngineBlock supports engine particles.
	 * @param effect {Object} An effect object, which stores the effect type and two
	 * network-converted {@link Block} objects as returned from {@link NetworkUtils#block}. The source block is the block
	 * that the effect is being added to. The target block is a secondary block that is required for certain effects like
	 * the laser effect.
	 * @memberof EngineBlock
	 * @instance
	 */
	addEffect: function(effect) {
		Part.prototype.addEffect.call(this, effect);

		switch (effect.type) {
			case 'engineParticles':
				//this._addEngineParticlesEffect();
				break;
		}
	},

	/**
	 * Handles adding the engine particle effect to this {@link EngineBlock}
	 * @memberof EngineBlock
	 * @private
	 * @instance
	 */
	_addEngineParticlesEffect: function() {
		this._effects['engineParticles'] = new IgeParticleEmitter()
			// Set the particle entity to generate for each particle
			.particle(EngineParticle)
			// Set particle life to 300ms
			.lifeBase(300)
			// Set output to 60 particles a second (1000ms)
			.quantityBase(60)
			.quantityTimespan(1000)
			// Set the particle's death opacity to zero so it fades out as it's lifespan runs out
			.deathOpacityBase(0)
			// Set velocity vector to y = 0.05, with variance values
			//.velocityVector(new IgePoint3d(0, 0.05, 0), new IgePoint3d(-0.04, 0.05, 0), new IgePoint3d(0.04, 0.15, 0))
			.translateVarianceY(-10, 10)
			.translateVarianceX(-10, 10)
			// Mount new particles to the object scene
			.particleMountTarget(ige.client.spaceGameScene)
			.start();
		this._mountEffect(this._effects['engineParticles'], false);
	},

	/**
	 * Handles removing the engine particle effect from this {@link EngineBlock}
	 * @memberof EngineBlock
	 * @private
	 * @instance
	 */
	_removeEngineParticlesEffect: function() {
		if (this._effects['engineParticles'] !== undefined) {
			this._effects['engineParticles'].destroy();
			delete this._effects['engineParticles'];
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = EngineBlock; }
;var IronEngineBlock = EngineBlock.extend({
	classId: 'IronEngineBlock',

	init: function (data) {
		// Add the thrust component to all Engine blocks.
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "WallabyLightPropulsorEngine.png";
		}

		EngineBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IronEngineBlock; }
;var SteelEngineBlock = EngineBlock.extend({
	classId: 'SteelEngineBlock',

	init: function (data) {
		// Add the thrust component to all Engine blocks.
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "CelereImpulsorEngine.png";
		}

		EngineBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = SteelEngineBlock; }
;var DragonBreathEngineBlock = EngineBlock.extend({
	classId: 'DragonBreathEngineBlock',

	init: function (data) {
		// Add the thrust component to all Engine blocks.
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "ZentrumFusionEngine.png";
		}

		EngineBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = DragonBreathEngineBlock; }
;/**
 * Subclass of the {@link Part} class. The BridgeBlock allows you to control your ship.
 * @class
 * @typedef {BridgeBlock}
 * @namespace
 * @todo When you lose your control block you should lose control of your ship.
 */
var BridgeBlock = Part.extend({
	classId: 'BridgeBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = 'CommandModule.png';
		}

		Part.prototype.init.call(this, data);
	},

	/*
	 * Override the Block's _mouseOverHandler to do nothing.
	 * This is because you can't deconstruct a Bridge Block, so
	 * it would be misleading for it to show a deconstruction indicator
	 * when you mouse over it.
	 */
	_mouseOverHandler: function() {
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = BridgeBlock; }
;/**
 * Subclass of the {@link Part} class. ThrusterBlocks allow your ship to rotate.
 * They don't provide primary thrust, they just provide the little impulses necessary to rotate your ship.
 * The more thrusters you have the more agile your ship will be.
 * @class
 * @typedef {ThrusterBlock}
 * @namespace
 */
var ThrusterBlock = Part.extend({
	classId: 'ThrusterBlock',

	init: function(data) {
		Part.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ThrusterBlock; }
;var IronThrusterBlock = ThrusterBlock.extend({
	classId: 'IronThrusterBlock',

	init: function(data) {
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "DaceloManeuveringThruster.png";
		}

		ThrusterBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IronThrusterBlock; }
;var SteelThrusterBlock = ThrusterBlock.extend({
	classId: 'SteelThrusterBlock',

	init: function(data) {
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "HAV3200ThrusterArray.png";
		}

		ThrusterBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = SteelThrusterBlock; }
;var KryptoniteThrusterBlock = ThrusterBlock.extend({
	classId: 'KryptoniteThrusterBlock',

	init: function(data) {
		if (Thrusts[this.classId()] !== undefined) {
			this.addComponent(Thrust, Thrusts[this.classId()]);
		}

		if (!ige.isServer) {
			this.iconFrame = "HXV4600FusionRelayThruster.png";
		}

		ThrusterBlock.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = KryptoniteThrusterBlock; }
;/**
 * Subclass of the {@link Part}. A Weapon is an abstract super class for all {@link Block} types that can be used to
 * deal damage to other {@link Block}s. (e.g. {@link RedLaserBlock}).
 *
 * Components: DamageComponent
 * @class
 * @typedef {Weapon}
 * @namespace
 */
var Weapon = Part.extend({
	classId: 'Weapon',

	init: function(data) {
		Part.prototype.init.call(this, data);
		// TODO: Determine dps value based on subclass

		if (DamageSources[this.classId()]) {
			this.addComponent(DamageSource, DamageSources[this.classId()]);
		}
	},

	fireClient: function(targetLoc) {
		IgeClass.abstractMethodError('fireClient');
	},

	fireServer: function(data) {
		IgeClass.abstractMethodError('fireServer');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Weapon; }
;var Laser = Weapon.extend({
	classId: 'Laser',

	_rayCastId: undefined,

	init: function(data) {
		Weapon.prototype.init.call(this, data);
	},

	firingUpdate: function() {
		if (!this.damageSource.target()) {
			// TOOD: This case is being hit. Figure out why and fix it, because this should never
			// happen.
			this.log("Laser#firingUpdate: called on a non-firing weapon.", "warning");
			return
		}

		var laserLoc = this.worldCoordinates();
		if (!laserLoc) {
			this.log("Laser#firingUpdate: error getting world coordinates of laser.", "error");
		}

		var targetLoc = this.damageSource.target();

		var delta = {x: targetLoc.x - laserLoc.x, y: targetLoc.y - laserLoc.y};
		var theta = Math.atan2(delta.y, delta.x);

		var inRangeLoc = {
			x: this.damageSource.range * Math.cos(theta) + laserLoc.x,
			y: this.damageSource.range * Math.sin(theta) + laserLoc.y
		};

		var opts = {
			point1X: laserLoc.x,
			point1Y: laserLoc.y,
			point2X: inRangeLoc.x,
			point2Y: inRangeLoc.y,
			ignoreBodyIds: [this.gridData.grid.id()],
			ignoreFixtureIds: [],
			ignoreFixtureCategories: [Ship.ATTRACTOR_BOX2D_CATEGORY_BITS,
				Drop.BOX2D_CATEGORY_BITS]
		};

		var self = this;
		var rayCastId = this._rayCastId = ige.physicsSystem.newRayCast(opts, function(data) {
			// If the stored rayCastId doesn't match the instance's rayCastId, this block was
			// probably removed. This needs to be dealt with because the rayCast system has an
			// asynchronous callback. Between when we ask for the rayCast and when we receive the
			// results, the block that requested the rayCast may have been removed or modified in
			// some meaningful way.
			if (rayCastId !== self._rayCastId) {
				return;
			}

			var intersectionPoint = {x: inRangeLoc.x, y: inRangeLoc.y};
			var hitBlock = null;

			_.forEach(data, function(intersected) {
				hitBlock = intersected.entity;
				if (!(hitBlock instanceof Block)) {
					self.log("Weapon#firingUpdate: received non-Block entity from ray cast: " +
						hitBlock.classId(), "error");
				}

				// Must check if grid is defined here. Theory is that the game server removes the
				// block from the grid then makes a request to the Physics Server to destroy the
				// associated fixture. Before the physics server destroys the fixture, it returns
				// that fixture as a raycast intersection resulting in a block here that is not
				// actually in a grid anymore.
				if (hitBlock.health.value <= 0 || !hitBlock.gridData.grid) {
					// Continue
					return;
				}

				intersectionPoint.x = intersected.pointX;
				intersectionPoint.y = intersected.pointY;

				// Stop the loop early
				return false;
			});

			if (hitBlock && hitBlock.gridData.grid) {
				var damage = self.damageSource.damage * Constants.UPDATE_TIME.SERVER
					/ self.damageSource.duration;

				hitBlock.takeDamage(damage, self.gridData.grid.player());
			}

			self.damageSource.intersectionPointServer(intersectionPoint);

			/* Increment duration fired/ */
			self.damageSource.durationFired += Constants.UPDATE_TIME.SERVER;

			/* If we have fired for as long as we were supposed to, shut off the weapon. */
			if (self.damageSource.durationFired >= self.damageSource.duration) {
				self.stopFiring();

				self.damageSource.coolingDown(true);
				setTimeout(function() {
					self.damageSource.coolingDown(false);
				}, self.damageSource.cooldown);
			}
			else {
				var renderData = {
					id: self.id(),
					targetLoc: intersectionPoint,
					normal: {x: data.normalX, y: data.normalY}
				};
			}
		});
	},

	fireClient: function(targetLoc) {
		var data = {
			id: this.id(),
			targetLoc: targetLoc
		};

		ige.network.send('cosmos:Weapon.fire', data);
	},

	fireServer: function(data) {
		/* Validate whether or not this weapon can fire */
		// Cannot fire while on cooldown.
		// Must check whether or not this block is part of a Ship because there are race conditions
		// where one client sends a message to have a laser fire, but before that message reaches
		// the server the laser is destroyed and placed in a drop. At that point, the grid of the
		// laser is not a ship, which would otherwise crash the server without this check.
		if (this.damageSource.coolingDown() || !(this.blockGrid() instanceof Ship)) {
			return;
		}

		// If already firing, duration will not reset. This way a player can only fire for the
		// laser's duration, but can retarget during that duration.
		if (!this.damageSource.target()) {
			this.damageSource.durationFired = 0;
			this.gridData.grid.firingWeapons().push(this);
		}

		this.damageSource.target(data.targetLoc);
	},

	onRemove: function() {
		Weapon.prototype.onRemove.call(this);

		if (ige.isServer && this.damageSource.target()) {
			this.stopFiring();
		}
	},

	stopFiring: function() {
		this.damageSource.target(null);
		this.damageSource.intersectionPointServer(null);
		this._rayCastId = undefined;

		var firingWeapons = this.blockGrid().firingWeapons();
		firingWeapons.splice(firingWeapons.indexOf(this), 1);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Laser;
}
;/**
 * Subclass of the {@link Part} class.
 * The {@link RedLaserBlock} class represents a block that can mine blocks. Better lasers will allow you to
 * (1) mine better blocks and (2) mine faster. If you don't have a laser you can't mine.
 * Also, note that lasers are currently the only weapon for combat.
 * @class
 * @typedef {RedLaserBlock}
 * @namespace
 */
var RedLaserBlock = Laser.extend({
	classId: 'RedLaserBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0xF2F2F2;
			this.borderColor = 0xD03F2C;
			this.iconFrame = 'RedLaser.png';

			this.textureBackground = "rgb(242, 242, 242)";
			this.textureOutline = "rgb(208, 63, 44)";
			this.textureSvg = ige.client.textures.redLaser;

			this.laserSpriteName = "RedLaserBeam.svg";
		}

		Laser.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = RedLaserBlock; }
;/**
 * Subclass of the {@link Part} class.
 * The {@link GreenLaserBlock} class represents a block that can mine blocks. Better lasers will allow you to
 * (1) mine better blocks and (2) mine faster. If you don't have a laser you can't mine.
 * Also, note that lasers are currently the only weapons for combat.
 * @class
 * @typedef {GreenLaserBlock}
 * @namespace
 */
var GreenLaserBlock = Laser.extend({
  classId: 'GreenLaserBlock',

  init: function(data) {
    if (!ige.isServer) {
      this.backgroundColor = 0xF2F2F2;
      this.borderColor = 0x30FF2C;
      this.iconFrame = 'GreenLaser.png';

      this.textureBackground = "rgb(242, 242, 242)";
      this.textureOutline = "rgb(30, 200, 30)";
      this.textureSvg = ige.client.textures.greenLaser;

      this.laserSpriteName = "GreenLaserBeam.svg";
    }

    Laser.prototype.init.call(this, data);
  }
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = GreenLaserBlock; }
;/**
 * Subclass of the {@link Part} class.
 * The {@link VioletLaserBlock} class represents a block that can mine blocks. Better lasers will allow you to
 * (1) mine better blocks and (2) mine faster. If you don't have a laser you can't mine.
 * Also, note that lasers are currently the only weapons for combat.
 * @class
 * @typedef {VioletLaserBlock}
 * @namespace
 */
var VioletLaserBlock = Laser.extend({
  classId: 'VioletLaserBlock',

  init: function(data) {
    if (!ige.isServer) {
      this.backgroundColor = 0xF2F2F2;
      this.borderColor = 0xD00FDC;
      this.iconFrame = 'VioletLaser.png';

      this.textureBackground = "rgb(242, 242, 242)";
      this.textureOutline = "rgb(208, 63, 244)";
      this.textureSvg = ige.client.textures.violetLaser;

      this.laserSpriteName = "VioletLaserBeam.svg";
    }

    Laser.prototype.init.call(this, data);
  }
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = VioletLaserBlock; }
;var Armor = Part.extend({
	classId: 'Armor',

	init: function(data) {
		if (ige.isClient) {
			this.textureSvg = ige.client.textures.plating;
		}

		Part.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Armor; }
;/**
 * Subclass of the {@link Element} class. An IronPlatingBlock is the most basic armor
 * block.
 * @class
 * @typedef {Armor} IronPlatingBlock
 * @namespace
 */
var IronPlatingBlock = Armor.extend({
	classId: 'IronPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "IronPlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = IronPlatingBlock; }
;var CloakBlock = Armor.extend({
	classId: 'CloakBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x000000;
			this.borderColor = 0xC8C8C8;
			this.backgroundAlpha = 0.7;
			this.borderAlpha = 0.5;
			this.iconFrame = "TitaniumPlating.png";
			this.textureBackground = "rgba(0, 0, 0, 0.7)";
			this.textureOutline = "rgba(200, 200, 200, 0.5)"
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = CloakBlock; }
;var KryptonitePlatingBlock = Armor.extend({
	classId: 'KryptonitePlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "KryptonitePlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = KryptonitePlatingBlock; }
;var AdamantiumPlatingBlock = Armor.extend({
	classId: 'AdamantiumPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = 'AdamantiumPlating.png';
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = AdamantiumPlatingBlock; }
;var MythrilPlatingBlock = Armor.extend({
	classId: 'MythrilPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "MythrilPlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = MythrilPlatingBlock; }
;var DragonPlatingBlock = Armor.extend({
	classId: 'DragonPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "DragonPlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = DragonPlatingBlock; }
;var TitaniumPlatingBlock = Armor.extend({
	classId: 'TitaniumPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "TitaniumPlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = TitaniumPlatingBlock; }
;var SteelPlatingBlock = Armor.extend({
	classId: 'SteelPlatingBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.iconFrame = "SteelPlating.png";
		}

		Armor.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = SteelPlatingBlock; }
;var Resource = Block.extend({
	classId: "Resource",

	init: function(data) {
		data = this.dataFromConfig(data);
		Block.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Resource;
};/**
 * Subclass of the {@link Element} class. An IronBlock is a basic element.
 * @class
 * @typedef {IronBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var IronBlock = Resource.extend({
	classId: 'IronBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x646464;
			this.borderColor = 0x6E6E6E;
			this.textureBackground = "rgb(100, 100, 100)";
			this.textureOutline = "rgb(110, 110, 110)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = IronBlock;
}
;/**
 * Subclass of the {@link Element} class.
 * @class
 * @typedef {CarbonBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var CarbonBlock = Resource.extend({
	classId: 'CarbonBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x282828;
			this.borderColor = 0x505050;
			this.textureBackground = "rgb(40, 40, 40)";
			this.textureOutline = "rgb(80, 80, 80)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CarbonBlock;
};/**
 * Subclass of the {@link Element} class.
 * @class
 * @typedef {FluorineBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var FluorineBlock = Resource.extend({
	classId: 'FluorineBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x551A8C;
			this.borderColor = 0x262626;
			this.textureBackground = "rgb(85, 26, 140)";
			this.textureOutline = "rgb(38, 38, 38)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = FluorineBlock;
}
;/**
 * Subclass of the {@link Element} class.
 * @class
 * @typedef {CobaltBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var CobaltBlock = Resource.extend({
	classId: 'CobaltBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x0047AB;
			this.borderColor = 0x000080;
			this.textureBackground = "rgb(0, 71, 171)";
			this.textureOutline = "rgb(0, 0, 128)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CobaltBlock;
}
;/**
 * Subclass of the {@link Element} class. A GoldBlock is a rare {@link Element} that may have a high value or good
 * crafting properties.
 * @class
 * @typedef {GoldBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var GoldBlock = Resource.extend({
	classId: 'GoldBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0xFFD700;
			this.borderColor = 0xDAA520;
			this.textureBackground = "rgb(255,215,0)";
			this.textureOutline = "rgb(218,165,32)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = GoldBlock;
}
;/**
 * Subclass of the {@link Element} class. The ice block is special in that it provides little to no nutritional
 * value but it can be mined very easily.
 * @class
 * @typedef {IceBlock}
 * @namespace
 * @todo Use this to craft things.
 */
var IceBlock = Resource.extend({
	classId: 'IceBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x3FAFDD;
			this.borderColor = 0x81CEE2;
			this.backgroundAlpha = 0.3;
			this.textureBackground = "rgba(63, 175, 221, 0.3)";
			this.textureOutline = "rgb(129, 206, 226)";
		}
		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = IceBlock;
}
;/**
* Subclass of the {@link Element} class. An MythrilBlock is a basic element.
* @class
* @typedef {MythrilBlock}
* @namespace
* @todo Use this to craft things.
*/
var MythrilBlock = Resource.extend({
	classId: 'MythrilBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0xC8C8FF;
			this.borderColor = 0xD2D2FF;
			this.textureBackground = "rgb(200, 200, 255)";
			this.textureOutline = "rgb(210, 210, 255)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = MythrilBlock;
}
;/**
* Subclass of the {@link Element} class. An RefinedMythrilBlock is a basic element.
* @class
* @typedef {RefinedMythrilBlock}
* @namespace
* @todo Use this to craft things.
*/
var RefinedMythrilBlock = Resource.extend({
	classId: 'RefinedMythrilBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x3264FF;
			this.borderColor = 0x3232FF;
			this.textureBackground = "rgb(50, 100, 255)";
			this.textureOutline = "rgb(50, 50, 255)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = RefinedMythrilBlock;
}
;/**
* Subclass of the {@link Element} class.
* @class
* @typedef {AdamantiumBlock}
* @namespace
*/
var AdamantiumBlock = Resource.extend({
	classId: 'AdamantiumBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x0E8118;
			this.borderColor = 0x146414;
			this.textureBackground = "rgb(14, 129, 24)";
			this.textureOutline = "rgb(20, 100, 20)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = AdamantiumBlock;
}
;/**
* Subclass of the {@link Element} class.
* @class
* @typedef {DragonBlock}
* @namespace
*/
var DragonBlock = Resource.extend({
	classId: 'DragonBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x770000;
			this.borderColor = 0x780000;
			this.textureBackground = "rgb(119, 0, 0)";
			this.textureOutline = "rgb(140, 0, 0)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = DragonBlock;
}
;/**
* Subclass of the {@link Element} class.
* @class
* @typedef {KryptoniteBlock}
* @namespace
* @todo Use this to craft things.
*/
var KryptoniteBlock = Resource.extend({
	classId: 'KryptoniteBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0x9FF500;
			this.borderColor = 0x6FA700;
			this.backgroundAlpha = 0.8;
			this.textureBackground = "rgba(159, 245, 0, 0.8)";
			this.textureOutline = "rgb(111, 167, 0)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = KryptoniteBlock;
}
;/**
* Subclass of the {@link Element} class.
* @class
* @typedef {SteelBlock}
* @namespace
* @todo Use this to craft things.
*/
var SteelBlock = Resource.extend({
	classId: 'SteelBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0xA0A0A0;
			this.borderColor = 0x505050;
			this.textureBackground = "rgb(160, 160, 160)";
			this.textureOutline = "rgb(80, 80, 80)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = SteelBlock;
}
;/**
* Subclass of the {@link Element} class.
* @class
* @typedef {TitaniumBlock}
* @namespace
* @todo Use this to craft things.
*/
var TitaniumBlock = Resource.extend({
	classId: 'TitaniumBlock',

	init: function(data) {
		if (!ige.isServer) {
			this.backgroundColor = 0xDCDCDC;
			this.borderColor = 0xC8C8C8;
			this.textureBackground = "rgb(220, 220, 220)";
			this.textureOutline = "rgb(200, 200, 200)";
		}

		Resource.prototype.init.call(this, data);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = TitaniumBlock;
}
;/**
 * Subclass of the {@link Block} class. The Element class is handles breaking down into random
 * resources for players to collect.
 * @class
 * @typedef {Element}
 * @namespace
 */
var Element = Block.extend({
	classId: 'Element',

	/**
	 * The type of the resource that dominates this element. Also defines what the element looks
	 * like.
	 */
	_resource: undefined,
	/**
	 * The purity level of this element. Defines distributions and probability of drops.
	 */
	_purity: undefined,

	init: function(data) {
		if (!data) {
			this.log("Element#init: No data passed to constructor.", "error");
		}

		if (!data.resource) {
			this.log("Element#init: No resource data passed to constructor.", "error");
		}

		this.resource(data.resource);

		if (!data.purity) {
			this.log("Element#init: No purity data passed to constructor.", "error");
		}

		this.purity(data.purity);

		data = this.dataFromConfig(data, this.resource());
		data.health = {
			max: Math.ceil(data.health.max * Element.HEALTH_MODIFIERS[this.purity()])
		};

		this.initTextureValues();
		Block.prototype.init.call(this, data);
	},

	childGridHeight: function() {
		// Height and width are the same for now.
		return this.childGridWidth();
	},

	childGridWidth: function() {
		var gridWidth = this.gridData.width;
		if (gridWidth % 2 === 0) {
			return gridWidth / 2;
		}
		else if (gridWidth % 3 === 0) {
			return gridWidth / 3;
		}

		this.log("Element#childGridWidth: Current gridWidth is not divisible by 2 or 3. Is this" +
			" a 1x1 element?", "warning");
	},

	displayName: function() {
		var displayName = cosmos.blocks.instances[this.resource()].displayName();

		if (this.purity() === Element.PURITIES.PURE) {
			displayName = "Pure " + displayName;
		}
		else if (this.purity() === Element.PURITIES.IMPURE) {
			displayName = "Impure " + displayName;
		}
		else {
			displayName = "Very Impure " + displayName;
		}

		return displayName;
	},

	initTextureValues: function() {
		this.backgroundColor = Elements[this.resource()].backgroundColor;
		this.backgroundAlpha = Elements[this.resource()].backgroundAlpha || 1;
		this.borderColor = Elements[this.resource()].borderColor;
		this.borderAlpha = Elements[this.resource()].borderAlpha || 1;
		this.textureBackground = Elements[this.resource()].textureBackground;
		this.textureOutline = Elements[this.resource()].textureOutline;
	},



	_numChildren: function() {
		var gridWidth = this.gridData.width;
		if (gridWidth % 2 === 0) {
			return 4;
		}
		else if (gridWidth % 3 === 0) {
			return 9;
		}

		this.log("Element#_numChildren: Current gridWidth is not divisible by 2 or 3. Is this" +
			" a 1x1 element?", "warning");
	},

	onDeath: function(player) {
		var grid = this.gridData.grid;
		var loc = this.gridData.loc;
		var gridWidth = this.gridData.width;
		var gridHeight = this.gridData.height;

		grid.remove(new IgePoint2d(loc.x, loc.y));

		grid.actions().push({
			action: "remove",
			loc: {
				x: loc.x,
				y: loc.y
			}
		});

		// If this is a 1x1 element, we call
		if (gridWidth === 1 && gridHeight === 1) {
			// TODO: Create the resource that matches this Element and drop it.
			var block = new cosmos.blocks.constructors[this.resource()]();
			var dropCoordinates = grid.worldCoordinatesForBlock(this);
			var newDrop = new Drop({
				owner: player.currentShip(),
				translate: {x: dropCoordinates.x, y: dropCoordinates.y}
			})
				.block(block)
				.streamMode(1)
				.mount(ige.server.spaceGameScene);
			// Emit a new drop event
			player.emit('cosmos:Element.onDeath.newDrop', [newDrop]);
		}
		else {
			var numChildren = this._numChildren();
			var childGridWidth = this.childGridWidth();
			var childGridHeight = this.childGridHeight();

			for (var x = 0; x < gridWidth / childGridWidth; x++) {
				for (var y = 0; y < gridHeight / childGridHeight; y++) {
					var child = Element.randomChild(this);
					grid.put(
						child,
						new IgePoint2d(loc.x + childGridWidth * x,
							loc.y + childGridHeight * y),
						true
					);

					grid.actions().push({
						action: "put",
						block: child.toJSON()
					});
				}
			}
		}
	},

	/**
	 * Getter/setter for purity value.
	 * @param newPurity
	 * @returns {*}
	 */
	purity: function(newPurity) {
		if (newPurity !== undefined) {
			this._purity = newPurity;
			return this;
		}
		return this._purity;
	},

	/**
	 * Getter/setter for resource value.
	 * @param newResource
	 * @returns {*}
	 */
	resource: function(newResource) {
		if (newResource !== undefined) {
			this._resource = newResource;
			return this;
		}
		return this._resource;
	},

	toJSON: function() {
		var json = Block.prototype.toJSON.call(this);
		json.resource = this.resource();
		json.purity = this.purity();

		return json;
	}
});

Element.randomChild = function(parentElement) {
	var resource;
	var purity;
	var gridWidth = parentElement.childGridWidth();
	var gridHeight = parentElement.childGridHeight();

	//First let's figure out if the child is going to have the same resource as the parent
	var probabilityOfBeingTheSameElement;
	if (parentElement.purity() === Element.PURITIES.PURE) {
		probabilityOfBeingTheSameElement = 1;
	} else if (parentElement.purity() === Element.PURITIES.IMPURE) {
		probabilityOfBeingTheSameElement = .80;
	} else if (parentElement.purity() === Element.PURITIES.VERY_IMPURE) {
		probabilityOfBeingTheSameElement = .60;
	}

	if (Math.random() < probabilityOfBeingTheSameElement) {
		// We know that the child element is going to have the same resource as the parent
		resource = parentElement.resource();
		// We now need to figure out what the purity of the child is going to be.
		purity = MathUtils.chooseRandomlyFromArray(
			Element.PURITY_RELATIONSHIPS_FOR_SAME_ELEMENT[parentElement.purity()]
		);
	} else {
		// We know that the child element is going to have a different resource as the parent
		var rarityLevel;
		var randomFloat = Math.random();
		if (randomFloat < Element.RARITIES_PROBABILITY[Element.RARITIES.COMMON]) {
			rarityLevel = Element.RARITIES.COMMON;
		} else if (randomFloat < Element.RARITIES_PROBABILITY[Element.RARITIES.COMMON]
			+ Element.RARITIES_PROBABILITY[Element.RARITIES.UNCOMMON])
		{
			rarityLevel = Element.RARITIES.UNCOMMON;
		} else if (randomFloat < Element.RARITIES_PROBABILITY[Element.RARITIES.COMMON]
			+ Element.RARITIES_PROBABILITY[Element.RARITIES.UNCOMMON]
			+ Element.RARITIES_PROBABILITY[Element.RARITIES.RARE]) //TODO: this repeated addition is pretty inelegant. Find a better way to do this.
		{
			rarityLevel = Element.RARITIES.RARE;
		} else {
			rarityLevel = Element.RARITIES.VERY_RARE;
		}

		var possibleImpurities = Element.RESOURCE_IMPURITIES[parentElement.resource()]
			|| Element.RESOURCE_IMPURITIES['default'];

		resource = possibleImpurities[rarityLevel];

		// We also need to figure out what the purity of the child is going to be.
		purity = MathUtils.chooseRandomlyFromArray(
			Element.PURITY_RELATIONSHIPS_FOR_DIFFERENT_ELEMENT[parentElement.purity()]
		);
	}

	return new Element({
		resource: resource,
		purity: purity,
		gridWidth: gridWidth,
		gridHeight: gridHeight
	});
};

// Enum for element rarities
Element.RARITIES = {
	COMMON: 1,
	UNCOMMON: 2,
	RARE: 3,
	VERY_RARE: 4
};

// Enum for element purities
Element.PURITIES = {
	PURE: 1, // Pure means 91-100% pure
	IMPURE: 2, // Impure means 71-90% pure
	VERY_IMPURE: 3 // Very impure means 51-70% pure
};

Element.RARITIES_PROBABILITY = {};
Element.RARITIES_PROBABILITY[Element.RARITIES.COMMON] = .6;
Element.RARITIES_PROBABILITY[Element.RARITIES.UNCOMMON] = .3;
Element.RARITIES_PROBABILITY[Element.RARITIES.RARE] = .08;
Element.RARITIES_PROBABILITY[Element.RARITIES.VERY_RARE] = .02;

Element.RESOURCE_IMPURITIES = {};
Element.RESOURCE_IMPURITIES['default'] = {};
Element.RESOURCE_IMPURITIES['default'][Element.RARITIES.COMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['default'][Element.RARITIES.UNCOMMON] = 'CarbonBlock';
Element.RESOURCE_IMPURITIES['default'][Element.RARITIES.RARE] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['default'][Element.RARITIES.VERY_RARE] = 'DragonBlock';

Element.RESOURCE_IMPURITIES['CarbonBlock'] = {};
Element.RESOURCE_IMPURITIES['CarbonBlock'][Element.RARITIES.COMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['CarbonBlock'][Element.RARITIES.UNCOMMON] = 'FluorineBlock';
Element.RESOURCE_IMPURITIES['CarbonBlock'][Element.RARITIES.RARE] = 'MythrilBlock';
Element.RESOURCE_IMPURITIES['CarbonBlock'][Element.RARITIES.VERY_RARE] = 'AdamantiumBlock';

Element.RESOURCE_IMPURITIES['DragonBlock'] = {};
Element.RESOURCE_IMPURITIES['DragonBlock'][Element.RARITIES.COMMON] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['DragonBlock'][Element.RARITIES.UNCOMMON] = 'AdamantiumBlock';
Element.RESOURCE_IMPURITIES['DragonBlock'][Element.RARITIES.RARE] = 'MythrilBlock';
Element.RESOURCE_IMPURITIES['DragonBlock'][Element.RARITIES.VERY_RARE] = 'KryptoniteBlock';

Element.RESOURCE_IMPURITIES['AdamantiumBlock'] = {};
Element.RESOURCE_IMPURITIES['AdamantiumBlock'][Element.RARITIES.COMMON] = 'MythrilBlock';
Element.RESOURCE_IMPURITIES['AdamantiumBlock'][Element.RARITIES.UNCOMMON] = 'DragonBlock';
Element.RESOURCE_IMPURITIES['AdamantiumBlock'][Element.RARITIES.RARE] = 'KryptoniteBlock';
Element.RESOURCE_IMPURITIES['AdamantiumBlock'][Element.RARITIES.VERY_RARE] = 'TitaniumBlock';

Element.RESOURCE_IMPURITIES['CobaltBlock'] = {};
Element.RESOURCE_IMPURITIES['CobaltBlock'][Element.RARITIES.COMMON] = 'SteelBlock';
Element.RESOURCE_IMPURITIES['CobaltBlock'][Element.RARITIES.UNCOMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['CobaltBlock'][Element.RARITIES.RARE] = 'MythrilBlock';
Element.RESOURCE_IMPURITIES['CobaltBlock'][Element.RARITIES.VERY_RARE] = 'TitaniumBlock';

Element.RESOURCE_IMPURITIES['FluorineBlock'] = {};
Element.RESOURCE_IMPURITIES['FluorineBlock'][Element.RARITIES.COMMON] = 'AdamantiumBlock';
Element.RESOURCE_IMPURITIES['FluorineBlock'][Element.RARITIES.UNCOMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['FluorineBlock'][Element.RARITIES.RARE] = 'SteelBlock';
Element.RESOURCE_IMPURITIES['FluorineBlock'][Element.RARITIES.VERY_RARE] = 'TitaniumBlock';

Element.RESOURCE_IMPURITIES['GoldBlock'] = {};
Element.RESOURCE_IMPURITIES['GoldBlock'][Element.RARITIES.COMMON] = 'SteelBlock';
Element.RESOURCE_IMPURITIES['GoldBlock'][Element.RARITIES.UNCOMMON] = 'CarbonBlock';
Element.RESOURCE_IMPURITIES['GoldBlock'][Element.RARITIES.RARE] = 'DragonBlock';
Element.RESOURCE_IMPURITIES['GoldBlock'][Element.RARITIES.VERY_RARE] = 'IronBlock';

Element.RESOURCE_IMPURITIES['IronBlock'] = {};
Element.RESOURCE_IMPURITIES['IronBlock'][Element.RARITIES.COMMON] = 'SteelBlock';
Element.RESOURCE_IMPURITIES['IronBlock'][Element.RARITIES.UNCOMMON] = 'CarbonBlock';
Element.RESOURCE_IMPURITIES['IronBlock'][Element.RARITIES.RARE] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['IronBlock'][Element.RARITIES.VERY_RARE] = 'DragonBlock';

Element.RESOURCE_IMPURITIES['KryptoniteBlock'] = {};
Element.RESOURCE_IMPURITIES['KryptoniteBlock'][Element.RARITIES.COMMON] = 'AdamantiumBlock';
Element.RESOURCE_IMPURITIES['KryptoniteBlock'][Element.RARITIES.UNCOMMON] = 'FluorineBlock';
Element.RESOURCE_IMPURITIES['KryptoniteBlock'][Element.RARITIES.RARE] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['KryptoniteBlock'][Element.RARITIES.VERY_RARE] = 'DragonBlock';

Element.RESOURCE_IMPURITIES['MythrilBlock'] = {};
Element.RESOURCE_IMPURITIES['MythrilBlock'][Element.RARITIES.COMMON] = 'CobaltBlock';
Element.RESOURCE_IMPURITIES['MythrilBlock'][Element.RARITIES.UNCOMMON] = 'AdamantiumBlock';
Element.RESOURCE_IMPURITIES['MythrilBlock'][Element.RARITIES.RARE] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['MythrilBlock'][Element.RARITIES.VERY_RARE] = 'DragonBlock';

Element.RESOURCE_IMPURITIES['SteelBlock'] = {};
Element.RESOURCE_IMPURITIES['SteelBlock'][Element.RARITIES.COMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['SteelBlock'][Element.RARITIES.UNCOMMON] = 'CarbonBlock';
Element.RESOURCE_IMPURITIES['SteelBlock'][Element.RARITIES.RARE] = 'GoldBlock';
Element.RESOURCE_IMPURITIES['SteelBlock'][Element.RARITIES.VERY_RARE] = 'CobaltBlock';

Element.RESOURCE_IMPURITIES['TitaniumBlock'] = {};
Element.RESOURCE_IMPURITIES['TitaniumBlock'][Element.RARITIES.COMMON] = 'IronBlock';
Element.RESOURCE_IMPURITIES['TitaniumBlock'][Element.RARITIES.UNCOMMON] = 'CarbonBlock';
Element.RESOURCE_IMPURITIES['TitaniumBlock'][Element.RARITIES.RARE] = 'SteelBlock';
Element.RESOURCE_IMPURITIES['TitaniumBlock'][Element.RARITIES.VERY_RARE] = 'CobaltBlock';

// PURITY_RELATIONSHIPS tells you what each purity can turn into
Element.PURITY_RELATIONSHIPS_FOR_SAME_ELEMENT = {};
Element.PURITY_RELATIONSHIPS_FOR_SAME_ELEMENT[Element.PURITIES.PURE] =
	[Element.PURITIES.PURE, Element.PURITIES.PURE, Element.PURITIES.IMPURE];

Element.PURITY_RELATIONSHIPS_FOR_SAME_ELEMENT[Element.PURITIES.IMPURE] =
	[
		Element.PURITIES.PURE,
		Element.PURITIES.IMPURE,
		Element.PURITIES.IMPURE,
		Element.PURITIES.VERY_IMPURE
	];

Element.PURITY_RELATIONSHIPS_FOR_SAME_ELEMENT[Element.PURITIES.VERY_IMPURE] =
	[Element.PURITIES.IMPURE, Element.PURITIES.VERY_IMPURE, Element.PURITIES.VERY_IMPURE];

Element.PURITY_RELATIONSHIPS_FOR_DIFFERENT_ELEMENT = {};
Element.PURITY_RELATIONSHIPS_FOR_DIFFERENT_ELEMENT[Element.PURITIES.PURE] = [];
Element.PURITY_RELATIONSHIPS_FOR_DIFFERENT_ELEMENT[Element.PURITIES.IMPURE] =
	[Element.PURITIES.IMPURE, Element.PURITIES.VERY_IMPURE];
Element.PURITY_RELATIONSHIPS_FOR_DIFFERENT_ELEMENT[Element.PURITIES.VERY_IMPURE] =
	[Element.PURITIES.VERY_IMPURE];

Element.HEALTH_MODIFIERS = {};
Element.HEALTH_MODIFIERS[Element.PURITIES.PURE] = 2;
Element.HEALTH_MODIFIERS[Element.PURITIES.IMPURE] = 1.5;
Element.HEALTH_MODIFIERS[Element.PURITIES.VERY_IMPURE] = 1;

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Element;
}
;/**
 * Subclass of the {@link IgeEntity} class. Defines the entity for the laser beam that is displayed when a
 * {@link Player} mines a {@link Block}.
 * @class
 * @typedef {LaserBeam}
 * @namespace
 */
var LaserBeam = IgeEntity.extend({
	classId: 'LaserBeam',

	/*
	 * This is the block that's firing the laser
	 */
	_source: undefined,

	_targetX: undefined,
	_targetY: undefined,

	init: function (data) {
		IgeEntity.prototype.init.call(this);

		if (data && data.source) {
			this.setSource(data.source);

			var self = this;
			this.addComponent(LaserBeamRenderableComponent,
				{
					createDisplayObject: function () {
						var sprite = PIXI.Sprite.fromFrame(self._source.laserSpriteName);
						sprite.width = 10;
						sprite.anchor.set(0.5);
						return sprite;
					}
				}
			);

			if (!ige.isServer) {
				// Fade in the laser beam
				this.opacity(0);
				this._fadeInTween();
			}
		}
	},

	/**
	 * Sets the tween on this entity so that it appears to fade in.
	 * Note: Old sweeping laser tween is in commit c4192b5d5a7ee840a688744c8e6ad92fb2a97e51
	 * @returns {LaserBeam} Returns this object to make setter call chaining convenient.
	 * @memberof LaserBeam
	 * @private
	 */
	_fadeInTween: function () {
		this.tween()
			.targetObj(this.renderable)
			.stepTo({_opacity: 1}, 1000, 'inOutCubic')
			.start();

		if (this.pixiRenderable) {
			this.tween()
				.targetObj(this.pixiRenderable)
				.stepTo({_opacity: 1}, 1000, 'inOutCubic')
				.start();
		}

		return this;
	},

	setSource: function(block) {
		this._source = block;
		return this;
	},

	/**
	 * Sets the location of the targeted block.
	 * @param blockGridId {string} The IGE ID of the {@link BlockGrid} we are targeting
	 * @param row {number} The row of the {@link Block} we are targeting in its {@link BlockGrid}.
	 * @param col {number} The col of the {@link Block} we are targeting in its {@link BlockGrid}.
	 * @memberof LaserBeam
	 * @instance
 	 */
	setTarget: function(x, y) {
		this._targetX = x;
		this._targetY = y;
		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = LaserBeam; }
;/**
 * Subclass of the {@link IgeParticle} class. This is the actual particle generated by the ablation of the surface of a
 * block by your laser.
 * It is a small red square.
 * @class
 * @typedef {LaserParticle}
 * @namespace
 */
var LaserParticle = IgeParticle.extend({
	classId: 'LaserParticle',

	/**
	 * Overrides the superclass color value to change the color of the particles.
	 * This is an orange color.
	 * @type {string}
	 * @memberof LaserParticle
	 * @private
	 * @instance
	 */
	_color: '#ff5a00',

	init: function(emitter) {
		this._emitter = emitter;
		IgeParticle.prototype.init.call(this);

		this.addComponent(ParticleRenderableComponent, {createDisplayObject: function() {
			var particle = new PIXI.Graphics();
			particle.beginFill(0xff5a00);
			particle.drawRect(0, 0, 7, 7);
			particle.endFill();

			return particle;
		}});

		this.texture(ige.client.textures.rectangleTexture)
			.width(7)
			.height(7);
	},

});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = LaserParticle; }
;/**
 * Subclass of the {@link IgeParticle} class. Defines the what the particles emitted by {@link EngineBlock}s should
 * look like.
 * @class
 * @typedef {EngineParticle}
 * @namespace
 */
var EngineParticle = IgeParticle.extend({
	classId: 'EngineParticle',

	/**
	 * Overrides the superclass color value to change the color of the particles.
	 * This is a light blue color.
	 * @type {string}
	 * @memberof EngineParticle
	 * @private
	 * @instance
	 */
	_color: '#ccffff',

	init: function(emitter) {
		this._emitter = emitter;
		IgeParticle.prototype.init.call(this);

		this.addComponent(ParticleRenderableComponent, {createDisplayObject: function() {
			var particle = new PIXI.Graphics();
			particle.beginFill(0xccffff);
			particle.drawRect(0, 0, 10, 10);
			particle.endFill();

			return particle;
		}});

		this.texture(ige.client.textures.rectangleTexture)
			.width(10)
			.height(10)
	},

});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = EngineParticle; }
;/**
 * Subclass of the {@link IgeParticleEmitter}. Customizes the particle emitter to output the particle effects that are
 * displayed on a {@link Block} when a {@link Player} mines a {@link Block}.
 * @class
 * @typedef {BlockParticleEmitter}
 * @namespace
 * @todo Should probably rename this to something sensible
 */
var BlockParticleEmitter = IgeParticleEmitter.extend({
	classId: 'BlockParticleEmitter',

	init: function (emitter) {
		IgeParticleEmitter.prototype.init.call(this);

		if (!ige.isServer) {
			// Set the particle entity to generate for each particle
			this.particle(LaserParticle)
				// Set particle life to 300ms
				.lifeBase(300)
				// Set output to 60 particles a second (1000ms)
				.quantityBase(60)
				.quantityTimespan(1000)
				// Set the particle's death opacity to zero so it fades out as it's lifespan runs out
				.deathOpacityBase(0)
				// Set velocity vector to y = 0.05, with variance values
				//.velocityVector(new IgePoint3d(0, 0.05, 0), new IgePoint3d(-0.04, 0.05, 0), new IgePoint3d(0.04, 0.15, 0))
				.translateVarianceY(-10, 10)
				.translateVarianceX(-10, 10)
				// Mount new particles to the object scene
				.particleMountTarget(ige.client.effectsScene)
				.start()
		}
	},

});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = BlockParticleEmitter; }
;/**
 * Subclass of the {@link IgeEntity} class. Instantiates a texture which displays as an oscillating glow effect. Can be
 * used to create a glow effect around other entities.
 * @class
 * @typedef {IgeEntity} GlowEffect
 * @namespace
 */
var GlowEffect = IgeEntity.extend({
	classId: 'GlowEffect',

	/**
	 * The maximum value of the shadow blur effect. Defines how "big" the glow gets.
	 * @type {number}
	 * @memberof GlowEffect
	 * @instance
	 */
	maxShadowBlur: undefined,
	/**
	 * The minimum value of the shadow blur effect. Defines how "small" the glow gets.
	 * @type {number}
	 * @memberof GlowEffect
	 * @instance
	 */
	minShadowBlur: undefined,
	/**
	 * The step size for the oscillation of the glow effect. Basically defines how quickly the glow oscillates.
	 * @type {number}
	 * @memberof GlowEffect
	 * @instance
	 */
	shadowBlurStep: undefined,
	/**
	 * The current shadow blur value. Updated by the GlowEffectTexture by the
	 * {@link GlowEffect#shadowBlurStep|shadowBlurStep} on each draw.
	 * @type {number}
	 * @memberof GlowEffect
	 * @instance
	 */
	shadowBlur: undefined,
	/**
	 * Whether or not the shadow blur value is increasing or decreasing. When this value is set to true, the shadow
	 * blur value is decreasing.
	 * @type {boolean}
	 * @memberof GlowEffect
	 * @instance
	 */
	decrementingShadowBlur: undefined,

	init: function(data) {
		IgeEntity.prototype.init.call(this, data);

		if (!ige.isServer) {
			this.height((data && data.height) || GlowEffect.DEFAULT_HEIGHT);
			this.width((data && data.width) || GlowEffect.DEFAULT_WIDTH);
			this.maxShadowBlur = (data && data.maxShadowBlur) || GlowEffect.DEFAULT_MAX_SHADOW_BLUR;
			this.minShadowBlur = (data && data.minShadowBlur) || GlowEffect.DEFAULT_MIN_SHADOW_BLUR;
			this.shadowBlurStep = (data && data.shadowBlurStep) || GlowEffect.DEFAULT_SHADOW_BLUR_STEP;
			this.shadowBlur = (data && data.startShadowBlur) || GlowEffect.DEFAULT_START_SHADOW_BLUR;
			this.shadowColor = (data && data.shadowColor) || GlowEffect.DEFAULT_SHADOW_COLOR;
			this.decrementingShadowBlur = (data && data.decrementingShadowBlur) || true;
			this.textureBackground = (data && data.textureBackground) || GlowEffect.DEFAULT_TEXTURE_BACKGROUND;
			//this.texture(ige.client.textures.glow);
			// TODO: Add a PixiRenderableComponent for Glow Effect
		}
	}
});

/**
 * Default height of a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_HEIGHT = Block.HEIGHT;
/**
 * Default width of a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_WIDTH = Block.WIDTH;
/**
 * Default maximum shadow blur value for a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_MAX_SHADOW_BLUR = 75;
/**
 * Default minimum shadow blur value for a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_MIN_SHADOW_BLUR = 25;
/**
 * Default step size for the shadow blur of a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_SHADOW_BLUR_STEP = 2;
/**
 * Default shadow color for a {@link GlowEffect} entity.
 * @constant {string}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_SHADOW_COLOR = 'white';
/**
 * Default starting value for the shadow blur of a {@link GlowEffect} entity.
 * @constant {number}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_START_SHADOW_BLUR = GlowEffect.DEFAULT_MAX_SHADOW_BLUR;
/**
 * Default fill color for the {@link GlowEffect}. Note: shadow blurs do not show unless there is a fill. They also
 * don't show if the fill color alpha is set to 0. This makes drawing the glow effect independently of a fill difficult,
 * but in most cases the fill is hidden behind the Block's texture.
 * @todo Ultimately, the right thing to do is probably use some sort of canvas clipping and offset to hide the fill but
 * still display the shadow.
 * @constant {string}
 * @default
 * @memberof GlowEffect
 */
GlowEffect.DEFAULT_TEXTURE_BACKGROUND = 'rgb(255, 255, 255)';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = GlowEffect; }
;/**
 * @class
 * @typedef {HealthBar}
 * @namespace
 */
var HealthBar = IgeEntity.extend({
	classId: 'HealthBar',

	/**
	 * The block associated with this health bar
	 * @type {Block}
	 * @memberof HealthBar
	 * @private
	 * @instance
	 */
	_block: undefined,

	init: function(block) {
		IgeEntity.prototype.init.call(this);
		this._block = block;

		this.addComponent(HealthBarRenderableComponent, {
			createDisplayObject: function() {
				return new PIXI.Graphics();
			},
			anchor: new IgePoint2d(-block.width() / 2, -block.height() / 2)
		});
	}

});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = HealthBar; }
;/**
 * The ExampleShips class has some prefabricated ships that can be used for creating players or just for testing.
 * @class
 * @namespace
 */
var ExampleShips = {
	/**
	 * This is the ship in beginning of the video. This ships contains pretty much the minimum amount that a player
	 * needs to get started.
	 * @retruns {Array} A {@link Block} matrix that represents the starter ship.
	 * @memberof ExampleShips
	 */
	starterShip: function() {
		return [
			[undefined,           undefined,   new RedLaserBlock(), undefined,   undefined],
			[undefined,           new IronPlatingBlock(), new IronPlatingBlock(),            new IronPlatingBlock(), undefined],
			[undefined,           new IronPlatingBlock(), new BridgeBlock(),     new IronPlatingBlock(), undefined],
			[undefined,           new IronPlatingBlock(), new IronPlatingBlock(),       new IronPlatingBlock(), undefined],
			[new IronThrusterBlock(), new IronPlatingBlock(), new IronPlatingBlock(),         new IronPlatingBlock(), new IronThrusterBlock()],
			[undefined,           new IronPlatingBlock(), new IronPlatingBlock(),         new IronPlatingBlock(), undefined],
			[undefined,           new IronPlatingBlock(), new IronEngineBlock(),          new IronPlatingBlock(), undefined]
		]
	},

	/**
	 * This is the ship in the middle of the video. It has two engines, but one of them is misplaced and unbalanced.
	 * @returns {Array} A {@link Block} matrix that represents the starter ship with two, unbalanced engines.
	 * @memberof ExampleShips
	 */
	starterShipSingleMisplacedEngine: function() {
		return [
			[undefined,           undefined,         new RedLaserBlock(), undefined,         undefined],
			[undefined,           new SteelPlatingBlock(),       new SteelPlatingBlock(),            new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new BridgeBlock(),     new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),       new SteelPlatingBlock(),       undefined],
			[new IronThrusterBlock(), new SteelPlatingBlock(),       new IronPlatingBlock(),         new SteelPlatingBlock(),       new IronThrusterBlock()],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),         new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),          new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new IronEngineBlock(),      new SteelPlatingBlock(),       undefined],
			[undefined,           new IronEngineBlock(), undefined,              undefined,         undefined]
		]
	},

	/**
	 * This is the ship at the end of the video. It has two, balanced engines at the bottom.
	 * @returns {Array} A {@link Block} matrix that represents the starter ship with two balanced engines on the bottom.
	 * @memberof ExampleShips
	 */
	starterShipDoubleEngines: function() {
		return [
			[undefined,           undefined,         new RedLaserBlock(), undefined,         undefined],
			[undefined,           new SteelPlatingBlock(),       new SteelPlatingBlock(),            new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new BridgeBlock(),     new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),       new SteelPlatingBlock(),       undefined],
			[new IronThrusterBlock(), new SteelPlatingBlock(),       new IronPlatingBlock(),         new SteelPlatingBlock(),       new IronThrusterBlock()],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),         new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       new IronPlatingBlock(),          new SteelPlatingBlock(),       undefined],
			[undefined,           new SteelPlatingBlock(),       undefined,              new SteelPlatingBlock(),       undefined],
			[undefined,           new IronEngineBlock(), undefined,              new IronEngineBlock(), undefined]
		]
	},

	/**
	 * A ship that has all the weapons. Purely for testing.
	 * @retruns {Array} A {@link Block} matrix that represents this ship.
	 * @memberof ExampleShips
	 */
	starterShipWithAllWeapons: function() {
		return [
			[undefined,           		new RedLaserBlock(),		 new GreenLaserBlock(), 		new VioletLaserBlock(),  undefined],
			[undefined,           		new SteelPlatingBlock(), new SteelPlatingBlock(),   new SteelPlatingBlock(), undefined],
			[undefined,           		new SteelPlatingBlock(), new BridgeBlock(),     		new SteelPlatingBlock(), undefined],
			[undefined,           		new SteelPlatingBlock(), new IronPlatingBlock(),       		new SteelPlatingBlock(), undefined],
			[new IronThrusterBlock(), new SteelPlatingBlock(), new IronPlatingBlock(),         		new SteelPlatingBlock(), new IronThrusterBlock()],
			[undefined,           		new SteelPlatingBlock(), new IronPlatingBlock(),         		new SteelPlatingBlock(), undefined],
			[undefined,           		new SteelPlatingBlock(), new IronPlatingBlock(),          		new SteelPlatingBlock(), undefined],
			[undefined,           		new SteelPlatingBlock(), new IronEngineBlock(),     new SteelPlatingBlock(), undefined]
		]
	},

	/**
	 * This is an empty ship for use in testing.
	 * @returns {Array} A {@link Block} matrix that contains nothing but undefined's.
	 * @memberof ExampleShips
	 */
	emptyShip: function() {
		return [
			[undefined, undefined, undefined, undefined, undefined],
			[undefined, undefined, undefined, undefined, undefined],
			[undefined, undefined, undefined, undefined, undefined],
			[undefined, undefined, undefined, undefined, undefined],
			[undefined, undefined, undefined, undefined, undefined]
		];
	},

	/**
	 * Returns a ship that consists of just an engine. Useful for testing purposes.
	 * @returns {Array} A {@link Block} matrix that contains just an {@link IronEngineBlock}.
	 * @memberof ExampleShips
	 */
	justAnEngine: function() {
		return [
			[new IronEngineBlock()]
		];
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ExampleShips; }
;/**
 * Use the ParallaxBackground class for parallax effect in-game backgrounds.
 * @class
 * @typedef {Object} ParallaxBackground
 * @namespace
 */
var ParallaxBackground = IgeEntity.extend({
	classId: "ParallaxBackground",

	/**
	 * Magnitude of parallax lag.
	 * Low value: Background is static.
	 * Intermediate value (2-10): Background lags behind camera (typically what
	 * you want).
	 * High value: Background moves with camera.
	 * @type {number}
	 * @memberof ParallaxBackground
	 * @private
	 * @instance
	 */
	_parallaxLag: 1,

	init: function() {
		var self = this;
		if (ige.isClient) {
			this.addComponent(ParallaxBackgroundRenderableComponent, {createDisplayObject: function() {
				var background = new PIXI.Sprite(self.backgroundTexture);
				background.height = self.backgroundHeight;
				background.width = self.backgroundWidth;
				background.position.x = -background.width / 2;
				background.position.y = -background.height / 2;

				return background;
			}});
		}

		IgeEntity.prototype.init.call(this);
	},

	/**
	 * Getter/setter for the parallaxLag property.
	 * @param val {number} Optional parameter. If set, this is the new
	 * parallaxLag
	 * @returns {*} parallaxLag value if no parameter is passed or this object if a
	 * parameter is passed to make setter chaining convenient.
	 * @memberof ParallaxBackground
	 * @instance
	 */
	parallaxLag: function(val) {
		return this.renderable.parallaxLag(val);
		if (val !== undefined) {
			this.pixiRenderable._parallaxLag = val;
			return this;
		}
		return this._parallaxLag;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ParallaxBackground; }
;/**
 * A {@link ParallaxBackground} which represents the nebula background of the game.
 * @class
 * @typedef {Background}
 * @namespace
 */
var Background = ParallaxBackground.extend({
	classId: 'Background',

	textureName: undefined,

	init: function (data) {
		if (data.texture !== undefined) {
			this.textureName = data.textureName;
		}

		if (ige.isClient) {
			this.backgroundTexture = PIXI.TextureCache[data.textureName];
			this.backgroundHeight = this.backgroundWidth = 1024;//TODO use the constant for this
		}

		ParallaxBackground.prototype.init.call(this);

		if (ige.isClient) {
			this
				.texture(ige.client.textures[data.textureName])
				.width(1024)
				.height(1024);
		}
	},

	streamCreateData: function() {
		var data = ParallaxBackground.prototype.streamCreateData.call(this);

		data.textureName = this.textureName;

		return data;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Background; }
;/**
 * A {@link ParallaxBackground} which represents the starfield background of the
 * game. This is in front of the nebula background.
 * @class
 * @typedef {StarfieldBackground}
 * @namespace
 */
var StarfieldBackground = ParallaxBackground.extend({
	classId: 'StarfieldBackground',

	init: function () {
		if (ige.isClient) {
			this.backgroundTexture = PIXI.TextureCache.background_starfield;
			this.backgroundHeight = this.backgroundWidth = 6000;
		}

		ParallaxBackground.prototype.init.call(this);

		if (ige.isClient) {
			this.texture(ige.client.textures.background_starfield)
				.width(6000)
				.height(6000)
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = StarfieldBackground; }
;/**
 * The ClickScene is a scene that intercepts all clicks on the background.
 * Think of it like a catch-all for all clicks that aren't intercepted by an actual entity above this scene.
 * @class
 * @typedef {ClickScene}
 * @namespace
 */
var ClickScene = IgeScene2d.extend({
	classId: 'ClickScene',

	init: function () {
		IgeScene2d.prototype.init.call(this);
		this.ignoreCamera(true);
		this.mouseDown(this._mouseDownHandler);
	},

	/**
	 * Handles mouse clicks on the ClickScene. Sends a message to the server about where in the game a mouse click has
	 * occurred.
	 * @param event {Object} The event object associated with the click.
	 * @param control {Object} The control object associated with the click.
	 * @memberof ClickScene
	 * @private
	 * @instance
	 */
	_mouseDownHandler: function(event, control) {
		var data = {
			x: this.mousePosWorld().x,
			y: this.mousePosWorld().y
		};

		// TODO: Extend when clientState supports multiple current capabilities
		if (ige.client.state !== undefined) {
			ige.client.state.currentCapability().tryPerformAction(this, event, data);
		}

		ige.emit('cosmos:background.mousedown');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {	module.exports = ClickScene; }
;/*
 * Note that all weapons have the same cooldown right now because
 * the controls for firing weapons don't yet take into account weapons
 * with different cooldowns in a reasonable way.
 */

var DamageSources = {};

/*
 * The red laser is the most basic weapon in the game right now
 */
DamageSources[RedLaserBlock.prototype.classId()] = {
	cooldown: 1000,
	damage: 40,
	duration: 2000,
	range: 600
};

/*
 * The green laser does more damage and has a slightly greater
 * range than the red laser
 */
DamageSources[GreenLaserBlock.prototype.classId()] = {
	cooldown: 1000,
	damage: 60,
	duration: 2000,
	range: 800
};

/*
 * The violet laser does more damage
 * and has a slightly greater range than the green laser
 */
DamageSources[VioletLaserBlock.prototype.classId()] = {
	cooldown: 1000,
	damage: 80,
	duration: 2000,
	range: 1000
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = DamageSources;
}
;var Descriptions = {};

/* === BLOCKS === */
Descriptions[Block.prototype.classId()] =
{
	text: 'A basic block with no special properties.'
};

/* === ARMOR BLOCKS === */
Descriptions[Armor.prototype.classId()] =
{
	text: 'An armor block. Useful for protecting important parts of your ship.'
};

Descriptions[AdamantiumPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text
};

Descriptions[CloakBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + " Doesn't actually cloak your ship."
};

Descriptions[DragonPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + " Forged from the hide of a space-dragon. Provides extra defense against fire."
};

Descriptions[IronPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + ""
};

Descriptions[KryptonitePlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + " Provides extra defense against super-humans."
};

Descriptions[MythrilPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + " There was once a myth about this block. But you've forgotten what it was."
};

Descriptions[SteelPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text
};

Descriptions[TitaniumPlatingBlock.prototype.classId()] =
{
	text: Descriptions[Armor.prototype.classId()].text + " Not only that, it sells for over $1k per kg on the open market."
};






/* === Elements === */
Descriptions[Element.prototype.classId()] =
{
	text: 'An element block with no special properties (yet). Use these to shield your ship or to decorate your ship with ' +
		'interesting colors and patterns.'
};

Descriptions[CarbonBlock.prototype.classId()] =
{
	text: "Carbon comes from decayed organic matter. It's an important reactant for making many common ship parts."
};

Descriptions[CobaltBlock.prototype.classId()] =
{
	text: "Cobalt is natually found in many asteroids. It has been used as a blue pigment since ancient times, and has recently been used to tint metals and glass." +
		" Use Cobalt to shield your ship or to decorate your ship with interesting colors and patterns."
};

Descriptions[FluorineBlock.prototype.classId()] =
{
	text: "Fluorine occurs natually in many toothpastes and mouth rinses. It's use is still not well understood."+
		" Use Fluorine to shield your ship or to decorate your ship with interesting colors and patterns."
};

Descriptions[GoldBlock.prototype.classId()] =
{
	text: "Gold is one of the best natually-occurring conductors. Gold is an important reactant for many electronics including lasers."
};

Descriptions[IceBlock.prototype.classId()] =
{
	text: "Ice is one of the only sources of water in the cold of space."
};

Descriptions[IronBlock.prototype.classId()] =
{
	text: "Iron is the primary component of most asteroids. It is also the basic metal out of which many basic ship-parts are created."
};

Descriptions[DragonBlock.prototype.classId()] =
{
	text: "The essential remains of space dragons. Dragon can be used to craft advanced engines and armor."
};

Descriptions[AdamantiumBlock.prototype.classId()] =
{
	text: "Wolverine's favorite element. Adamantium is an extremely strong metal."
};


Descriptions[KryptoniteBlock.prototype.classId()] =
{
	text: "Kryptonite is a not-yet-understood element that radiates a disruptive magnetic field. It can be used to craft advanced thrusters."
};

Descriptions[SteelBlock.prototype.classId()] =
{
	text: "Steel is tempered form of iron, strengthed by added carbon. Steel is a basic building block of many ship-parts."
};

Descriptions[TitaniumBlock.prototype.classId()] =
{
	text: "Titanium is one of the strongest metals known to man. It can be used to build advanced defense systems."
};

Descriptions[MythrilBlock.prototype.classId()] =
{
	text: "Mythril is a rare and strong metal."
};

Descriptions[RefinedMythrilBlock.prototype.classId()] =
{
	text: "Refined Mythril is ready to be crafted into useful ship-parts."
};






/* === Parts === */
Descriptions[Part.prototype.classId()] =
{
	text: 'A ship part block with no special properties (yet).'
};

Descriptions[BridgeBlock.prototype.classId()] =
{
	text: "The Bridge is the most important block in your ship. If you lose your bridge you'll have to get a new ship."
};

/* Engines */
Descriptions[IronEngineBlock.prototype.classId()] =
{
	text: 'Engines allow your ship to move forward and backwards. The more engines your ship has, the faster ' +
		'it will move. If you have no engines, your ship cannot move forward or backwards. As you place more blocks '+
		'on your ship, your ship will become heavier and you will need more Engines in order to fly at the same ' +
		'speed as before. Additionally, if you place engines on your ship in a lopsided manner, your ship will not ' +
		'fly straight.'
};

Descriptions[SteelEngineBlock.prototype.classId()] =
{
	text: "An engine with more strength and durability than the Iron Engine."
};

Descriptions[DragonBreathEngineBlock.prototype.classId()] =
{
	text: 'Forged from the remains of a space dragon, this engine is a significant improvement over the basic Iron ' +
		'Engine.'
};

/* Thrusters */
Descriptions[IronThrusterBlock.prototype.classId()] =
{
	text: 'Thrusters allow your ship to rotate left and right. The more thrusters your ship has, the faster ' +
		'it can rotate. If you have no thrusters, your ship cannot rotate. As you place more blocks on your ship, ' +
		'your ship will become heavier and you will need more thrusters in order to rotate at the same speed as ' +
		'before.'
};

Descriptions[SteelThrusterBlock.prototype.classId()] =
{
	text: "A thruster with more strength and durability than the Iron Thruster."
};

Descriptions[KryptoniteThrusterBlock.prototype.classId()] =
{
	text: "A thruster that moves so fast that even Super Man couldn't get away."
};

/* === WEAPONS === */
Descriptions[Weapon.prototype.classId()] =
{
	text: 'A weapon block which can deal damage to other blocks.'
};

Descriptions[RedLaserBlock.prototype.classId()] =
{
	text: 'This laser is the most basic weapon in the game. Use it to break blocks off of structures ' +
		'and ships. If you lose your laser, you will not be able to shoot.'
};
Descriptions[GreenLaserBlock.prototype.classId()] =
{
	text: 'This bright emerald-colored laser is more powerful than the Red Laser.'
};
Descriptions[VioletLaserBlock.prototype.classId()] =
{
	text: 'This beautiful Amethyst-colored laser is one of the most powerful lasers known to man.' +
		'It can cut through meter-thick steel like a hot knife through butter.'
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Descriptions
}
;var Elements = {};

// TODO: textureBackground and textureOutline are legacy so that IGE texture rendering continues
// to work. This will be removed soon.
Elements[AdamantiumBlock.prototype.classId()] = {
	backgroundColor: 0x0E8118,
	borderColor: 0x146414,
	textureBackground: "rgb(14, 129, 24)",
	textureOutline: "rgb(20, 100, 20)"
};

Elements[CarbonBlock.prototype.classId()] = {
	backgroundColor: 0x282828,
	borderColor: 0x505050,
	textureBackground: "rgb(40, 40, 40)",
	textureOutline: "rgb(80, 80, 80)"
};

Elements[CobaltBlock.prototype.classId()] = {
	backgroundColor: 0x0047AB,
	borderColor: 0x000080,
	textureBackground: "rgb(0, 71, 171)",
	textureOutline: "rgb(0, 0, 128)"
};

Elements[DragonBlock.prototype.classId()] = {
	backgroundColor: 0x770000,
	borderColor: 0x780000,
	textureBackground: "rgb(119, 0, 0)",
	textureOutline: "rgb(120, 0, 0)"
};

Elements[FluorineBlock.prototype.classId()] = {
	backgroundColor: 0x551A8C,
	borderColor: 0x262626,
	textureBackground: "rgb(85, 26, 140)",
	textureOutline: "rgb(38, 38, 38)"
};

Elements[GoldBlock.prototype.classId()] = {
	backgroundColor: 0xFFD700,
	borderColor: 0xDAA520,
	textureBackground: "rgb(255,215,0)",
	textureOutline: "rgb(218,165,32)"
};

Elements[IceBlock.prototype.classId()] = {
	backgroundColor: 0x3FAFDD,
	borderColor: 0x81CEE2,
	backgroundAlpha: 0.3,
	textureBackground: "rgba(63, 175, 221, 0.3)",
	textureOutline: "rgb(129, 206, 226)"
};

Elements[IronBlock.prototype.classId()] = {
	backgroundColor: 0x646464,
	borderColor: 0x6E6E6E,
	textureBackground: "rgb(100, 100, 100)",
	textureOutline: "rgb(110, 110, 110)"
};

Elements[KryptoniteBlock.prototype.classId()] = {
	backgroundColor: 0x9FF500,
	borderColor: 0x6FA700,
	backgroundAlpha: 0.8,
	textureBackground: "rgba(159, 245, 0, 0.8)",
	textureOutline: "rgb(111, 167, 0)"
};

Elements[MythrilBlock.prototype.classId()] = {
	backgroundColor: 0xC8C8FF,
	borderColor: 0xD2D2FF,
	textureBackground: "rgb(200, 200, 255)",
	textureOutline: "rgb(210, 210, 255)"
};

Elements[SteelBlock.prototype.classId()] = {
	backgroundColor: 0xA0A0A0,
	borderColor: 0x505050,
	textureBackground: "rgb(160, 160, 160)",
	textureOutline: "rgb(80, 80, 80)"
};

Elements[TitaniumBlock.prototype.classId()] = {
	backgroundColor: 0xDCDCDC,
	borderColor: 0xC8C8C8,
	textureBackground: "rgb(220, 220, 220)",
	textureOutline: "rgb(200, 200, 200)"
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Elements;
}
;var GridDimensions = {};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = GridDimensions;
}
;var Healths = {};




/* === PARTS === */
Healths[BridgeBlock.prototype.classId()] =
{
	max: 45
};

/* Armor */
Healths[IronPlatingBlock.prototype.classId()] =
{
	max: 40
};

Healths[SteelPlatingBlock.prototype.classId()] =
{
	max: 50
};

Healths[CloakBlock.prototype.classId()] =
{
	max: 60
};

Healths[KryptonitePlatingBlock.prototype.classId()] =
{
	max: 65
};

Healths[TitaniumPlatingBlock.prototype.classId()] =
{
	max: 70
};

Healths[MythrilPlatingBlock.prototype.classId()] =
{
	max: 90
};

Healths[AdamantiumPlatingBlock.prototype.classId()] =
{
	max: 150
};

Healths[DragonPlatingBlock.prototype.classId()] =
{
	max: 500
};


/* Engines */
Healths[IronEngineBlock.prototype.classId()] =
{
	max: 40
};

Healths[SteelEngineBlock.prototype.classId()] =
{
	max: 50
};

Healths[DragonBreathEngineBlock.prototype.classId()] =
{
	max: 60
};

/* Thrusters */

Healths[IronThrusterBlock.prototype.classId()] =
{
	max: 40
};

Healths[SteelThrusterBlock.prototype.classId()] =
{
	max: 50
};

Healths[KryptoniteThrusterBlock.prototype.classId()] =
{
	max: 60
};

/* Weapons */

Healths[RedLaserBlock.prototype.classId()] =
{
	max: 50
};
Healths[GreenLaserBlock.prototype.classId()] =
{
	max: 60
};
Healths[VioletLaserBlock.prototype.classId()] =
{
	max: 80
};


/* === ELEMENTS === */
Healths[IceBlock.prototype.classId()] =
{
	max: 8
};

Healths[CarbonBlock.prototype.classId()] =
{
	max: 10
};


Healths[GoldBlock.prototype.classId()] =
{
	max: 20
};

Healths[CobaltBlock.prototype.classId()] =
{
	max: 20
};

Healths[FluorineBlock.prototype.classId()] =
{
	max: 20
};

Healths[IronBlock.prototype.classId()] =
{
	max: 25
};

Healths[SteelBlock.prototype.classId()] =
{
	max: 30
};

Healths[KryptoniteBlock.prototype.classId()] =
{
	max: 35
};

Healths[TitaniumBlock.prototype.classId()] =
{
	max: 40
};


Healths[MythrilBlock.prototype.classId()] =
{
	max: 50
};

Healths[RefinedMythrilBlock.prototype.classId()] =
{
	max: 60
};


Healths[AdamantiumBlock.prototype.classId()] =
{
	max: 60
};


Healths[DragonBlock.prototype.classId()] =
{
	max: 70
};


if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Healths; }
;var Recipes = {};




/* === PARTS === */

/* === Engines === */

Recipes[IronEngineBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronBlock.prototype.classId(),
			quantity: 2
		},
		{
			blockType: IceBlock.prototype.classId(),
			quantity: 2
		}
	],
	equipment: []
};

Recipes[SteelEngineBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronEngineBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: SteelBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};

Recipes[DragonBreathEngineBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: SteelEngineBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: DragonBlock.prototype.classId(),
			quantity: 2
		}
	],
	equipment: []
};

/* === Thrusters === */

Recipes[IronThrusterBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronBlock.prototype.classId(),
			quantity: 3
		},
		{
			blockType: CarbonBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: IceBlock.prototype.classId(),
			quantity: 3
		}
	],
	equipment: []
};

Recipes[SteelThrusterBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronThrusterBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: SteelBlock.prototype.classId(),
			quantity: 2
		}
	],
	equipment: []
};

Recipes[KryptoniteThrusterBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: SteelThrusterBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: KryptoniteBlock.prototype.classId(),
			quantity: 2
		}
	],
	equipment: []
};

/* === Armor === */

Recipes[IronPlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronBlock.prototype.classId(),
			quantity: 2
		},
		{
			blockType: CarbonBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};

Recipes[SteelPlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronPlatingBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: SteelBlock.prototype.classId(),
			quantity: 1
		},
	],
	equipment: []
};

Recipes[KryptonitePlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: SteelPlatingBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: KryptoniteBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};

Recipes[MythrilPlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: KryptonitePlatingBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: MythrilBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};

Recipes[AdamantiumPlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: MythrilPlatingBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: AdamantiumBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};

Recipes[DragonPlatingBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: AdamantiumPlatingBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: GoldBlock.prototype.classId(),
			quantity: 10
		},
		{
			blockType: DragonBlock.prototype.classId(),
			quantity: 3
		}
	],
	equipment: []
};



/* === Weapons === */
// LVL 1 Laser
Recipes[RedLaserBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronBlock.prototype.classId(),
			quantity: 2
		},
		{
			blockType: GoldBlock.prototype.classId(),
			quantity: 2
		}
	],
	equipment: []
};

// LVL 2 laser
Recipes[GreenLaserBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: RedLaserBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: KryptoniteBlock.prototype.classId(),
			quantity: 3
		}
	],
	equipment: []
};

// LVL 3 Laser
Recipes[VioletLaserBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: GreenLaserBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: FluorineBlock.prototype.classId(),
			quantity: 10
		}
	],
	equipment: []
};





/* === RESOURES === */

/* === Refined Elements === */
/*
Recipes[RefinedMythrilBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: MythrilBlock.prototype.classId(),
			quantity: 3
		},
		{
			blockType: CarbonBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};
*/
Recipes[SteelBlock.prototype.classId()] =
{
	reactants: [
		{
			blockType: IronBlock.prototype.classId(),
			quantity: 1
		},
		{
			blockType: CarbonBlock.prototype.classId(),
			quantity: 1
		}
	],
	equipment: []
};



if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Recipes; }
;var Thrusts = {};

var BASE_ENGINE_POWER = 0.015;
Thrusts[IronEngineBlock.prototype.classId()] =
{
	value: 1 * BASE_ENGINE_POWER
};

Thrusts[SteelEngineBlock.prototype.classId()] =
{
	value: 2 * BASE_ENGINE_POWER
};

Thrusts[DragonBreathEngineBlock.prototype.classId()] =
{
	value: 3 * BASE_ENGINE_POWER
};

var BASE_THRUST_POWER = 0.004;
Thrusts[IronThrusterBlock.prototype.classId()] =
{
	value: 1 * BASE_THRUST_POWER
};

Thrusts[SteelThrusterBlock.prototype.classId()] =
{
	value: 3 * BASE_THRUST_POWER
};

Thrusts[KryptoniteThrusterBlock.prototype.classId()] =
{
	value: 6 * BASE_THRUST_POWER
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Thrusts }
;var Types = {};

/* === BLOCKS === */
Types[Block.prototype.classId()] =
{
	text: 'Block'
};

/* === ARMOR BLOCKS === */
Types[Armor.prototype.classId()] =
{
	text: 'Armor'
};

Types[CloakBlock.prototype.classId()] =
{
	text: "Cloaking Armor"
};

Types[IronPlatingBlock.prototype.classId()] =
{
	text: "Level 1 Armor"
};

Types[SteelPlatingBlock.prototype.classId()] =
{
	text: "Level 2 Armor"
};

Types[KryptonitePlatingBlock.prototype.classId()] =
{
	text: "Level 3 Armor"
};

Types[MythrilPlatingBlock.prototype.classId()] =
{
	text: "Level 4 Armor"
};

Types[AdamantiumPlatingBlock.prototype.classId()] =
{
	text: "Level 5 Armor"
};

Types[DragonPlatingBlock.prototype.classId()] =
{
	text: "Level 6 Armor"
};

Types[TitaniumPlatingBlock.prototype.classId()] =
{
	text: "Level 3 Armor"
};






/* === Elements === */
Types[Element.prototype.classId()] =
{
	text: "Resource"
};

Types[CarbonBlock.prototype.classId()] =
{
	text: "Basic Resource"
};

Types[CobaltBlock.prototype.classId()] =
{
	text: "Colorant"
};

Types[FluorineBlock.prototype.classId()] =
{
	text: "Advanced Resource"
};

Types[GoldBlock.prototype.classId()] =
{
	text: "Rare Metal"
};

Types[IceBlock.prototype.classId()] =
{
	text: "Basic Resource"
};

Types[IronBlock.prototype.classId()] =
{
	text: "Basic Metal"
};

Types[DragonBlock.prototype.classId()] =
{
	text: "Rare Metal"
};

Types[AdamantiumBlock.prototype.classId()] =
{
	text: "Rare Metal"
};


Types[KryptoniteBlock.prototype.classId()] =
{
	text: "Rare Metal"
};

Types[SteelBlock.prototype.classId()] =
{
	text: "Metal Alloy"
};

Types[TitaniumBlock.prototype.classId()] =
{
	text: "Rare Metal"
};

Types[MythrilBlock.prototype.classId()] =
{
	text: "Rare Metal"
};

Types[RefinedMythrilBlock.prototype.classId()] =
{
	text: "Refined Metal"
};






/* === Parts === */
Types[Part.prototype.classId()] =
{
	text: "Ship Part"
};

Types[BridgeBlock.prototype.classId()] =
{
	text: "Command Center"
};

/* Engines */
Types[IronEngineBlock.prototype.classId()] =
{
	text: "Level 1 Engine"
};

Types[SteelEngineBlock.prototype.classId()] =
{
	text: "Level 2 Engine"
};

Types[DragonBreathEngineBlock.prototype.classId()] =
{
	text: 'Level 3 Engine'
};

/* Thrusters */
Types[IronThrusterBlock.prototype.classId()] =
{
	text: 'Level 1 Thruster'
};

Types[SteelThrusterBlock.prototype.classId()] =
{
	text: "Level 2 Thruster"
};

Types[KryptoniteThrusterBlock.prototype.classId()] =
{
	text: "Level 3 Thruster"
};

/* === WEAPONS === */
Types[Weapon.prototype.classId()] =
{
	text: 'Weapon'
};

Types[RedLaserBlock.prototype.classId()] =
{
	text: 'Level 1 Laser'
};
Types[GreenLaserBlock.prototype.classId()] =
{
	text: 'Level 2 Laser'
};
Types[VioletLaserBlock.prototype.classId()] =
{
	text: 'Level 3 Laser'
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Types
}
;/**
 * Cargo.js
 * 
 * The Cargo class represents a player's entire cargo inventory. 
 * This class provides a high-level interface for managing cargo items.
 *
 *
 * @author Daniel Chiu
 * @class
 * @typedef {Object} Cargo
 * @namespace  
 */
var Cargo = TLEntityComponent.extend({
	classId: 'Cargo',
	componentId: 'cargo',

	_items: undefined,
	_numItems: undefined,
	_numTypes: undefined,
	_recentChanges: undefined,

	/**
	 * Initialize the cargo model for a player.
	 * @memberof Cargo
	 * @instance
	 */
	init: function(entity, options) {
		TLEntityComponent.prototype.init.call(this, entity, options);

		this._items = {};
		this._numItems = 0;
		this._numTypes = 0;

		this._recentChanges = {};
	},

	/**
	 * Adds an item type to the cargo.
	 * @param type {string} A string representing the type of item to place in
	 * cargo
	 * @param quantity {number} An integer representing the number of items to
	 * place in cargo. Can be negative, but it is better to use Cargo#remove when
	 * trying to remove items.
	 */
	add: function(type, quantity) {
		quantity = quantity || 1;

		if (!this._items[type]) {
			this._items[type] = 0;
			this._numTypes++;
		}

		this._items[type] += quantity;

		this._numItems += quantity;

		this._recentChanges[type] = this._recentChanges[type] || 0;
		this._recentChanges[type] += quantity;

		this.emit("add", [type, quantity]);
	},

	fromJSON: function(data) {
		this.updateFromChanges(data);
	},

	/**
	 * Retrieves an object which contains the items of the cargo. Object is in the
	 * format quantity = items[type].
	 * @returns {*}
	 */
	items: function() {
		return this._items;
	},

	numItems: function() {
		return this._numItems;
	},

	numItemsOfType: function(type) {
		if (this._items[type]) {
			return this._items[type];
		}
		return 0;
	},

	numTypes: function() {
		return this._numTypes;
	},

	/**
	 * Retrieves the recent changes object. Recent include an aggregation of the
	 * modifications made to the cargo since the last time
	 * Cargo#resetRecentChanges was called.
	 * Reset changes are in the format delta = recentChanges[type].
	 * @returns {*}
	 */
	recentChanges: function() {
		return this._recentChanges;
	},

	/**
	 * Removes items of the specified type from the Cargo.
	 * @param type {string} A string representing the type of item to remove
	 * @param quantity {number} The number of items to remove.
	 * @returns {boolean}
	 */
	remove: function(type, quantity) {
		quantity = quantity || 1;

		if (!this._items[type]) {
			this.log("CargoComponent#remove: tried to remove item type that isn't in cargo: "
				+ type, "warning");
			return false;
		}

		if (this._items[type] < quantity) {
			this.log("CargoComponent#remove: tried to remove " + quantity + " " + type + "'s when"
				+ " only " + this._items[type] + " existed in cargo.", "warning");
			return false;
		}

		this._items[type] -= quantity;
		if (this._items[type] === 0) {
			this._numTypes--;
			delete this._items[type];
		}

		this._numItems -= quantity;

		this._recentChanges[type] = this._recentChanges[type] || 0;
		this._recentChanges[type] -= quantity;

		this.emit("remove", [type, quantity]);

		return true;
	},

	/**
	 * Resets the recent changes object so that there are no recent changes.
	 */
	resetRecentChanges: function() {
		this._recentChanges = {};
	},

	toJSON: function() {
		return this._items;
	},

	/**
	 * Given a changes object in the format delta = changes[type], adds or removes
	 * the necessary items from the cargo to apply the change.
	 * @param changes
	 */
	updateFromChanges: function(changes) {
		var self = this;

		_.forOwn(changes, function(delta, type) {
			// Branch here to avoid awkwardly passing negative numbers to the add function.
			// Additionally, the remove function does some sanity checks.
			if (delta >= 0) {
				self.add(type, delta);
			}
			else {
				self.remove(type, -delta);
			}
		});
	}
});

if (typeof (module) !== "undefined" && typeof (module.exports) !== "undefined")
{
	 module.exports = Cargo;
}
;var DamageSource = TLStreamedEntityComponent.extend({
	classId: 'DamageSource',
	componentId: 'damageSource',

	cooldown: undefined,
	_coolingDown: undefined,
	damage: undefined,
	duration: undefined,
	durationFired: undefined,
	_intersectionPoint: undefined,
	range: undefined,
	_target: undefined,

	init: function(entity, data) {
		if (data === undefined || data.cooldown === undefined || data.damage === undefined
			|| data.duration === undefined || data.range === undefined ) {
			this.log('Init parameters not provided for DamageSource.', 'error');
			return;
		}

		TLStreamedEntityComponent.prototype.init.call(this, entity, data);

		this._actionCallbacks = {
			intersectionPoint: this.intersectionPointClient
		};

		this.cooldown = data.cooldown;
		this.damage = data.damage;
		this.duration = data.duration;
		this.range = data.range;

		this.durationFired = 0;
		this._intersectionPoint = null;
		this._coolingDown = false;
	},

	coolingDown: function(newVal) {
		if (newVal !== undefined) {
			this._coolingDown = newVal;
			return this;
		}
		return this._coolingDown;
	},

	intersectionPoint: function(newPoint) {
		if (newPoint !== undefined) {
			this._intersectionPoint = newPoint;
			return this;
		}

		return this._intersectionPoint;
	},

	// TODO: For now, the DamageSource makes assumptions about the type of weapon. This should be
	// changed when there are multiple types of weapons in the game.
	intersectionPointClient: function(action) {
		this.intersectionPoint(action.data);
		var laser = this._entity;

		if (this._intersectionPoint) {
			if (laser.laserBeam === undefined) {
				laser.laserBeam = new LaserBeam({source: laser})
					.setTarget(action.data.x, action.data.y);

				laser._mountEffect(laser.laserBeam, true);
			}
			else {
				laser.laserBeam.setTarget(action.data.x, action.data.y);
			}
		}
		else {
			laser.laserBeam.destroy();
			laser.laserBeam = undefined;

			// Laser stopped firing. Start cooldown timer on client.
			var ship = this._entity.blockGrid();
			if (ship === ige.client.player.currentShip()) {
				ige.hud.bottomToolbar.capBar.mineCap.startCooldown(this._entity);
			}
		}
	},

	intersectionPointServer: function(newPoint) {
		this.intersectionPoint(newPoint);
		this.pushAction("intersectionPoint", newPoint);
	},

	target: function(newTarget) {
		if (newTarget !== undefined) {
			this._target = newTarget;
			return this;
		}

		return this._target;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = DamageSource; }
;var Description = IgeClass.extend({
	classId: 'Description',
	componentId: 'description',

	text: undefined,

	init: function(entity, data) {
		if (data === undefined || data.text === undefined) {
			this.log('Init parameters not provided for Description.', 'error');
			return;
		}

		// Take the text as a parameter
		this.text = data.text;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Description; }
;var Type = IgeClass.extend({
	classId: 'Type',
	componentId: 'type',

	text: undefined,

	init: function(entity, data) {
		if (data === undefined || data.text === undefined) {
			this.log('Init parameters not provided for Type.', 'error');
			return;
		}

		// Take the text as a parameter
		this.text = data.text;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Type; }
;var Health = TLStreamedEntityComponent.extend({
	classId: 'Health',
	componentId: 'health',

	value: undefined,
	max: undefined,

	init: function(entity, data) {
		TLStreamedEntityComponent.prototype.init.call(this, entity, data);

		this._actionCallbacks = {
			set: this.setClient
		};

		if (data === undefined || data.max === undefined) {
			this.log('Init parameters not provided for Health.', 'error');
			return;
		}

		// Take the maximum health value as a parameter
		this.max = data.max;
		// Health always starts at the maximum value
		this.value = this.max;
	},

	increase: function(amount) {
		this.setServer(this.value + amount);
	},

	decrease: function(amount) {
		this.setServer(this.value - amount);
	},

	set: function(newValue) {
		this.value = newValue;
	},

	setClient: function(action) {
		this.set(action.data);
	},

	setServer: function(newValue) {
		this.set(newValue);
		this.pushAction("set", this.value);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Health;
};var Recipe = IgeClass.extend({
	classId: 'Recipe',
	componentId: 'recipe',

	/**
	 * The entity that this component has been added to.
	 */
	entity: undefined,
	/**
	 * The name of this recipe. Matches the block it is added to.
	 */
	name: undefined,
	/**
	 * Whether or not this recipe is craftable by players. Certain blocks may not be.
	 */
	craftable: undefined,
	/**
	 * Object containing the reactants of this recipe. This is a list of {blockType: string, quantity: number} objects.
	 */
	reactants: undefined,

	init: function(entity, data) {
		if (data === undefined || data.reactants === undefined) {
			this.log('Init parameters not provided for Recipe.', 'error');
			return;
		}

		this.entity = entity;
		this.name = data.name || Block.displayNameFromClassId(entity.classId());
		this.craftable = data.craftable || true;
		this.reactants = data.reactants;
	},

	tooltipData: function() {
		var data = {};
		data.name = this.name;
		data.description = this.entity.description.text;
		data.reactants = [];
		for (var i = 0; i < this.reactants.length; i++) {
			var reactant = this.reactants[i];
			data.reactants.push(
				{
					blockType: Block.displayNameFromClassId(reactant.blockType),
					quantity: reactant.quantity
				}
			);
		}

		return data;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Recipe; };var Thrust = IgeClass.extend({
	classId: 'Thrust',
	componentId: 'thrust',

	value: undefined,

	init: function(entity, data) {
		if (data === undefined || data.value === undefined) {
			this.log('Init parameters not provided for Thrust.', 'error');
			return;
		}

		this.value = data.value;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Thrust; }
;var ConstructionOverlayRenderableComponent = PixiRenderableComponent.extend({
	classId: 'ConstructionOverlayRenderableComponent',

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
	},

	renderConstructionLocations: function() {
		// TODO: Clearing the children could probably be optimized to not create and destroy so
		// so many things so often.
		// Clear all children
		while (this._displayObject.children.length > 0) {
			this._displayObject.removeChildAt(0);
		}

		var constructionLocations = this._entity._constructionLocations; // TODO This should be this._entity.constructionLocations()

		for (var x = 0; x < constructionLocations.length; x++) {
			for (var y = 0; y < constructionLocations[0].length; y++) {
				if (constructionLocations[x][y] > 0) {
					var sprite = PIXI.Sprite.fromFrame("ConstructionZone.png");

					sprite.width = Block.WIDTH;
					sprite.height = Block.HEIGHT;

					sprite.position.x = Block.WIDTH * x - this._entity.width() / 2;
					sprite.position.y = Block.HEIGHT * y - this._entity.height() / 2;

					this._displayObject.addChild(sprite);
				}
			}
		}
	}
});
;var HealthBarRenderableComponent = PixiRenderableComponent.extend({
	classId: 'HealthBarRenderableComponent',
	componentId: 'renderable',

	lastHp: undefined,

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
	},

	update: function() {
		PixiRenderableComponent.prototype.update.call(this);

		// Cache the last HP value and only do anything if the HP has changed.
		if (this.lastHp !== this._entity._block.health.value) {

			// If lastHp is undefined, we've never drawn before, so no need to clear.
			if (this.lastHp !== undefined) {
				this._displayObject.clear();
			}

			this.lastHp = this._entity._block.health.value;

			this._displayObject.beginFill(0xFF0000, 0.4);
			this._displayObject.drawRect(0, 0,
					this._entity._block.width()
					* (1 - this._entity._block.health.value / this._entity._block.health.max),
				this._entity._block.height()
			);
			this._displayObject.endFill();
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = HealthBarRenderableComponent;
}
;var ParallaxBackgroundRenderableComponent = PixiRenderableComponent.extend({
	classId: 'ParallaxBackgroundRenderableComponent',
	componentId: 'renderable',

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
		this._parallaxLag = 1;
	},

	/**
	 * Getter/setter for the parallaxLag property.
	 * @param val {number} Optional parameter. If set, this is the new
	 * parallaxLag
	 * @returns {*} parallaxLag value if no parameter is passed or this object if a
	 * parameter is passed to make setter chaining convenient.
	 * @memberof ParallaxBackground
	 * @instance
	 */
	parallaxLag: function(val) {
		if (val !== undefined) {
			this._parallaxLag = val;
			return this._entity;
		}
		return this._parallaxLag;
	},

	update: function() {
		var camera = ige._currentCamera;

		this._displayObject.position.x = this._entity.translate().x() + (camera._translate.x / this._parallaxLag - this._entity.width() / 2);
		this._displayObject.position.y = this._entity.translate().y() + (camera._translate.y / this._parallaxLag - this._entity.height() / 2);

		this._displayObject.rotation = this._entity.rotate().z();
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ParallaxBackgroundRenderableComponent; }
;var LaserBeamRenderableComponent = PixiRenderableComponent.extend({
	classId: 'LaserBeamRenderableComponent',
	componentId: 'renderable',

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
	},

	update: function() {
		PixiRenderableComponent.prototype.update.call(this);

		if (!this._entity._targetX || !this._entity._targetY || !this._entity._source) {
			return;
		}

		var sourceCoordinates = this._entity._source.worldCoordinates();
		var targetCoordinates = new IgePoint2d(this._entity._targetX, this._entity._targetY);

		if (!sourceCoordinates || !targetCoordinates) {
			return;
		}

		var delta = targetCoordinates.minusPoint(sourceCoordinates);
		var distance = MathUtils.magnitude(delta);
		var angle = Math.atan2(delta.y, delta.x);

		this._displayObject.height = distance * 2;
		this._displayObject.blendMode = PIXI.blendModes.ADD;
		this._displayObject.rotation = angle - this._entity._source.gridData.grid.
			renderable._displayObject.rotation + Math.radians(90);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = LaserBeamRenderableComponent; }
;var ParticleRenderableComponent = PixiRenderableComponent.extend({
	classId: 'ParticleRenderableComponent',
	componentId: 'renderable',

	init: function(entity, data) {
		PixiRenderableComponent.prototype.init.call(this, entity, data);
	},

	update: function() {
		PixiRenderableComponent.prototype.update.call(this);

		this._displayObject.position.x -= this._entity.width() / 2;
		this._displayObject.position.y -= this._entity.height() / 2;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ParticleRenderableComponent; };var RespawnableComponent = IgeClass.extend({
	classId: 'RespawnableComponent',
	componentId: 'respawn',

	_entity: undefined,
	_respawnTime: undefined,
	_respawnAction: undefined,
	_respawnTimeout: undefined,

	init: function(entity, data) {
		var self = this;
		this._entity = entity;

		if (data === undefined || data.minRespawnTime === undefined || data.maxRespawnTime === undefined
			|| data.respawnAction === undefined) {
			this.log('Init parameters not provided for RespawnableComponent.', 'error');
			return;
		}

		this._respawnAction = data.respawnAction;

		this._respawnTime = Math.floor(Math.random() * data.maxRespawnTime) + data.minRespawnTime;
		this._respawnTimeout = setTimeout(function() {

			self._respawnAction();
			self._entity.destroy();
			self._entity.log('Respawning!');
		}, this._respawnTime);
	},

	resetTimeout: function() {
		var self = this;
		clearTimeout(this._respawnTimeout);
		this._respawnTimeout = setTimeout(function() {

			self._respawnAction();
			self._entity.destroy();
			self._entity.log('Respawning!');
		}, this._respawnTime);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = RespawnableComponent; }
;/**
 * An {@link IgeEntity} that represents a player in the game.
 * The player class contains all of the additional data and functionality (beyond a mere block grid) that is needed to
 * represent a player in Cosmos.
 * @typedef {Player}
 * @class
 * @namespace
 * @todo This design should be replaced by something more natural (like there should be a ship class) and/or
 * something component-based.
 */
var Player = IgeEntity.extend({
	classId: 'Player',

	/**
	 * The session ID associated with this player's client and current session.
	 * @type {string}
	 * @memberof Player
	 * @private
	 * @instance
	 */
	_sid: undefined,
	_loggedIn: undefined,
	_username: undefined,
	_usernameLabel: undefined,
	hasGuestUsername: undefined,

	/**
	* The player's controls object. This represents the state of the player's instructions to to the game, like which keys are depressed.
	* Network messages are used to keep this property in sync between the server and the client.
	*/
	_controls: undefined,
	// Keep track of previous values so we can send the client notifications only
	// on a change.
	_prevControls: undefined,
	_prevMovementBlocks: undefined,

	/**
	 * The clientId associated with the player. Used to send notifications to
	 * a specific player.
	 * @type {string}
	 * @memberof Player
	 * @private
	 * @instance
	 */
	 _clientId: undefined,

	/**
	 * The Ship object that this player is currently controlling. At some point, players may be able to control more than one ship.
	 * Right now a player can only control one ship.
	 */
	_currentShip: undefined,

	init: function() {
		IgeEntity.prototype.init.call(this);

		this._controls = {
			key: {
				left: false,
				right: false,
				up: false,
				down: false
			}
		};

		this._prevControls = {
			key: {
				left: false,
				right: false,
				up: false,
				down: false
			}
		};

		this.addComponent(CraftingComponent);
		this.addComponent(QuestComponent);
	},

	/**
	 * Getter/setter for the _sid parameter, which stores the session ID of this player.
	 * @param val {string?} The new value to use or undefined if we are invoking this function as the getter.
	 * @returns {string|Player} Either the current _sid or this object so that we can chain setter calls.
	 * @memberof Player
	 * @instance
	 */
	sid: function(val) {
		if (val === undefined) {
			return this._sid;
		}
		this._sid = val;
		return this;
	},

	loggedIn: function(val) {
		if (val === undefined) {
			return this._loggedIn;
		}
		this._loggedIn = val;
		return this;
	},

	/*
	Getter and setter for the _username property
	*/
	username: function(val) {
		if (val === undefined) {
			return this._username;
		}

		// Players can't change their username after they've chosen one!
		if (!this.hasGuestUsername && this._username) {
			return this;
		}

		this._username = val;

		if (ige.isClient) {
			this._createUsernameLabel();
			this._usernameLabel.text(this._username);
		}

		return this;
	},

	requestUsername: function(username) {
		if (!this.username() || this.hasGuestUsername) {
			ige.network.send('cosmos:player.username.set.request', username);
		}
	},

	generateGuestUsername: function() {
		var guestNumber = Math.floor((Math.random() * 999999) + 100000);
		var guestUsername = 'guest' + guestNumber;
		this.hasGuestUsername = true;
		this.username(guestUsername);
	},

	/**
	 * Getter/setter for the _clientId parameter. This is set when the player
	 * is created and read when a notification is sent to a specific
	 * player.
	 * @param val {string?} The new value to use or undefined if we are invoking this function as the getter.
	 * @returns {string|Player} Either the clientId or this object so that we can chain setter calls.
	 * @memberof Player
	 * @instance
	 */
	clientId: function(val) {
		if (val === undefined) {
			return this._clientId;
		}
		this._clientId = val;
		return this;
	},

	/*
	TODO: the usernames should really be a part of the ship, instead of the player object.
	Because only when a ship is streamed to you do you potentially care about that player.
	Otherwise you don't need the player data at all.
	*/
	_createUsernameLabel: function() {
		// Don't create the username label again if it already exists.
		if (this._usernameLabel !== undefined) {
			return;
		}
		var self = this;
		this._usernameLabel = $('<div>' + this.username() + '</div>').addClass('username-label tooltip');
		$('body').append(this._usernameLabel);

		var hoverTimer;

		// Make the username label "disappear" on hover. Cannot just hide the label, because there is no good condition
		// to make it show again. This makes the mousedown code below necessary so that we can send clicks through this
		// label to the canvas below.
		this._usernameLabel.hover(function() {
			if (hoverTimer !== undefined) {
				clearTimeout(hoverTimer);
			}
			$(this).css({opacity: 0});
		},
		function() {
			var label = $(this);
			hoverTimer = setTimeout(function() {
				// 400ms for duration is the default for fadeIn()
				label.fadeTo(Player.USERNAME_LABEL_FADE_IN_DURATION, 1);
			}, Player.USERNAME_LABEL_HYSTERESIS_INTERVAL);
		});

		// When the username label is clicked, construct a click event that looks like a regular IGE canvas click event
		// and pass it down to IGE.
		this._usernameLabel.mousedown(function(e) {
			self.dispatchClickToIge(e);
		});

		// Also need to pass mouse up events from the label down or the entity won't change its internal state to think
		// that the mouse down ended and won't allow additional clicks.
		this._usernameLabel.mouseup(function(e) {
			self.dispatchClickToIge(e);
		});

		var mouseOutTimer; // this will store the numerical ID of the timeout. As in mouseOutTimer = setTimeout(...)

		this.mouseOver(function() {
			if (mouseOutTimer !== undefined) {
				clearTimeout(mouseOutTimer);
			}
			self._usernameLabel.hide();
		});

		this.mouseOut(function() {
			mouseOutTimer = setTimeout(function() {
				self._usernameLabel.fadeIn();
			}, Player.USERNAME_LABEL_HYSTERESIS_INTERVAL);
		});
	},

	dispatchClickToIge: function(e) {
		var igeCanvas = document.getElementById('igeFrontBuffer');
		var clickEvent = this.createIgeClickEvent(e);
		igeCanvas.dispatchEvent(clickEvent);
	},

	createIgeClickEvent: function(e) {
		var igeCanvas = document.getElementById('igeFrontBuffer');
		var clickEvent = document.createEvent('MouseEvent');
		clickEvent.initMouseEvent(
			e.type,
			e.bubbles,
			e.cancelable,
			e.view,
			1,
			e.screenX,
			e.screenY,
			e.clientX,
			e.clientY,
			e.ctrlKey,
			e.altKey,
			e.shiftKey,
			e.metaKey,
			e.button,
			null
		);
		clickEvent.srcElement = clickEvent.currentTarget = clickEvent.target = clickEvent.toElement = igeCanvas;
		return clickEvent;
	},

	_destroyUsernameLabel: function() {
		// If there is no username label, there isn't anything to destroy
		if (this._usernameLabel === undefined) {
			return;
		}

		this._usernameLabel.remove();
		this._usernameLabel = undefined;
	},

	/**
	 * TODO fix this comment
	 * Override the {@link IgeEntity#update} function to provide support for player controls and {@link Block} functions
	 * like applying force where {@link EngineBlock}s are or turning faster when there are more {@link ThrusterBlock}s.
	 * @param ctx {Object} The render context.
	 * @memberof Player
	 * @instance
	 */
	update: function(ctx) {
		IgeEntity.prototype.update.call(this, ctx);

		if (!ige.isServer) {
			// If this isn't the player playing on this client, draw a label to help identify this player
			if (this._usernameLabel !== undefined && (ige.client.player && ige.client.player.id() !== this.id()) && this.currentShip()) {
				var screenPos = this.currentShip().screenPosition();
				this._usernameLabel.css('left', Math.round(screenPos.x - this._usernameLabel.outerWidth() / 2));
				this._usernameLabel.css('top', Math.round(screenPos.y - this._usernameLabel.outerHeight() / 2));
			}

			/* Save the old control state for comparison later */
			oldControls = JSON.stringify(this._controls);

			/* Modify the KEYBOARD controls to reflect which keys the client currently is pushing */
			this.controls().key.up =
				ige.input.actionState('key.up') | ige.input.actionState('key.up_W');
			this.controls().key.down =
				ige.input.actionState('key.down') | ige.input.actionState('key.down_S');
			this.controls().key.left =
				ige.input.actionState('key.left') | ige.input.actionState('key.left_A');
			this.controls().key.right =
				ige.input.actionState('key.right') | ige.input.actionState('key.right_D');

			if (JSON.stringify(this._controls) !== oldControls) { //this._controls !== oldControls) {
				// Tell the server about our control change
				ige.network.send('playerControlUpdate', this._controls);
			}
		}
	},

	/**
	 * Getter and setter for the controls property.
	 */
	controls: function(newControls) {
		if (newControls) {
			this._controls = newControls;

			newShipControls = {};
			newShipControls.up = this._controls.key.up;
			newShipControls.down = this._controls.key.down;
			newShipControls.left = this._controls.key.left;
			newShipControls.right = this._controls.key.right;

			this.currentShip().controls(newShipControls);

			return this;
		}

		return this._controls;
	},

	/**
	 * Getter and setter for the _currentShip property
	 */
	currentShip: function(newCurrentShip) {
		if (newCurrentShip !== undefined) {
			this._currentShip = newCurrentShip;
			//Give the new ship a reference back to this player object
			this._currentShip.player(this);

			if (!ige.isServer) {
					/**
					* Initializes all of the cameras that need to track the ship.
					* This is currently just one camera: the camera for the main viewport.
					* The minimap doesn't actually use IGE, it uses HTML instead, and so it doesn't have a camera.
					*/
				var cameraSmoothingAmount = 0;

				if (ige.client.player && ige.client.player.id() === this.id()) {
					ige.$('mainViewport').camera.trackTranslate(this._currentShip, cameraSmoothingAmount);
				}
			}

			// Update previous controls so we can tell what has changed each update.
			// We want to send engine missing notifications on a change, not every
			// update
			this._prevControls = JSON.parse(JSON.stringify(this._controls));
			return this;
		}

		return this._currentShip;
	},

	/*
	toJSON returns a dictionary that containts the public members of this player class.
	Note that toJSON should not return any members that are not meant to be read by all game clients.
	*/
	toJSON: function() {
		return {
			playerId: this.id(),
			username: this.username(),
			hasGuestUsername: this.hasGuestUsername,
			loggedIn: this.loggedIn(),
			shipId: this.currentShip().id()
		}
	}
});

Player.USERNAME_LABEL_FADE_IN_DURATION = 400;
Player.USERNAME_LABEL_HYSTERESIS_INTERVAL = 500;

Player.onUsernameRequested = function(username, clientId) {
	if (!ige.isServer) {
		return;
	}

	var player = ige.server.players[clientId];
	if (player === undefined) {
		return;
	}

	if (!player.hasGuestUsername && player.username()) {
		//This should never be sent unless someone screws with the client:
		ige.network.send('cosmos:player.username.set.error', 'Player already has username ' + player.username(), clientId);
		console.log("Player already has username: " + player.username());
		return;
	}

	if (!Player.usernameIsCorrectLength(username)) {
		ige.network.send('cosmos:player.username.set.error', 'Username must be between 2 and 12 characters', clientId);
	}
	else if (!Player.usernameIsAlphanumericUnderscore(username)) {
		ige.network.send('cosmos:player.username.set.error', 'Alphanumeric characters and underscores only', clientId);
	}

	DbPlayer.findByUsername(username, function(err, foundPlayer) {
		if (err) {
			console.error('Error finding player with username ' + username + '. Error: ' + err);
			ige.network.send('cosmos:player.username.set.error', 'Database error', clientId);
			return;
		}

		if (foundPlayer) {
			ige.network.send('cosmos:player.username.set.error', 'Username ' + username + ' is taken');
		}
		else {
			player.username(username);
			player.hasGuestUsername = false;
			DbPlayer.update(player.id(), player, function(err) {
				if (err) {
					console.error('Error updating player ' + player.id() + '. Error: ' + err);
					ige.network.send('cosmos:player.username.set.error', 'Database error', clientId);
					return;
				}
				ige.network.send('cosmos:player.username.set.approve', {'playerId': player.id(), 'username': username});
			});
		}
	});
};

Player.onUsernameRequestApproved = function(data) {
	ige.emit('cosmos:player.username.set.approve', data);

	var player = ige.$(data.playerId);
	if (player) {
		player.username(data.username);
		player.hasGuestUsername = false;

		if (ige.client.player && ige.client.player.id() === player.id()) {
			ige.emit('cosmos:client.player.username.set', player.username());
		}
	}
};

Player.onUsernameRequestError = function(error) {
	ige.emit('cosmos:player.username.set.error', error);
};

Player.usernameIsAlphanumericUnderscore = function(username) {
	var regex = /^([a-zA-Z0-9_])+$/;
	return regex.test(username);
};

Player.usernameIsCorrectLength = function(username) {
	return username.length >= 2 && username.length <= 12;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Player; }
;/**
 * This class represents a ship in Cosmos.
 * A ships is a BlockStructure that also has a cargo. A ship is controlled by a {@link Player} or an AI (not yet implemented).
 */
var Ship = BlockStructure.extend({
	classId: 'Ship',

	/**
	 * Whether or not this {@link Ship} is mining. Used to restrict ships from mining more than one {@link Block}
	 * at a time. I expect that at some later point Ships will be able to mine multiple blocks at once
	 * (assuming the ship has >1 lasers). Right now ships can only mine one at a time.
	 * @type {boolean}
	 * @memberof Ship
	 * @instance
	 */
	mining: false,

	/**
	 * The control state of this ship. For example,
	 * {
	 * 	left: false,
	 * 	right: false,
	 * 	up: false,
	 * 	down: false
	 * }
	 * [up and down should potentially be renamed forwards and backwards]
	 * @type {Object}
	 * @memberof Ship
	 * @instance
	 */
	_controls: undefined,

	/**
	* A dictonary that keeps track of the previous state of the controls for this ship.
	* @type {Object}
	* @memberof Ship
	* @instance
	*/
	_prev_controls: undefined,

	/**
	 * The cargo of the ship.
	 * @type {Cargo}
	 * @memberof Ship
	 * @instance
	 */
	cargo: undefined,

	/**
	 * Stores the number of thrusters and engines that you had the last time that update was run
	 * @type {Object}
	 * @memberof Ship
	 * @instance
	 */
	_prevMovementBlocks: undefined,

	/**
	 * A reference to the player that owns this ship.
	 * At some point we may have NPCs, in which case this should be a pointer to the more general object which is the superclass of both Player and NPC.
	 * @type {Player}
	 * @memberof Ship
	 * @instance
	 */
	_player: undefined,

	_bridgeBlocks: undefined,

	/**
	 * A list that stores references to all of the engines in this ship
	 * //TODO shouldn't the engines be kept track of by some component? Like a engines component?
	 * @type {Array}
	 * @memberof Ship
	 * @instance
	 */
	_engines: undefined,

	/**
	* A list that stores references to all of the thrusters in this ship
	* //TODO shouldn't the thrusters be kept track of by some component? Like a thrusting component?
	* @type {Array}
	* @memberof Ship
	* @instance
	*/
	_thrusters: undefined,

	_firingWeapons: undefined,
	_weapons: undefined,

	_prevGridLocationForMouse: undefined,

	init: function(data) {
		data = data || {};

		// Note that these variables must be initialized before the superclass constructor can be
		// called, because it will add things to them by calling add().
		this._bridgeBlocks = [];
		this._engines = [];
		this._thrusters = [];
		this._firingWeapons = [];
		this._weapons = [];

		if (ige.isServer) {
			this.category(Ship.BOX2D_CATEGORY_BITS);

			data.physicsBody = {};
			data.physicsBody.fixtureFilter = {
				categoryBits: Ship.BOX2D_CATEGORY_BITS,
				// Collide with everything, including drops.
				maskBits: 0xffff
			};
		}

		BlockStructure.prototype.init.call(this, data);

		this._controls = {
			left: false,
			right: false,
			up: false,
			down: false
		};

		if (ige.isClient) {
			this._initClient();
			var player = ige.$(data.playerId);
			if (player) {
				this.player(player);
				this.player().currentShip(this);
			}
		} else {
			this._initServer();
		}

		this.addComponent(Cargo);

		var streamPrivateSections = [
			{
				id: "cargo",
				// Object used here instead of an array for faster look up.
				clients: {}
			}
		];

		this.streamPrivateSections(streamPrivateSections);

		var self = this;
		this.cargo.on('add', function() {
			var player = self.player();
			if (player && ige.isServer) {
				player.emit('cosmos:Ship.blockCollected')
				DbPlayer.update(player.id(), player, function() {});
			}
		});

		this._prevMovementBlocks = {
			engines: this._engines.length,
			thrusters: this._thrusters.length
		};

		if (ige.isClient) {
			this._prevGridLocationForMouse = new IgePoint2d(0, 0);
			this.mouseMove(this._mouseMoveHandler);
		}
	},

	_mouseMoveHandler: function(event, control) {
		var currentMouseGridLocation = this.gridLocationForEvent(event, control);
		
		if (!(this._prevGridLocationForMouse.compare(currentMouseGridLocation))) {

			if (this.get(this._prevGridLocationForMouse).length > 0) {
				this.get(this._prevGridLocationForMouse)[0]._mouseOutHandler();
			}
			if (this.get(currentMouseGridLocation).length > 0) {
				this.get(currentMouseGridLocation)[0]._mouseOverHandler();
			}

			this._prevGridLocationForMouse = currentMouseGridLocation;
		}
	},

	streamCreateData: function() {
		var data = BlockStructure.prototype.streamCreateData.call(this);

		if (this.player()) {
			data.playerId = this.player().id();
		}
		return data;
	},

	streamSectionData: function(sectionId, data, bypassTimeStream) {
		switch (sectionId) {
			case 'cargo':
				// If data has been provided, then we are on the client and need to deal with the
				// data. For cargo, data comes in the form of an object with types of blocks as the
				// keys and the quantity to change this entry in the cargo by as the values.
				if (data) {
					this.cargo.updateFromChanges(JSON.parse(data));
				}
				else {
					var json = JSON.stringify(this.cargo.recentChanges());
					this.cargo.resetRecentChanges();
					return json;
				}
				break;
			case 'actions':
				if (ige.isClient && sectionId === "actions") {
					ige.hud.bottomToolbar.capBar.mineCap.cooldownActivated = false;
				}
			default:
				return BlockStructure.prototype.streamSectionData
					.call(this, sectionId, data, bypassTimeStream);
				break;
		}
	},

	destroy: function() {
		if (ige.isClient && this.player()) {
			this.player()._destroyUsernameLabel();
		}

		BlockStructure.prototype.destroy.call(this);
	},

	bridgeBlocks: function() {
		return this._bridgeBlocks;
	},

	// Getter for the _engines property
	engines: function() {
		return this._engines;
	},

	// Getter for the _thrusters property
	thrusters: function() {
		return this._thrusters;
	},

	firingWeapons: function() {
		return this._firingWeapons;
	},

	weapons: function() {
		return this._weapons;
	},

	_addToPartsLists: function(block) {
		if (block instanceof EngineBlock) {
			this.engines().push(block);
		}
		else if (block instanceof ThrusterBlock) {
			this.thrusters().push(block);
		}
		else if (block instanceof Weapon) {
			this.weapons().push(block);
		}
		else if (block instanceof BridgeBlock) {
			this.bridgeBlocks().push(block);
		}
	},

	/*
	Overrides the superclass's put function
	Updates the engines and thrusters lists on each add
	*/
	put: function(block, loc, replace) {
		// You can't add a second Bridge to a ship.
		if (block instanceof BridgeBlock && this.controllable()) {
			return false;
		}

		var result = BlockStructure.prototype.put.call(this, block, loc,
			replace);
		if (result !== null && ige.isServer) {
			DbPlayer.update(this.player().id(), this.player(), function() {});
		}

		if (result !== null) {
			this._addToPartsLists(block);
		}

		var self = this;
		_.forEach(result, function(removedBlock) {
			self._removeFromPartsLists(removedBlock);
		});

		return result;
	},

	streamEntityValid: function(val) {
		if (val !== undefined && this.player() !== undefined) {
			if (val === false) {
				this.player()._destroyUsernameLabel();
			}
			else {
				this.player()._createUsernameLabel();
			}
		}

		return BlockStructure.prototype.streamEntityValid.call(this, val);
	},

	_removeFromPartsLists: function(block) {
		if (block instanceof EngineBlock) {
			this.engines().splice(this.engines().indexOf(block), 1);
		}
		else if (block instanceof ThrusterBlock) {
			this.thrusters().splice(this.thrusters().indexOf(block), 1);
		}
		else if (block instanceof Weapon) {
			this.weapons().splice(this.weapons().indexOf(block), 1);
		}
		else if (block instanceof BridgeBlock) {
			this.bridgeBlocks().splice(this.bridgeBlocks().indexOf(block), 1);
		}
	},

	remove: function(loc, width, height) {
		var removed = BlockStructure.prototype.remove.call(this, loc, width, height);
		var self = this;
		_.forEach(removed, function(removedBlock) {
			self._removeFromPartsLists(removedBlock);
		});

		if (ige.isServer) {
			DbPlayer.update(this.player().id(), this.player(), function() {});
			// If the ship has no longer controllable
			if (!this.controllable()) {
				// Then it is dead
				var data = {};
				ige.network.stream.queueCommand('cosmos:ship.death', data, this.player().clientId());
			}
		}

		return removed;
	},

	/**
	 * Perform client-specific initialization here. Called by init()
	 * @memberof Ship
	 * @private
	 * @instance
	 */
	_initClient: function() {
		this.depth(Ship.DEPTH);
	},

	/**
	 * Perform server-specific initialization here. Called by init()
	 * @memberof Ship
	 * @private
	 * @instance
	 */
	_initServer: function() {
		this.addSensor(500)
			.attractionStrength(0.01)
	},

	player: function(newPlayer) {
		if (newPlayer === undefined) {
			return this._player;
		}

		this._player = newPlayer;
		if (ige.isClient) {
			this._player._createUsernameLabel();
		}
		else {
			// Update private stream sections so updates about the ship are sent to just the
			// player who controls this ship.
			this._streamPrivateSections[0].clients[newPlayer.clientId()] = true;
		}
		return this;
	},

	/**
	 * Add the sensor fixture. Called in ServerNetworkEvents after the box2Dbody
	 * is created.
	 * @param radius {number} The radius of the attraction field
	 * @return {Ship} This object is returned to facilitate setter chaining.
	 * @memberof Ship
	 * @instance
	 */
	// @server-side
	// TODO: Make the sensor a separate entity, so we can have multiple sensors
	// attached to the ship
	addSensor: function(radius) {
		this.addComponent(TLPhysicsFixtureComponent);
		this.physicsFixture.fixtureDef = {
			fixtureCategory: Ship.ATTRACTOR_BOX2D_CATEGORY,
			friction: 0.0,
			restitution: 0.0,
			density: 0.0,
			isSensor: true,
			categoryBits: Ship.ATTRACTOR_BOX2D_CATEGORY_BITS,
			maskBits: 0xffff,

			shapeType: 'CIRCLE',
			radius: radius,
			x: 0.0,
			y: 0.0
		}
		this.physicsBody.newFixture(this);

		return this;
	},

	/**
	 * Get/set the strength of attraction
	 * @param strength {number?} A multiplier for attraction force
	 * @return {(number|Ship)} The current attraction strength if no argument is passed or this object if an argument
	 * is passed in order to support setter chaining.
	 * @memberof Ship
	 * @instance
	 */
	attractionStrength: function(strength) {
		if (strength === undefined) {
			return this._attractionStrength;
		}
		else {
			this._attractionStrength = strength;
			return this;
		}
	},

	/**
	 * Changes the ship's location to a random new location.
	 * @memberof Ship
	 * @instance
	 */
	relocate: function() {
		var coordinates = this.getRelocateCoordinates();
		return this.translateTo(coordinates.x, coordinates.y, 0);
	},

	getRelocateCoordinates: function() {
		return {
			x: (Math.random() - .5) * Ship.SHIP_START_RADIUS,
			y: (Math.random() - .5) * Ship.SHIP_START_RADIUS
		};
	},

	/**
	 * Checks if the ship is able to mine
	 * @memberof Ship
	 * @instance
	 * @return {Boolean} True if ship can mine
	 */
	canMine: function () {
		// Do not start mining if we are already mining
		if (this.mining) {
			return false;
		}

		// We can't mine if we're dead
		if (!this.controllable()) {
			return false;
		}

		// Do not start mining if ship has no lasers
		return this.weapons().length > 0;
	},

	/**
	 * Sends messages to clients to tell them to turn on all of the lasers for this ship.
	 * @param targetBlock {Block} The {@link Block} that the lasers will be focused on.
	 * @memberof Ship
	 * @instance
	 */
	fireMiningLasers: function(targetBlock) {
		// TODO: Change this when there are more weapons than just lasers.
		var miningLasers = this.weapons();
		for (var i = 0; i < miningLasers.length; i++) {
			var miningLaser = miningLasers[i];
			ige.network.send('addEffect', NetworkUtils.effect('miningLaser', miningLaser, targetBlock));
		}
	},

	/**
	 * Sends messages to clients to tell them to turn off all of the lasers for this ship.
	 * @param targetBlock {Block} The {@link Block} that the lasers were focused on.
	 * @memberof Ship
	 * @instance
	 */
	turnOffMiningLasers: function(targetBlock) {
		// TODO: Change this when there are more weapons than just lasers.
		var miningLasers = this.weapons();
		for (var i = 0; i < miningLasers.length; i++) {
			var miningLaser = miningLasers[i];
			ige.network.send('removeEffect', NetworkUtils.effect('miningLaser', miningLaser, targetBlock));
		}
	},

	controls: function(newControls) {
		if (newControls === undefined) {
			return this._controls;
		}

		if (this.controllable()) {
			this._controls = newControls;
		}

		return this;
	},

	controllable: function() {
		return this.bridgeBlocks().length > 0;
	},

	update: function(ctx) {
		BlockStructure.prototype.update.call(this, ctx);

		if (ige.isServer) {
			/* Process Firing Weapons */
			this.updateFiringWeapons();

			/* Angular motion */
			// Angular rotation speed depends on number of thrusters
			if (this.controls().left || this.controls().right) {
				var angularImpulse = 0;
				for (var i = 0; i < this.thrusters().length; i++) {
					angularImpulse += this.thrusters()[i].thrust.value;
				}
				angularImpulse = -angularImpulse * ige._tickDelta;

				if (this.thrusters().length < 1) {
					if (JSON.stringify(this.controls()) !== JSON.stringify(this._prev_controls) ||
						this._prevMovementBlocks.thrusters > 0) {

						ige.network.stream.queueCommand('notificationError',
							NotificationDefinitions.errorKeys.noRotationalThruster, this.player().clientId());
					}
				}
				this._prevMovementBlocks.thrusters = this.thrusters().length;

				if (this.controls().left) {
					this.physicsBody.applyAngularImpulse(angularImpulse);
				}
				if (this.controls().right) {
					this.physicsBody.applyAngularImpulse(-angularImpulse);
				}
			}

			if (this.controls().up || this.controls().down) {
				// Notify player that they cannot fly without an engine
				if (this.engines().length < 1) {
					if (JSON.stringify(this.controls()) !== JSON.stringify(this._prev_controls) ||
						this._prevMovementBlocks.engines > 0) {
						ige.network.stream.queueCommand('notificationError',
							NotificationDefinitions.errorKeys.noEngine, this.player().clientId());
					}
				}
				this._prevMovementBlocks.engines = this.engines().length;

				var linearImpulse = 3 * ige._tickDelta;
				if (this._controls.up) {
					linearImpulse = linearImpulse;
				}
				else if (this._controls.down) {
					linearImpulse = -linearImpulse;
				}

				// The "- Math.PI/2" below makes the ship move forward and backwards,
				// instead of side to side.
				var angle = this._rotate.z - Math.PI/2;

				// Notify player that they cannot fly without an engine
				if (this.engines().length < 1) {
					if (JSON.stringify(this._controls) !== JSON.stringify(this._prev_controls) ||
						this._prevMovementBlocks.engines > 0) {
						ige.network.stream.queueCommand('notificationError',
							NotificationDefinitions.errorKeys.noEngine, this.player().clientId());
					}
				}

				this._prevMovementBlocks.engines = this.engines().length;

				// Apply impulse at all engine locations
				for (var i = 0; i < this.engines().length; i++) {
					var engine = this.engines()[i];

					var linearImpulse = engine.thrust.value * ige._tickDelta;
					if (this._controls.down) {
						linearImpulse = -linearImpulse;
					}

					var impulseX = MathUtils.round(Math.cos(angle) * linearImpulse);
					var impulseY = MathUtils.round(Math.sin(angle) * linearImpulse);

					var enginePosition = BlockGrid.coordinatesForBlock(engine);

					var opts = {impulseX: impulseX, impulseY: impulseY,
						posX: enginePosition.x, posY: -enginePosition.y};
					this.physicsBody.applyLinearImpulseLocal(opts);

				}
			}

			// Update previous controls so we can tell what has changed each update.
			// We want to send engine missing notifications on a change, not every
			// update
			this._prev_controls = JSON.parse(JSON.stringify(this.controls()));
		}
	},

	updateFiringWeapons: function() {
		_.forEach(this.firingWeapons(), function(weapon) {
			weapon.firingUpdate();
		});
	}
});

/**
* The radius from the center of the world within which ships will spawn.
* @constant {number}
* @default
* @memberof Ship
*/
Ship.SHIP_START_RADIUS = 4000;

/**
* The Box2D category of all ship entities. Used by Box2D to determine what to do in certain collision scenarios.
* @constant {string}
* @default
* @memberof Ship
*/
Ship.BOX2D_CATEGORY_BITS = 0x0001;
Ship.ATTRACTOR_BOX2D_CATEGORY_BITS = 0x0002;
/**
* The default depth layer for {@link Ship}s when rendered to the screen. Should be rendered above other
* {@link BlockGrid}s.
* @constant {number}
* @default
* @memberof Ship
*/
Ship.DEPTH = 2;

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Ship;
}
;/**
 * ClientState.js
 *
 * The ClientState object manages the current client state and handles switching
 * between different client game states and activating each states' associated capabilities.
 *
 * @author Derrick Liu
 * @class
 * @typedef {Object} Capability
 * @namespace  
 */
var ClientState = IgeClass.extend({
	classId: 'ClientState',

	/**
	 * The possible selected caps and the states that they induce.
	 * @type {Object}
   * @memberof ClientState
   * @instance
   * @private
	 */
	capStates: {
		'': 'idle',
		'MineCap': 'mine',
		'ConstructCap': 'construct'
	},

	/**
	 * Capabilities associated with states above.
	 * @type {Object}
   * @memberof ClientState
   * @instance
   * @private
	 */
	capabilities: {
		'mine': undefined,
		'construct': undefined,
		'idle': undefined
	},

	/**
	 * The currently selected capability identifier.
	 * @type {string}
   * @memberof ClientState
   * @instance
   * @private
   */
	_selectedCap: undefined,

	/**
	 * Initializes the capbar state handler and capabilities
   * @memberof ClientState
   * @instance
   */
	init: function() {
		this._initEvents();
		this._initCapabilities();

		// Default selected capability
		this.selectedCap('');
	},

	/**
	 * Initializes the capbar state handler and capabilities
   * @memberof ClientState
   * @instance
   * @private
   */
	_initEvents: function() {
		var self = this;

		ige.on('capbar cap selected', function(classId) {
			self.selectedCap(classId);
		});

		ige.on('capbar cap cleared', function(classId) {
			// Only reset to idle if we just deselected the current capability
			if (self.selectedCap() === self.capStates[classId]) {
				self.selectedCap('');
			}
		});
	},

	/**
	 * Initializes the capbar state handler and capabilities
   * @memberof ClientState
   * @instance
   * @private
   */
	_initCapabilities: function() {
		this.capabilities.mine = new MineCapability();
		this.capabilities.construct = new ConstructCapability();
		this.capabilities.idle = new Capability();
	},

	/**
	 * Select the currently active capability by choosing a cap, or get the currently active capability's identifier
	 * @param cap {string} the cap whose analogous capability to activate
	 * @returns {string} the current capability state identifier
	 * @memberof ClientState
   * @instance
   */
	selectedCap: function(cap) {
		if (cap !== undefined) {
			if (this._selectedCap !== undefined) {
				this.capabilities[this._selectedCap].deactivate();
			}

			if (this.capStates.hasOwnProperty(cap)) {
				this._selectedCap = this.capStates[cap];
			} else {
				this._selectedCap = this.capStates[''];
				console.error('invalid cap selected, reset to idle...');
			}

			this.capabilities[this._selectedCap].activate();

			this.log("Player selected " + this._selectedCap + " in capbar", 'info');
			ige.emit('clientstate selected cap changed', [this._selectedCap]);
		}

		return this._selectedCap;
	},

	// TODO: Support multiple current capabilities (active, passive)
	/**
	 * Gets the actual capability object associated with the currently selected capability.
	 * @returns {Object} the current capability's object
	 * @memberof ClientState
   * @instance
   */
	currentCapability: function() {
		return this.capabilities[this.selectedCap()];
	}
});

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = ClientState;
};/**
 * Capability.js
 * Capabilities are modules that encapsulate gameplay state, state-checking,
 * and functions that perform actions in a way that is easily extensible and
 * maintainable. Capabilities can also store info that's related to a particular
 * state.
 *
 * @author Derrick Liu
 * @class
 * @typedef {Object} Capability
 * @namespace
 */
var Capability = IgeClass.extend({
	classId: "Capability",

  /**
   * Represents the events that the capability listens for and acts upon. Should
   * be defined in subclasses, but a default is defined in {@link Capability#init}
   * for reference.
   * @type {Object}
   * @memberof Capability
   * @instance
   * @private
   */
	registeredEvents: undefined,

	/**
	 * Initialize the capability with some default registered events.
	 * @memberof Capability
	 * @instance
	 */
	init: function() {
		if (this.registeredEvents === undefined) {
			this.registeredEvents = {
				'Block': {
					'mousedown': {
						// Note: Since calling this in either the conditionFunc or actionFunc will
						// refer to this object (the one this comment is in), we include
						// the capability field to allow easy access to the Capability object itself.
						capability: this,
						conditionFunc: this.Block_canMouseDown,
						actionFunc: this.Block_mouseDown
					}
				},
				'ClickScene': {
					'mousedown': {
						capability: this,
						conditionFunc: this.ClickScene_canMouseDown,
						actionFunc: this.ClickScene_mouseDown
					}
				}
			};
		}
	},

	/**
	 * Stub functions implemented by child classes that are called
	 * when Capabilities are activated by ClientState
	 * @memberof Capability
	 * @instance
	 */
	activate: function() {
		return this;
	},

	/**
	 * Stub functions implemented by child classes that are called
	 * when Capabilities are deactivated by ClientState
	 * @memberof Capability
	 * @instance
	 */
	deactivate: function() {
		return this;
	},

	/**
	 * Selects a registered event from the registeredEvents list that is the most relevant
	 * to the entity type / event type pair provided.
	 *
	 * If a registered event does not exactly match the entity classId, this method will
	 * traverse up the entity class hierarchy in case a parent classId is registered.
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @returns {string} the classId of a registered event, or undefined if none can be found
	 * @memberof Capability
	 * @instance
	 */
	selectRegistration: function(sender, event) {
		var selectedClass, currentPrototype = sender;

		var traversalIterations = 0;
		while (true) {
			// If we've driven off the end of the class hierarchy (or there seems to be a loop somewhere), abort!
			if (currentPrototype === null ||
				currentPrototype.classId === undefined ||
				traversalIterations > 10) {
				return undefined;
			}

			if (this.registeredEvents.hasOwnProperty(currentPrototype.classId())) {
				selectedClass = currentPrototype.classId();
				break;
			}

			currentPrototype = Object.getPrototypeOf(currentPrototype);
			traversalIterations++;
		}

		if (this.registeredEvents[selectedClass].hasOwnProperty(event.type)) {
			return selectedClass;
		} else {
			return undefined;
		}
	},

	/**
	 * Checks whether or not an event action can be performed in the current game state.
	 *
	 * Calls the conditionFunc associated with the registered event for this entity/event pair.
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc and actionFunc
	 * @returns {boolean} whether or not the event action can be performed
	 * @memberof Capability
	 * @instance
	 */
	canDo: function(sender, event, data) {
		// Check if we have this event and sender registered for this capability
		var selectedClass = this.selectRegistration(sender, event);
		if (selectedClass === undefined) {
			console.warn("Event type (" + event.type + ") / sender (" + sender.classId() + ") not registered!");
			return false;
		}

		// The event and sender are registered, so we can handle it.
		return this.registeredEvents[selectedClass][event.type].conditionFunc(sender, event, data);
	},

	/**
	 * Default stub for demonstrating a conditionFunc
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof Capability
	 * @instance
	 */
	Block_canMouseDown: function(sender, event, data) {
		return true;
	},

	/**
	 * Default stub for demonstrating a conditionFunc
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof Capability
	 * @instance
	 */
	ClickScene_canMouseDown: function(sender, event, data) {
		return true;
	},

	/**
	 * Performs a registered event action for the entity/event pair.
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof Capability
	 * @instance
	 */
	performAction: function(sender, event, data) {
		// Check if we have this event and sender registered for this capability
		var selectedClass = this.selectRegistration(sender, event);
		if (selectedClass === undefined) {
			console.warn("Event type (" + event.type + ") / sender (" + sender.classId() + ") not registered!");
			return;
		}

		this.registeredEvents[selectedClass][event.type].actionFunc(sender, event, data);
	},

	/**
	 * Default stub for demonstrating an actionFunc
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof Capability
	 * @instance
	 */
	Block_mouseDown: function(sender, event, data) {
		console.log("IdleCapability: received mouseDown (button " + event.button + ") on a block (classId: " + sender.classId() + ", id: " + sender.id() + "!");
	},

	/**
	 * Default stub for demonstrating an actionFunc
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof Capability
	 * @instance
	 */
	ClickScene_mouseDown: function(sender, event, data) {
		console.log("IdleCapability: received mouseDown (button " + event.button + ") on the background!");
	},

	/**
	 * Convenience function to test using canDo and act using performAction in one fell swoop.
	 *
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc and actionFunc
	 * @returns {boolean} whether or not the action was performed
	 * @memberof Capability
	 * @instance
	 */
	tryPerformAction: function(sender, event, data) {
		if (this.canDo(sender, event, data)) {
			this.performAction(sender, event, data);
			return true;
		}

		return false;
	}
});

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = Capability;
}
;/**
 * ConstructCapability.js
 * The ConstructCapability implementation encapsulates state checking and event
 * handling that drives the construction game mechanic. Specifically, it listens
 * for clicks on existing blocks, and on the background, for CXB (construction
 * on existing blockgrids) and CNB (construction of new blockgrids).
 *
 * @author Derrick Liu
 * @class
 * @typedef {Object} ConstructCapability
 * @namespace
 */
var ConstructCapability = Capability.extend({
	classId: "ConstructCapability",
	selectedType: undefined,
	_toolbarListener: undefined,

	/**
	 * Initialize with ConstructCapability event registration
	 * @memberof ConstructCapability
	 * @instance
	 */
	init: function() {
		this.registeredEvents = {
			'ClickScene': {
				'mousedown': {
					capability: this,
					conditionFunc: this.ClickScene_canMouseDown,
					actionFunc: this.ClickScene_mouseDown
				}
			},
			'ConstructionOverlay': {
				'mousedown': {
					capability: this,
					conditionFunc: this.ConstructionOverlay_canMouseDown,
					actionFunc: this.ConstructionOverlay_mouseDown
				}
			},
			'Block': {
				'mousedown': {
					capability: this,
					conditionFunc: this.Block_canMouseDown,
					actionFunc: this.Block_mouseDown
				}
			}
		};
	},

	/**
	 * Upon activation, registers this capability as a listener on the Construction toolbar
	 * so the capability can store state about the currently selected item on the toolbar.
	 * @memberof ConstructCapability
	 * @instance
	 */
	activate: function() {
		this.log("Activating... registering event listener.", 'info');

		return this;
	},

	/**
	 * Upon deactivation, unregisters this capability as a toolbar listener.
	 * @memberof ConstructCapability
	 * @instance
	 */
	deactivate: function() {
		this.log("Deactivating... deregistering event listener.", 'info');

		return this;
	},

	/**
	 * Checks to see if the player has the construct cap selected and an itemType selected.
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof ConstructCapability
	 * @instance
	 */
	ClickScene_canMouseDown: function(sender, event, data) {
		// Notify player that no block type is selected
		if (ige.hud.leftToolbar.windows.cargo.selectedType === undefined) {
			ige.notification.emit('notificationError',
				NotificationDefinitions.errorKeys.noItemTypeSelected);
		}
		return (ige.client.state.selectedCap() === 'construct' && ige.hud.leftToolbar.windows.cargo.selectedType !== undefined);
	},

	/**
	 * Sends a command to the server to create a new block at the point clicked.
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof ConstructCapability
	 * @instance
	 */
	ClickScene_mouseDown: function(sender, event, data) {
		data.selectedType = ige.hud.leftToolbar.windows.cargo.selectedType;
		ige.client.metrics.track('cosmos:construct.attempt.new', {'type': ige.hud.leftToolbar.windows.cargo.selectedType});
		ige.network.send('constructNew', data);
	},

	/**
	* Checks to see if the player has the construct cap selected
	* @param sender {Object} an entity upon which an event was triggered
	* @param event {Object} the triggering event
	* @param data {Object} provided data that can be used in conditionFunc
	* @memberof ConstructCapability
	* @instance
	*/
	Block_canMouseDown: function(sender, event, data) {
		return (ige.client.state.selectedCap() === 'construct');
	},

	/**
	* Sends a command to the server to collect the block at the point clicked into the cargo.
	* @param sender {Object} an entity upon which an event was triggered
	* @param event {Object} the triggering event
	* @param data {Object} provided data that can be used in actionFunc
	* @memberof ConstructCapability
	* @instance
	*/
	Block_mouseDown: function(sender, event, data) {
		ige.client.metrics.track('cosmos:construct.attempt.deconstruct');

		data = {
			blockId: sender.id()
		};
		ige.network.send('deconstructionZoneClicked', data);
	},

	/**
	 * Checks to see if the player has the construct cap selected and an itemType selected.
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof ConstructCapability
	 * @instance
	 */
	ConstructionOverlay_canMouseDown: function(sender, event, data) {
		// Notify player that no block type is selected
		if (ige.hud.leftToolbar.windows.cargo.selectedType === undefined) {
			ige.notification.emit('notificationError',
				NotificationDefinitions.errorKeys.noItemTypeSelected);
		}

		return (ige.client.state.selectedCap() === 'construct' &&
			ige.hud.leftToolbar.windows.cargo.selectedType !== undefined);
	},

	/**
	 * Sends a command to the server to create a new block at the point clicked.
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof ConstructCapability
	 * @instance
	 */
	ConstructionOverlay_mouseDown: function(sender, event, data) {
		data.selectedType = ige.hud.leftToolbar.windows.cargo.selectedType;
		ige.client.metrics.track('cosmos:construct.attempt.existing',
			{'type': ige.hud.leftToolbar.windows.cargo.selectedType});

		ige.network.send('constructionZoneClicked', data);
	}
});
;/**
 * MineCapability.js
 * The MineCapability implementation encapsulates state checking and event
 * handling that drives the mining game mechanic. Specifically, it listens
 * for clicks on existing blocks and checks to see if they're minable.
 *
 * @author Derrick Liu
 *
 * @class
 * @typedef {Object} MineCapability
 * @namespace
 */
var MineCapability = Capability.extend({
	classId: "MineCapability",

	/**
	 * Initialize with MineCapability event registration
	 * @memberof MineCapability
	 * @instance
	 */
	init: function() {
		this.registeredEvents = {
			'Block': {
				'mousedown': {
					capability: this,
					conditionFunc: this.Block_canMouseDown,
					actionFunc: this.Block_mouseDown
				}
			},
			'ClickScene': {
				'mousedown': {
					capability: this,
					conditionFunc: this.ClickScene_canMouseDown,
					actionFunc: this.ClickScene_mouseDown
				}
			}
		};

		Capability.prototype.init.call(this);
	},

	/**
	 * Checks to see if the player has the mining cap selected
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof MineCapability
	 * @instance
	 */
	Block_canMouseDown: function(sender, event, data) {
		return (ige.client.state.selectedCap() === 'mine');
	},

	/**
	 * Send a command to the server to attempt mining the block that was just clicked on.
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in actionFunc
	 * @memberof MineCapability
	 * @instance
	 */
	Block_mouseDown: function(sender, event, data) {
		data = {
			x: sender.mousePosWorld().x,
			y: sender.mousePosWorld().y
		};

		_.forEach(ige.client.player.currentShip().weapons(), function(weapon) {
			weapon.fireClient(data);
		});

		/*if (sender.parent().parent() instanceof Ship) {
			ige.client.metrics.track('cosmos:block.attack', {'type': sender.classId()});//note that this includes when you mine yourself
		} else {
			ige.client.metrics.track('cosmos:block.mine', {'type': sender.classId()});
		}*/
	},

	/**
	 * Notifies the player that they cannot mine empty space
	 * @param sender {Object} an entity upon which an event was triggered
	 * @param event {Object} the triggering event
	 * @param data {Object} provided data that can be used in conditionFunc
	 * @memberof MineCapability
	 * @instance
	 */
	ClickScene_canMouseDown: function(sender, event, data) {
		// TODO: Fire lasers individually-- understand which laser is selected. For now, all lasers
		// are fired together.

		return (ige.client.state.selectedCap() === 'mine');
	},

	ClickScene_mouseDown: function(sender, event, data) {
		_.forEach(ige.client.player.currentShip().weapons(), function(weapon) {
			weapon.fireClient(data);
		});
	}
});
;/* Crafting system
 * This is an IGE system
 * This system is meant to be initialized client-side and server-side.
 */

var CraftingSystem = IgeEventingClass.extend({
	classId: 'CraftingSystem',
	componentId: 'craftingSystem',


	init: function(entity, options) {
		if (ige.isServer) {
			ige.network.define('cosmos:crafting.craft', this._craftServer);
			ige.network.define('cosmos:crafting.addRecipe');
			ige.network.define('cosmos:CraftingSystem._craftServer.success');
		}
		if (ige.isClient) {
			ige.network.define('cosmos:crafting.addRecipe', this._addRecipeClient);
			ige.network.define('cosmos:CraftingSystem._craftServer.success', this._onCraftServerSuccess);

			var self = this;
			// TODO: The crafting state should update as cargo information comes in. For now, we're
			// just refreshing crafting state once at the beginning because crafting isn't yet
			// smart enough to show you what you can or cannot craft.
			ige.on('cosmos:client.player.currentShip.ready', function() {
				self._refreshCraftingState();
			});
		}
		this.log('Crafting system initiated!');
	},

	// Called by the client to craft an item. This sends a network command to the
	// server to do the actual crafting verification
	craftClient: function(recipeName) {
		ige.network.send('cosmos:crafting.craft', recipeName);
	},

	// Called by the server in response to a client craft request. This verifies
	// and does the crafting.
	_craftServer: function (data, clientId) {
		var player, cargo, recipeName;

		// Check if player exists
		player = ige.server.players[clientId];
		if (player === undefined) {
			ige.craftingSystem.log('CraftingSystem#_craftServer: Player is undefined', 'warning');
			return;
		}
		// Check if player cargo exists
		cargo = player.currentShip().cargo;
		if (cargo === undefined) {
			ige.craftingSystem.log('CraftingSystem#_craftServer: Cargo is undefined', 'warning');
			return;
		}
		recipeName = data;
		// Check if recipe exists in the game
		if (!Recipes.hasOwnProperty(recipeName)) {
			ige.craftingSystem.log('CraftingSystem#_craftServer: Recipe does not exist', 'warning');
			return;
		}

		if (ige.craftingSystem._canCraft(cargo, player, recipeName)) {
			ige.craftingSystem._doCraft(cargo, player, recipeName);
			ige.network.stream.queueCommand('cosmos:CraftingSystem._craftServer.success',
				recipeName, clientId);
		}

	},

	/**
	 * Checks if the recipe is craftable by the player.
	 * A recipe is craftable if the player has:
	 * 1. The recipe unlocked
	 * 2. The correct number of reactant blocks in cargo
	 * 3. The correct number of equipment blocks on the ship
	 * 4. Space in their cargo for the products
	 * @param cargo {Cargo}
	 * @param player {Player}
	 * @param recipeName {String}
	 * @returns {Boolean} True if the recipe is craftable
	 */
	_canCraft: function(cargo, player, recipeName) {
		var clientId = player.clientId();
		var cargoItems = cargo.items();
		// Check if the player has this recipe unlocked
		if (!player.crafting.recipes().hasOwnProperty(recipeName)) {
			ige.network.stream.queueCommand('notificationError',
				NotificationDefinitions.errorKeys.crafting_recipeNotUnlocked,
				clientId);
			return false;
		}
		var recipe = Recipes[recipeName];
		// Check for correct number of reactant blocks in cargo
		for (var i = 0; i < recipe.reactants.length; i++) {
			var reactant = recipe.reactants[i];
			if (!cargoItems.hasOwnProperty(reactant.blockType) ||
				cargoItems[reactant.blockType] < reactant.quantity)
			{
				ige.network.stream.queueCommand('notificationError',
					NotificationDefinitions.errorKeys.crafting_insufficientReactants,
					clientId);
				return false;
			}
		}

		for (var i = 0; i < recipe.equipment.length; i++) {
			var equipment = recipe.equipment[i];
			if (player.blocksOfType(equipment).length < equipment.quantity) {
				ige.network.stream.queueCommand('notificationError',
					NotificationDefinitions.errorKeys.crafting_insufficientEquipment,
					clientId);
				return false;
			}
		}

		// Check if there is enough room in the cargo for the products
		// Net space needed = products - reactants. For now, all recipes have one product so start this variable
		// at 1.
		// TODO: When cargo has limits, make sure to check if there is enough space.
		/*var spaceNeeded = 1;
		_.forEach(recipe.reactants, function(reactant) {
			spaceNeeded -= reactant.quantity;
		});
		if (!cargo.spaceAvailable(spaceNeeded)) {
			ige.network.stream.queueCommand('notificationError',
				NotificationDefinitions.errorKeys.crafting_insufficientCargoSpace,
				clientId);
		}*/

		return true;
	},

	/**
	 * Removes reactants from cargo and adds products to cargo
	 * This should be called after _canCraft()
	 */
	_doCraft: function(cargo, player, recipeName) {
		var recipe = Recipes[recipeName];
		// Consume reactants. Remove them from cargo
		_.forEach(recipe.reactants, function(reactant) {
			cargo.remove(reactant.blockType, reactant.quantity);
		});

		cargo.add(recipeName);

		DbPlayer.update(player.id(), player, function() {});
	},

	// @client-side
	_onCraftServerSuccess: function(data) {
		var recipeName = data;

		ige.notification.emit('notificationSuccess', NotificationDefinitions.successKeys.crafting_success);
		ige.craftingSystem.emit('cosmos:CraftingSystem.craft.success', recipeName);
		ige.client.metrics.track('cosmos:CraftingSystem.craft.success', {'recipeName': recipeName});
	},

	// Add a recipe to a player
	addRecipeServer: function(recipe, player, clientId) {
		player.crafting.addRecipe(recipe);
		ige.network.stream.queueCommand('cosmos:crafting.addRecipe', recipe, clientId);
	},

	// Keep the client side recipe list in sync
	_addRecipeClient: function(data) {
		var recipe = data;
		ige.client.player.crafting.addRecipe(recipe);
	},

	// Keep client side crafting state consistent
	_refreshCraftingState: function(data) {
		//var cargoItems = data;
		//ige.client.player.crafting.resetCraftableRecipes();
		// TODO: Refresh craftable recipes based on cargoItems
		ige.hud.leftToolbar.windows.craftingUI.refresh();
	},

	// TODO:Serialize and persist to DB
	serializeRecipes: function() {
	},

	rehydrateRecipes: function () {
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CraftingSystem; }
;/* Crafting component
 * This is a player component
 * This component is meant to be initialized client-side and server-side
 */

var CraftingComponent = IgeEventingClass.extend({
	classId: 'CraftingComponent',
	componentId: 'crafting',
	// All the recipes the player knows
	_recipes: undefined,
	// The recipes that are craftable (correct number of reactants in cargo)
	_craftableRecipes: undefined,

	init: function(entity, options) {
		// TODO: Client side crafting should have an idea of the cargo. This allows
		// uncraftable things to be grayed out. Pending cargo refactor

		// TODO: Load unlocked recipes from DB. For now, we have a
		// predefined set of recipes.
		this._recipes = CraftingComponent.starterRecipes();
		this._craftableRecipes = CraftingComponent.starterRecipes();
	},

	recipes: function() {
		return this._recipes;
	},

	addRecipe: function(recipe) {
		this._recipes[recipe] = true;
	},

	craftableRecipes: function() {
		return this._craftableRecipes;
	},

	addCraftableRecipe: function(recipe) {
		this._craftableRecipes[recipe] = true;
	},

	resetCraftableRecipes: function() {
		this._craftableRecipes = {};
	}
});

/**
 * List of block types that can be initially crafted
 */
CraftingComponent.starterRecipes = function() {
	// Create an object that has the same keys as the Recipes object and has the value true
	// for all keys. In effect, this is a basic starter recipes set that includes all the
	// recipes in the game.
	var starterRecipes = _.mapValues(Recipes, function(blockType) {
		return true;
	});

	return starterRecipes;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CraftingComponent; }
;var QuestSystem = IgeEventingClass.extend({
	classId: 'QuestSystem',
	componentId: 'questSystem',

	init: function() {
		if (ige.isServer) {
			ige.network.define('cosmos:quest.addQuest');
			ige.network.define('cosmos:quest.removeQuest');
			ige.network.define('cosmos:quest.eventToClient');
			ige.network.define('cosmos:quest.eventToServer', this._onEventToServer);
			// The client uses this to ask the server if it can start a quest
			ige.network.define('cosmos:quest.requestStartQuest', this._onRequestStartQuest);
		}
		if (ige.isClient) {
			ige.network.define('cosmos:quest.addQuest', this._addQuestClient);
			ige.network.define('cosmos:quest.removeQuest', this._removeQuestClient);
			ige.network.define('cosmos:quest.eventToClient', this._onEventToClient);
			ige.addBehaviour('questStepClient', this._questStepClient);
			// Show the tutorial for the guest user and the logged in guest user
			ige.on('cosmos:NamePrompt.hide', this._tutorialQuest, this, true);
			ige.on('cosmos:client.ship.streamed', this._tutorialQuest, this, true);
		}
		this.log('Quest system initiated');
	},

	/* Handles client attempts to start quests */
	// @server-side
	_onRequestStartQuest: function(data, clientId) {
		// Check if player exists
		var player = ige.server.players[clientId];
		if (player === undefined) {
			ige.questSystem.log('QuestSystem#_onRequestStartQuest: Player is undefined', 'warning');
			return;
		}
		var questName = data;

		// Verify player has unlocked this quest
		var unlockedQuests = player.quest.unlockedQuests();
		if (!unlockedQuests.hasOwnProperty(questName)) {
			ige.questSystem.log('QuestSystem#_onRequestStartQuest: Quest not unlocked', 'warning');
			return;
		}

		ige.questSystem.addQuestServer(questName, player);
	},

	// @server-side
	addQuestServer: function(questName, player) {
		// Get the next available instance number
		var instance = player.quest.getNextInstance(questName);
		player.quest.addQuest(questName, instance);
		var data = [questName, instance];
		ige.network.stream.queueCommand('cosmos:quest.addQuest', data, player.clientId());
	},

	// @client-side
	_addQuestClient: function(data) {
		var questName = data[0];
		var questInstance = data[1];
		ige.client.player.quest.addQuest(questName, questInstance);

		ige.questSystem.log('QuestSystem: Quest ' + questName + ' ' +
			questInstance + ' added!', 'info');
	},

	// @server-side
	removeQuestServer: function(quest, player) {
		var questName = quest.classId();
		var questInstance = quest.instance;
		delete player.quest.activeQuests()[questName][questInstance];

		// Delete quest client-side
		var data = [questName, questInstance];
		ige.network.stream.queueCommand('cosmos:quest.removeQuest', data, player.clientId());
	},

	// @client-side
	_removeQuestClient: function(data) {
		var questName = data[0];
		var questInstance = data[1];
		delete ige.client.player.quest.activeQuests()[questName][questInstance];

		ige.questSystem.log('QuestSystem: Quest ' + questName + ' ' +
			questInstance + ' removed!', 'info');
	},

	/* Sends a quest event to the server. */
	// @client-side
	eventToServer: function(event, quest) {
		var data = [quest.classId(), quest.instance, event]
		ige.network.send('cosmos:quest.eventToServer', data);
	},

	/* Receives a quest event from the client and emits it on the server's quest */
	// @server-side
	_onEventToServer: function(data, clientId) {
		// Check if player exists
		var player = ige.server.players[clientId];
		if (player === undefined) {
			ige.questSystem.log('QuestSystem#_onEventToServer: Player is undefined', 'warning');
			return;
		}
		var questName = data[0];
		var questInstance = data[1];
		var event = data[2];

		// Verify quest name
		var activeQuests = player.quest.activeQuests();
		if (!activeQuests.hasOwnProperty(questName)) {
			ige.questSystem.log('QuestSystem#_onEventToServer: Quest name not found', 'warning');
			return;
		}
		// Verify quest instance
		var instances = activeQuests[questName];
		if (!instances.hasOwnProperty(questInstance)) {
			ige.questSystem.log('QuestSystem#_onEventToServer: Quest instance not found', 'warning');
			return;
		}

		// Retrieve the specific quest
		var quest = instances[questInstance];

		// Emit an event on the quest
		quest.emit(event, [player]);
	},

	/* Sends an event to a quest on the client */
	// TODO: Build more functionality as needed when quests need more server
	// interaction
	// @server-side
	eventToClient: function(event, quest, clientId) {
		var data = [quest.classId(), quest.instance, event];
		ige.network.stream.queueCommand('cosmos:quest.eventToClient', data,
			clientId);
	},

	/* Receives an event from the server and emits it on the appropriate quest. */
	// @client-side
	_onEventToClient: function(data) {
		var questName = data[0];
		var questInstance = data[1];
		var event = data[2];

		// Retrieve the specific quest
		var quest = ige.client.player.quest.activeQuests()[questName][questInstance];

		// Emit an event on the quest
		quest.emit(event);
	},

	/* Loops over the player's active quests and runs their logic */
	// @client-side
	_questStepClient: function(ctx) {
		// Don't start until the player is streamed
		if (ige.client.player === undefined) {
			return;
		}

		var questComponent = ige.client.player.quest;
		var activeQuests = questComponent.activeQuests();
		// Loop over all quest names
		for (questName in activeQuests) {
			if (activeQuests.hasOwnProperty(questName)) {
				var instances = activeQuests[questName];
				// Loop over all instances of a quest name
				for (instance in instances) {
					if (instances.hasOwnProperty(instance)) {
						// Process behavior for that quest
						var quest = instances[instance];
						quest.processStep();
					}
				}
			}
		}
	},

	/**
	 * Runs when guest name window is hidden. Prompts the user if they want to
	 * start the tutorial quest
	 */
	// @client-side
	_tutorialQuest: function() {
		// TODO: This is sort of hacky. We want a unified way of showing new
		// players the tutorial
		if ((ige.namePrompt !== undefined && !ige.namePrompt.hidden) ||
			(ige.client.player.loggedIn() && !ige.client.player.hasGuestUsername)) {
			return;
		}
		var message = "Hi! We noticed that you are a guest user." + "<br>" +
			"Would you like to complete a short in-game tutorial?";
		alertify.confirm(message, function (e) {
			if (e) {
				var questName = TutorialQuest.prototype.classId();
				ige.network.send('cosmos:quest.requestStartQuest', questName);
				ige.client.metrics.track('cosmos:quest.tutorialQuest.clicked');
			} else {
				ige.client.metrics.track('cosmos:quest.tutorialQuest.skipped');
			}
		});
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = QuestSystem; }
;var QuestComponent = IgeEventingClass.extend({
	classId: 'QuestComponent',
	componentId: 'quest',
	
	_activeQuests: undefined,
	_unlockedQuests: undefined,

	init: function(entity, options) {
		this._activeQuests = {};
		// TODO: Load unlocked quests from DB
		this._unlockedQuests = {'TutorialQuest': true};
	},

	activeQuests: function() {
		return this._activeQuests;
	},

	unlockedQuests: function() {
		return this._unlockedQuests;
	},

	addQuest: function(questName, instance) {

		var globalContext = (ige.isServer) ? global : window;
		if (this._activeQuests.hasOwnProperty(questName)) {
			var quests = this._activeQuests[questName];
			if (quests.hasOwnProperty(instance)) {
				this.log('QuestComponent#addQuest: Quest already exists!', 'warn');
				return;
			}
		}
		this._activeQuests[questName] = this._activeQuests[questName] || {};
		this._activeQuests[questName][instance] = new globalContext[questName](instance);
	},

	removeQuest: function(questName, instance) {
		var globalContext = (ige.isServer) ? global : window;
		if (this._activeQuests.hasOwnProperty(questName)) {
			var quests = this._activeQuests[questName];
			if (quests.hasOwnProperty(instance)) {
				delete quests[instance];
				return;
			}
		}
		this.log('QuestComponent#removeQuest: Quest does not exist!', 'warn');
	},

	/**
	 * Returns the next available instance number for a given quest.
	 * @param {String}
	 * @return {Number}
	 */
	getNextInstance: function(questName) {
		var nextInstance = 0;

		if (this._activeQuests.hasOwnProperty(questName)) {
			var quests = this._activeQuests[questName];
			nextInstance = _.max(_.map(_.keys(quests),parseIntDecimal)) + 1;
		}
		return nextInstance;

		// Needed to create a partial function
		// TODO: Remove this when lodash 3 is released with placeholder partials
		function parseIntDecimal(val) {
			return parseInt(val, 10);
		}
	}


});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = QuestComponent; }
;var Quest = IgeEventingClass.extend({
	classId: 'Quest',
	// How far the player is in the quest
	questState: undefined,
	// The instance number of the quest. Some quests can be instantiated multiple times,
	// for example a "mine X blocks" quest
	instance: undefined,

	init: function(instance) {
		this.instance = instance;
	},


	// @client-side
	processStep: function() {
		var questState = this.questState;
		// TODO: Don't delete clientOnce; we might want to go back to a previous
		// quest state
		if (questState.clientOnce !== undefined) {
			questState.clientOnce.call(this);
			delete questState.clientOnce;
		}
		if (questState.clientStep !== undefined) {
			questState.clientStep.call(this);
		}
	}

});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = Quest; }
;var TutorialQuest = Quest.extend({
	classId: "TutorialQuest",

	init: function(instance) {
		Quest.prototype.init.call(this, instance);

		if (ige.isClient) {
			this.questState = this.welcome;
		}

		if (ige.isServer) {
			this.on(this.keys['mine'], this.mine.server, this);
			this.on(this.keys['collect'], this.collect.server, this);
			this.on(this.keys['complete'], this.complete.server, this);
		}
	},

	// Map messages to numbers to reduce bandwidth
	// This is important when quests require heavy client-server interaction
	// NOTE: values must be strings to work with IGE event system
	keys: {
		'mine': "1",
		'collect': "2",
		// The client sends a 'complete' message to the server when this quest is
		// completed
		'complete': "3",
	},

	welcome: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			welcomeMessage();

			function welcomeMessage() {
				var message = 'Welcome to Cosmos!';
				alertify.questLog(message, "", msgTimeout);
				setTimeout(tutorialMessage, msgTimeout / 2);
			}

			function tutorialMessage() {
				var message = "Let's get familiar with the controls, the WASD keys";
				alertify.questLog(message, "", msgTimeout);
				setTimeout(done, msgTimeout / 2);
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.welcome.completed");
				self.questState = self.moveForward;
			}

		},

		clientStep: function() {
		},
	},

	moveForward: {
		clientOnce: function () {
			var self = this;
			var msgTimeout = 2000;

			pressW();

			function pressW() {
				var questLog = alertify.questLog("Press W to move forward");
				var listener = ige.input.on("keyDown", function (event, keyCode) {
					if (keyCode === ige.input.key.w) {
						questLog.close();
						ige.input.off("keyDown", listener);
						alertify.questLog("Good! You\'ve moved forward!", "success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.moveForward.completed");
				self.questState = self.moveBackwards;
			}
		},

		clientStep: function() {
		}
	},

	moveBackwards: {
		clientOnce: function () {
			var self = this;
			var msgTimeout = 2000;

			pressS();

			function pressS() {
				var questLog = alertify.questLog("Press S to move backward");
				var listener = ige.input.on("keyDown", function (event, keyCode) {
					if (keyCode === ige.input.key.s) {
						questLog.close();
						ige.input.off("keyDown", listener);
						alertify.questLog("Great! You\'ve moved backward!", "success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.moveBackwards.completed");
				self.questState = self.rotateLeft;
			}
		},

		clientStep: function() {
		}
	},

	rotateLeft: {
		clientOnce: function () {
			var self = this;
			var msgTimeout = 2000;

			pressA();

			function pressA() {
				var questLog = alertify.questLog("Press A to rotate left");
				var listener = ige.input.on("keyDown", function (event, keyCode) {
					if (keyCode === ige.input.key.a) {
						questLog.close();
						ige.input.off("keyDown", listener);
						alertify.questLog("Sweet! You\'ve rotated left!", "success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.rotateLeft.completed");
				self.questState = self.rotateRight;
			}
		},

		clientStep: function() {
		}
	},

	rotateRight: {
		clientOnce: function () {
			var self = this;
			var msgTimeout = 2000;

			pressD();

			function pressD() {
				var questLog = alertify.questLog("Press D to rotate right");
				var listener = ige.input.on("keyDown", function (event, keyCode) {
					if (keyCode === ige.input.key.d) {
						questLog.close();
						ige.input.off("keyDown", listener);
						alertify.questLog("Awesome! You\'ve rotated right!", "success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.rotateRight.completed");
				self.questState = self.moveAround;
			}
		},

		clientStep: function() {
		}
	},

	moveAround: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			flyingMessage();

			function flyingMessage() {
				var delay = 1000;
				var repetition = 10;
				var message = 'Let\'s fly around for a bit using the WASD controls!\n';
				var questLog = alertify.questLog(message);

				// Display a count down timer so players know the quest is advancing
				var countdown = repetition;
				var intervalId = setInterval(function(){
					questLog.DOMElement.innerText = message + ' ' + countdown;
					if (--countdown <= 0) {
						clearInterval(intervalId);
						questLog.close();
						doneFlying();
					}
				}, delay);
			}

			function doneFlying() {
				alertify.questLog("Nice! Let's look at the minimap!",
					"success", msgTimeout);
				setTimeout(done, msgTimeout / 2);
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.moveAround.completed");
				self.questState = self.minimap;
			}
		},

		clientStep: function() {
		},

		server: function() {
		}
	},

	minimap: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 10000;

			minimapWelcome();

			function minimapWelcome() {
				ige.hud.minimap.addGlow();
				var message = "The mini-map is located near the lower right corner." + "<br>" +
					"It allows you to see more of the world.";
				alertify.questLog(message, '', msgTimeout);
				setTimeout(minimapExplain, msgTimeout / 2);
			}

			function minimapExplain() {
				var message = '<font style="color:#00ff00;"> You show up as green</font><br>' +
					'<font style="color:#ff0000;"> Other players show up as red</font><br>' +
					'<font style="color:#808080;"> Neutral objects show up as gray</font>';
				alertify.questLog(message, '', msgTimeout);
				setTimeout(minimapDone, msgTimeout / 2);
			}

			function minimapDone() {
				ige.hud.minimap.removeGlow();
				alertify.questLog("Let's try out some capabilities!",
					'success', 5000);
				setTimeout(done, 5000 / 2);
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.minimap.completed");
				self.questState = self.mine;
			}
		}

	},

	mine: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			clickMineButton();

			function clickMineButton() {
				var questLog = alertify.questLog("Click the mine button on the toolbar at the bottom of the screen");
				// Show the tooltip for the mine button
				ige.hud.bottomToolbar.capBar.mineCap.pinButtonTooltip();
				var listener = ige.on("capbar cap selected", function (classId) {
					if (classId === MineCap.prototype.classId()) {
						questLog.close();
						ige.off("capbar cap selected", listener);
						// Hide the tooltip
						ige.hud.bottomToolbar.capBar.mineCap.unpinButtonTooltip();
						mineBlock();
					}
				});
			}

			function mineBlock() {
				var questLog = alertify.questLog("Now, click on an asteroid to mine it");
				// First, set up listeners
				self.on(self.keys['collect'], function() { // Listen for block collection
					self.collect.collected = true;
				}, self, true);

				self.on(self.keys['mine'], function() { // Listen for block mined
					questLog.close();
					alertify.questLog("Magnificent! You've mined a block!", 'success', msgTimeout);
					setTimeout(done, msgTimeout / 2);
				}, self, true);

				// Then, ask the server
				ige.questSystem.eventToServer(self.keys['collect'], self);
				ige.questSystem.eventToServer(self.keys['mine'], self);
			}


			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.mine.completed");
				self.questState = self.collect;
			}
		},

		clientStep: function() {
		},

		// Tells the client that a block has been mined
		// @server-side
		server: function(player) {
			player.on('cosmos:Element.onDeath.newDrop', function(drop) {
				ige.questSystem.eventToClient(this.keys['mine'], this, player.clientId());
			}, this, true);
		}
	},

	collect: {
		// Indicates if a block has been collected
		collected: false,

		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			// If a block is already collected, don't tell player to collect the block
			if (this.collect.collected) {
				alertify.questLog("Glorious! You've collected a block! You will " +
					"automatically collect blocks near you.", 'success', msgTimeout);
				setTimeout(done, msgTimeout / 2);
			}
			else {
				collectBlock();
			}

			function collectBlock() {
				var questLog = alertify.questLog("Move your ship towards the dropped block to collect it.");
				// First, set up listener
				self.on(self.keys['collect'], function() {
					questLog.close();
					alertify.questLog("Glorious! You've collected a block!", 'success', msgTimeout);
					setTimeout(done, msgTimeout / 2);
				}, self, true);
				// Then, ask the server if we have collected a drop
				ige.questSystem.eventToServer(self.keys['collect'], self);
			}


			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.collect.completed");
				self.questState = self.cargo;
			}
		},

		clientStep: function() {
		},

		// Tells the client that a drop has been collected
		// @server-side
		server: function(player) {
			player.on('cosmos:Ship.blockCollected', function(drop) {
				ige.questSystem.eventToClient(this.keys['collect'], this, player.clientId());
			}, this, true);
		}
	},

	// TODO: Skip this if the cargo window is already open
	cargo: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			clickCargoButton();

			function clickCargoButton() {
				var questLog = alertify.questLog("To see what's in your cargo, click the cargo button on the toolbar at the left side of the screen");
				// Show the tooltip
				var cargoWindow = ige.hud.leftToolbar.windows.cargo;
				cargoWindow.pinButtonTooltip();
				var listener = cargoWindow.on("opened",
					function() {
						questLog.close();
						cargoWindow.off("opened", listener);
						cargoWindow.unpinButtonTooltip();
						alertify.questLog("Your cargo holds everything you've mined",
							"", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				);
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.cargo.completed");
				self.questState = self.craft;
			}
		},

		clientStep: function() {
		}
	},

	// TODO: Skip this if the crafting window is already open
	craft: {
		clientOnce: function() {
			var craftingWindow = ige.hud.leftToolbar.windows.craftingUI;
			var playerCargo = ige.client.player.currentShip().cargo;

			var self = this;
			var msgTimeout = 5000;

			// Here, we choose an Iron Engine to craft
			var block = cosmos.blocks.instances["IronEngineBlock"];
			var recipeName = block.classId();
			var recipeNameHuman = block.recipe.name;
			var reactants = block.recipe.reactants;

			clickCraftButton();

			function clickCraftButton() {
				var questLog = alertify.questLog("Click the crafting button");
				// Show the tooltip
				craftingWindow.pinButtonTooltip();
				var listener = craftingWindow.on("opened", function () {
					questLog.close();
					craftingWindow.off("opened", listener);
					// Hide the tooltip
					craftingWindow.unpinButtonTooltip();
					alertify.questLog("Crafting allows you to make powerful new blocks",
						"", msgTimeout);
					setTimeout(waitForReactants, msgTimeout / 2);
				});
			}

			function waitForReactants() {
				var baseMessage = "Now, let's craft an " + recipeNameHuman + ".";
				var questLog = alertify.questLog(baseMessage);
				// Show the crafting tooltip for the desired block
				craftingWindow.pinRecipeTooltip(recipeName);
				// Autohide the crafting tooltip so it doesn't get in the way
				setTimeout(function() {craftingWindow.unpinRecipeTooltip(
					recipeName)}, msgTimeout);

				// Inform the player what they need to collect

				var cargoAddListener = playerCargo.on("add", updateReactantCounts,
					this);
				var cargoRemoveListener = playerCargo.on("remove", updateReactantCounts,
					this);
				updateReactantCounts();

				function updateReactantCounts() {
					var canCraft = true;
					var collectionMessage = "You'll need the following resources in " +
						"addition to the resources already in your cargo:";

					_.forEach(reactants, function (reactant) {
						var reactantType = reactant.blockType;
						var reactantQuantity = reactant.quantity;

						var numOwned = playerCargo.numItemsOfType(reactantType);
						var numRequired = Math.max(reactantQuantity - numOwned, 0);

						if (numRequired > 0) {
							canCraft = false;
							collectionMessage += "<br />" + numRequired + " "
								+ Block.displayNameFromClassId(reactantType);
						}
					});

					questLog.DOMElement.innerHTML = baseMessage + collectionMessage;

					if (canCraft) {
						questLog.close();
						playerCargo.off("add", cargoAddListener);
						playerCargo.off("remove", cargoRemoveListener);
						alertify.questLog("Bravo! You've collected all necessary blocks!",
							"success", msgTimeout);
						setTimeout(craftBlock, msgTimeout / 2);
					}
				}
			}

			function craftBlock() {
				var questLog = alertify.questLog("To craft the " + recipeNameHuman + ", click the " + recipeNameHuman +
					" recipe in the crafting window");

				craftingWindow.pinRecipeTooltip(recipeName);
				var listener = ige.craftingSystem.on("cosmos:CraftingSystem.craft.success",
					function (serverRecipeName) {
					if (serverRecipeName === recipeName) {
						questLog.close();
						craftingWindow.unpinRecipeTooltip(recipeName);
						ige.craftingSystem.off("cosmos:CraftingSystem.craft.success", listener);
						alertify.questLog("Woohoo! You've crafted one " + recipeNameHuman + "!",
							"success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.craft.completed");
				self.questState = self.construct;
			}
		},

		clientStep: function() {
		}

	},

	// Construct something on the player ship
	construct: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			constructMessage();

			function constructMessage() {
				var message = "Now, let's add something to your ship";
				alertify.questLog(message, "", msgTimeout);
				setTimeout(clickConstruct, msgTimeout / 2);
			}

			function clickConstruct() {
				// Make the player click the construct button
				var questLog = alertify.questLog("Click the construct button");
				// Show the tooltip for the construct button
				ige.hud.bottomToolbar.capBar.constructCap.pinButtonTooltip();
				var listener = ige.on("capbar cap selected", function (classId) {
					if (classId === ConstructCap.prototype.classId()) {
						questLog.close();
						ige.off("capbar cap selected", listener);
						// Hide the tooltip
						ige.hud.bottomToolbar.capBar.constructCap.unpinButtonTooltip();
						constructShip();
					}
				});
			}

			function constructShip() {
				// Make the player construct a block on the ship
				var questLog = alertify.questLog("Now, click on the construction zones around your ship.");
				var listener = ige.on("cosmos:BlockGrid.processActionClient.put",
					function (selectedType, blockGrid) {
					if (blockGrid === ige.client.player.currentShip()) {
						questLog.close();
						ige.off("cosmos:BlockGrid.processActionClient.put", listener);
						alertify.questLog("Wow! You've constructed a block on your ship!",
							"success", msgTimeout);
						setTimeout(done, msgTimeout / 2);
					}
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.construct.completed");
				self.questState = self.chat;
			}
		},


		clientStep: function() {
		}


	},

	// TODO: Skip this if chat is already visible
	chat: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			clickChat();

			function clickChat() {
				var questLog = alertify.questLog("Now, click the chat button");
				// Show the tooltip
				ige.hud.bottomToolbar.chat.pinButtonTooltip();
				var listener = ige.hud.bottomToolbar.chat.on("cosmos:ChatComponent.show", function () {
					questLog.close();
					ige.hud.bottomToolbar.chat.off("cosmos:ChatComponent.show", listener);
					// Hide the tooltip
					ige.hud.bottomToolbar.chat.unpinButtonTooltip();
					alertify.questLog("You\'ve opened the chat!\nYou can use the chat to talk with other players at any time.", "success",
						msgTimeout);
					setTimeout(done, msgTimeout / 2);
				});
			}

			function done() {
				self.questState = self.relocate;
			}

		},

		clientStep: function() {
		}
	},

	relocate: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			relocateMessage();

			function relocateMessage() {
				var message = 'If you\'re ever stuck, the relocate button warps you to another place';
				alertify.questLog(message, "", msgTimeout);
				setTimeout(clickRelocate, msgTimeout / 2);
			}

			function clickRelocate() {
				var questLog = alertify.questLog("Click the relocate button on the toolbar in the lower right");
				// Show the tooltip
				ige.hud.bottomToolbar.relocate.pinButtonTooltip();
				var listener = ige.hud.bottomToolbar.relocate.on("cosmos:RelocateComponent.mouseDown", function () {
					questLog.close();
					ige.hud.bottomToolbar.relocate.off("cosmos:RelocateComponent.mouseDown", listener);
					// Hide the tooltip
					ige.hud.bottomToolbar.relocate.unpinButtonTooltip();
					alertify.questLog("Good job. You\'ve clicked the relocate button!",
						"success", msgTimeout);
					setTimeout(done, msgTimeout / 2);
				});
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.chat.completed");
				self.questState = self.newShip;
			}
		},

		clientStep: function() {
		}
	},

	newShip: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			newShipMessage();

			function newShipMessage() {
				var message = 'If you are disabled, the new ship button gives you another ship';
				alertify.questLog(message, "", msgTimeout);
				setTimeout(pinNewShipTooltip, msgTimeout / 2);
			}

			function pinNewShipTooltip() {
				alertify.questLog("Click the new ship button (optional)", "", msgTimeout);
				// Show the tooltip
				ige.hud.bottomToolbar.newShip.pinButtonTooltip();
				setTimeout(unpinNewShipTooltip, msgTimeout);
			}

			function unpinNewShipTooltip() {
				// Hide the tooltip
				ige.hud.bottomToolbar.newShip.unpinButtonTooltip();
				done();
			}

			function done() {
				self.questState = self.feedback;
			}
		},

		clientStep: function() {
		}
	},

	feedback: {
		clientOnce: function() {
			var self = this;
			var msgTimeout = 5000;

			feedbackMessage();

			function feedbackMessage() {
				var message = 'Your feedback is very important to us! We\'d love to get your thoughts!';
				alertify.questLog(message, "", msgTimeout);
				setTimeout(clickFeedback, msgTimeout / 2);
			}

			function clickFeedback() {
				var questLog = alertify.questLog("Click the feedback button");
				// Show the tooltip
				ige.hud.bottomToolbar.feedback.pinButtonTooltip();
				var listener = ige.hud.bottomToolbar.feedback.on("cosmos:FeedbackComponent.clicked", function () {
					questLog.close();
					// Hide the tooltip
					ige.hud.bottomToolbar.feedback.unpinButtonTooltip();
					alertify.questLog("Great! Feel free to leave us some feedback.", "success",
						msgTimeout);
					setTimeout(done, msgTimeout / 2);
				}, self, true);
			}

			function done() {
				ige.client.metrics.track("cosmos:quest.tutorialQuest.newShip.completed");
				self.questState = self.complete;
			}
		},

		clientStep: function() {
		}
	},



	complete: {
		clientOnce: function() {
			var msgTimeout = 5000;
			var message = "Congratulations! You've completed the tutorial. Your galaxy awaits!";
			alertify.questLog(message, "success", msgTimeout);
			ige.questSystem.eventToServer(this.keys['complete'], this);
			ige.client.metrics.track("cosmos:quest.tutorialQuest.completed");
		},
		clientStep: function() {
		},
		// @server-side
		server: function(player) {
			// For now, don't do any server side verification that the client has
			// completed the quest
			ige.questSystem.removeQuestServer(this, player);
		}
	},

});

if (typeof(module) !== "undefined" && typeof(module.exports) !== "undefined") {
	module.exports = TutorialQuest; }
;/**
 * Contains all notification definitions.
 * The text of notifications are centralized so they are easy to view
 * and change. In addition, the use of definitions saves bandwidth
 * because the server sends a number instead of the full string.
 * @namespace
 */
var NotificationDefinitions = {
	infoKeys: {
		test: 1,
	},

	infos: {
		1: 'Test Message!',
	},

	errorKeys: {
		notMinable: 1,
		notConstructable: 2,
		noItemTypeSelected: 4,
		noMineEmptySpace: 5,
		noEngine: 6,
		noRotationalThruster: 7,
		noMiningLaser: 8,
		crafting_recipeNotUnlocked : 9,
		crafting_insufficientReactants: 10,
		crafting_insufficientEquipment: 11,
		crafting_insufficientCargoSpace: 12,
		alreadyLoggedIn: 13,
		constructing_deconstructing_bridge: 14,
		constructing_deconstructing_otherBlockGrid: 15
	},

	errors: {
		1: 'Cannot mine this block. Your laser cannot reach the inside of asteroids.',
		2: 'Cannot construct here!',
		4: 'No block type selected!',
		5: 'Cannot mine empty space!',
		6: 'Cannot thrust... no engine!',
		7: 'Cannot rotate... no rotational thruster!',
		8: 'Cannot mine... no laser!',
		9: 'Recipe not unlocked!',
		10: 'Insufficient reactants!',
		11: 'Insufficient ship equipment!',
		12: 'Insufficient cargo space!',
		13: 'This account is already playing the game elsewhere!',
		14: 'Cannot deconstruct your own bridge. This would result in death.',
		15: 'Cannot deconstruct other ships or asteroids. You have to mine them.'
	},

	successKeys: {
		constructNewBlock: 1,
		minedBlock: 2,
		relocateShip: 3,
		newShip: 4,
		crafting_success: 5,
	},

	successes: {
		1: 'Constructed new block!',
		2: 'Mined a block!',
		3: 'Relocated ship!',
		4: 'New ship created and relocated!',
		5: 'Crafted a block!',
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = NotificationDefinitions; }
;/**
 * The NotificationComponent handles both server and client notifications.
 * The NotificationComponent has three queues: Info, Error, and Success. 
 * Each engineStep, the behavior for the notificationComponent is called.
 * The behavior calls the registered notification UI functions.
 * This way, the UI is decoupled from the backend.
 * @class
 * @namespace
 */
var NotificationComponent = IgeEventingClass.extend({
	classId: 'NotificationComponent',
	componentId: 'notification',
	/** 
	 * True if component's behavior is running every engineStep
	 * @type {Boolean}
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_active: undefined,
	/** 
	 * Displays queued info notifications
	 * @type {function}
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_infoHandler: undefined,

	/** 
	 * Displays queued error notifications
	 * @type {function}
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_errorHandler: undefined,

	/** 
	 * Displays queued success notifications
	 * @type {function}
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_successHandler: undefined,

	init: function (entity, options) {
		if (ige.isServer) {
			// Define network commands server side
			ige.network.define('notificationInfo');
			ige.network.define('notificationError');
			ige.network.define('notificationSuccess');
		}

		if (ige.isClient) {
			this._queuedInfos = [];
			this._queuedErrors = [];
			this._queuedSuccesses = [];

			// Register client notifications
			this.on('notificationInfo', this._onNotificationInfo);
			this.on('notificationError', this._onNotificationError);
			this.on('notificationSuccess', this._onNotificationSuccess);

			// Register server notifications
			ige.network.define('notificationInfo', this._onNotificationInfo);
			ige.network.define('notificationError', this._onNotificationError);
			ige.network.define('notificationSuccess', this._onNotificationSuccess);
		}

		this.log('Notification component initiated!');
	},

	/**
	 * Starts the NotificationComponent so that notifications are pushed onto
	 * the notification queue and notification handlers are called every
	 * engineStep.
	 * @memberof NotificationComponent
	 * @instance
	 */
	start: function () {
		if (!this._active) {
			this._active = true;
			ige.addBehaviour('notificationStep', this._behaviour);
		}
	},

	/**
	 * Stops pushing notifications onto the notification queue and stops
	 * notification handlers from being called.
	 * @memberof NotificationComponent
	 * @instance
	 */
	stop: function () {
		if (this._active) {
			this._active = false;
			ige.removeBehaviour('notificationStep');
		}
	},

	/**
	 * Register info notification handler with the NotificationComponent
	 * This handler takes an array of notifications and should display them.
	 * @param handler {infoNotificationCallback} UI callback
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	registerInfoHandler: function (handler) {
		this._infoHandler = handler;
		return this;
	},

	/**
	 * Register error notification handler with the NotificationComponent
	 * This handler takes an array of notifications and should display them.
	 * @param handler {errorNotificationCallback} UI callback
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	registerErrorHandler: function (handler) {
		this._errorHandler = handler;
		return this;
	},

	/**
	 * Register success notification handler with the NotificationComponent
	 * This handler takes an array of notifications and should display them.
	 * @param handler {successNotificationCallback} UI callback
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	registerSuccessHandler: function (handler) {
		this._successHandler = handler;
		return this;
	},

	/**
	 * Unregister info notification handler with the NotificationComponent.
	 * This will stop info notifications from being added to the info queue.
	 * Additionally, the info handler will not be called every engineStep.
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	unRegisterInfoHandler: function () {
		this._infoHandler = undefined;
		return this;
	},

	/**
	 * Unregister error notification handler with the NotificationComponent.
	 * This will stop error notifications from being added to the error queue.
	 * Additionally, the error handler will not be called every engineStep.
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	unRegisterErrorHandler: function () {
		this._errorHandler = undefined;
		return this;
	},

	/**
	 * Unregister success notification handler with the NotificationComponent.
	 * This will stop success notifications from being added to the success queue.
	 * Additionally, the success handler will not be called every engineStep.
	 * @returns {NotificationComponent}
	 * @memberof NotificationComponent
	 * @instance
	 */
	unRegisterSuccessHandler: function () {
		this._successHandler = undefined;
		return this;
	},

	/**
	 * Call notification handlers, which will display notifications on the screen.
	 * @param ctx {CanvasContext} Canvas context
	 * @private
	 * @memberof NotificationComponent
	 * @instance
	 */
	_behaviour: function (ctx) {
		var self = ige.notification;
		if (self._active) {
			// Handle info notifications
			if (self._infoHandler !== undefined) {
				self._infoHandler(self._queuedInfos);
			}
			// Handle error notifications
			if (self._errorHandler !== undefined) {
				self._errorHandler(self._queuedErrors);
			}
			// Handle success notifications
			if (self._successHandler !== undefined) {
				self._successHandler(self._queuedSuccesses);
			}
		}
	},

	/**
	 * Push an info notification onto queuedInfos
	 * @param notification {String} A NotificationDefinition index
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_onNotificationInfo: function (notification) {
		var self = ige.notification;
		if (self._active && (self._infoHandler !== undefined)) {
			self._queuedInfos.push(notification);
		}
	},

	/**
	 * Push an error notification onto queuedErrors
	 * @param notification {String} A NotificationDefinition index
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_onNotificationError: function (notification) {
		var self = ige.notification;
		if (self._active && (self._errorHandler !== undefined)) {
			self._queuedErrors.push(notification);
		}
	},

	/**
	 * Push a success notification onto queuedSuccesses
	 * @param notification {String} A NotificationDefinition index
	 * @memberof NotificationComponent
	 * @private
	 * @instance
	 */
	_onNotificationSuccess: function (notification) {
		var self = ige.notification;
		if (self._active && (self._successHandler !== undefined)) {
			self._queuedSuccesses.push(notification);
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = NotificationComponent; }
;/**
 * The NotificationUIComponent displays info, error, and success notifications.
 * It registers notification handlers in the NotificationComponent
 * backend.
 * @class
 * @namespace
 */
var NotificationUIComponent = IgeEventingClass.extend({
	classId: 'NotificationUIComponent',
	componentId: 'notificationUI',
	notificationUIRoot: '/vendor/alertify/',

	init: function (entity, options) {
		var self = this;

		if (ige.isClient) {
			// Load Alertify, a notification library
			ige.requireScript(self.notificationUIRoot + 'alertify.js');

			ige.on('allRequireScriptsLoaded', function () {
				// Load Alertify stylesheets
				ige.requireStylesheet(self.notificationUIRoot + 'alertify_themes/alertify.core.css');
				ige.requireStylesheet(self.notificationUIRoot +
					'alertify_themes/alertify.default.css');

				ige.notification.registerInfoHandler(ige.hud.notificationUI.infoHandler);
				ige.notification.registerErrorHandler(ige.hud.notificationUI.errorHandler);
				ige.notification.registerSuccessHandler(ige.hud.notificationUI.successHandler);
				ige.emit('cosmos:hud.subcomponent.loaded');
				}, null, true);

		}

		this.log('Notification UI component initiated!');
	},

	/**
	 * Displays queued info notifications using alertify.js
	 * @callback infoNotificationCallback
	 * @param queue {Array} Queued notifications
	 * @memberof NotificationUIComponent
	 * @instance
	 */
	infoHandler: function (queue) {
		for (var i = 0; i < queue.length; i++) {
			var infosIndex = queue.pop();
			var notification = NotificationDefinitions.infos[infosIndex];
			alertify.log(notification);
		}
	},

	/**
	 * Displays queued error notifications using alertify.js
	 * @callback errorNotificationCallback
	 * @param queue {Array} Queued notifications
	 * @memberof NotificationUIComponent
	 * @instance
	 */
	errorHandler: function (queue) {
		for (var i = 0; i < queue.length; i++) {
			var errorsIndex = queue.pop();
			var notification = NotificationDefinitions.errors[errorsIndex];
			alertify.log(notification, "error");
		}
	},

	/**
	 * Displays queued success notifications using alertify.js
	 * @callback successNotificationCallback
	 * @param queue {Array} Queued notifications
	 * @memberof NotificationUIComponent
	 * @instance
	 */
	successHandler: function (queue) {
		for (var i = 0; i < queue.length; i++) {
			var successesIndex = queue.pop();
			var notification = NotificationDefinitions.successes[successesIndex];
			alertify.log(notification, "success");
		}
	},
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = NotificationUIComponent; }
;var HUDComponent = IgeEventingClass.extend({
	classId: 'HUDComponent',
	componentId: 'hud',

	element: undefined,
	numComponentsToLoad: undefined,

	init: function() {
		var self = this;
		var hudDiv = document.createElement('div');
		hudDiv.id = 'hud';
		$('body').append(hudDiv);

		this.element = $('#hud');

		this.hide();

		this.numComponentsToLoad = 5;

		// Track how many of the other HUD components have loaded. Emit an event when everything is done.
		ige.on('cosmos:hud.subcomponent.loaded', function(component) {
			self.numComponentsToLoad--;
			if (self.numComponentsToLoad === 0) {
				ige.emit('cosmos:hud.loaded', self);
			}
		});

		this.addComponent(BottomToolbarComponent);
		this.addComponent(LeftToolbarComponent);
		this.addComponent(MinimapComponent);
		this.addComponent(Inspector);
		this.addComponent(NotificationUIComponent);
	},

	show: function() {
		this.element.show();
	},

	hide: function() {
		this.element.hide();
	}
});

HUDComponent.loadHtml = function(url, callback) {
	$.ajax({
		url: url,
		success: callback,
		dataType: 'html',
		async: false
	});
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = HUDComponent;
}
;var BottomToolbarComponent = IgeEventingClass.extend({
	classId: 'BottomToolbarComponent',
	componentId: 'bottomToolbar',

	element: undefined,
	numComponentsToLoad: undefined,

	init: function() {
		var self = this;
		var hud = $('#hud');
		if (hud.length === 0) {
			this.log('HUD has not been initialized.', 'error');
			return;
		}

		var bottomToolbarDiv = document.createElement('div');
		bottomToolbarDiv.id = 'bottom-toolbar';
		bottomToolbarDiv.className = 'bottom-toolbar';

		hud.append(bottomToolbarDiv);

		this.element = $('#bottom-toolbar');

		this.numComponentsToLoad = 7;

		ige.on('cosmos:hud.bottomToolbar.subcomponent.loaded', function(component) {
			self.numComponentsToLoad--;
			if (self.numComponentsToLoad === 0) {
				ige.emit('cosmos:hud.subcomponent.loaded', self);
			}
		});

		this.addComponent(UserTileComponent);
		this.addComponent(ChatComponent);

		this.addComponent(CapBar);

		this.addComponent(MenuComponent);
		this.addComponent(FeedbackComponent);
		this.addComponent(RelocateComponent);
		this.addComponent(NewShipComponent);

	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = BottomToolbarComponent;
}
;var LeftToolbarComponent = IgeEventingClass.extend({
	classId: 'LeftToolbarComponent',
	componentId: 'leftToolbar',

	element: undefined,
	numComponentsToLoad: undefined,

	init: function() {
		var self = this;
		var hud = $('#hud');
		if (hud.length === 0) {
			this.log('HUD has not been initialized.', 'error');
			return;
		}

		var leftToolbarDiv = document.createElement('div');
		leftToolbarDiv.id = 'left-toolbar';
		leftToolbarDiv.className = 'left-toolbar';

		hud.append(leftToolbarDiv);

		this.element = $('#left-toolbar');

		this.numComponentsToLoad = 1;

		ige.on('cosmos:hud.leftToolbar.subcomponent.loaded', function(component) {
			self.numComponentsToLoad--;
			if (self.numComponentsToLoad === 0) {
				ige.emit('cosmos:hud.subcomponent.loaded', self);
			}
		});

		this.addComponent(WindowsComponent);

	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = LeftToolbarComponent;
}
;var WindowsComponent = IgeEventingClass.extend({
	classId: 'WindowsComponent',
	componentId: 'windows',

	init: function() {
		var self = this;
		var leftToolbar = $('#left-toolbar');
		if (leftToolbar.length === 0) {
			this.log('Left toolbar has not been initialized.', 'error');
			return;
		}

		self.windows = $('<div></div>').attr('id', 'windows');
		leftToolbar.append(self.windows);

		ige.on('cosmos:hud.leftToolbar.windows.subcomponent.loaded', function(component) {
			self.numComponentsToLoad--;
			if (self.numComponentsToLoad === 0) {
				ige.emit('cosmos:hud.leftToolbar.subcomponent.loaded', self);
			}
		});

		this.numComponentsToLoad = 2;

		this.addComponent(CargoUI);
		this.addComponent(CraftingUIComponent);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = WindowsComponent;
}
;var ButtonComponent = IgeEventingClass.extend({
	classId: 'ButtonComponent',

	element: undefined,

	init: function(parent, id, className, tooltip, tooltipPosition) {
		if (parent.length === 0) {
			this.log('Parent has not been initialized when creating button with id: ' + id + '.', 'error');
			return;
		}

		var buttonDiv = document.createElement('div');
		buttonDiv.id = id;
		if (className !== undefined) {
			buttonDiv.className = className;
		}

		$(buttonDiv).tooltipster({
				content: tooltip,
				delay: 0,
				position: tooltipPosition,
				theme: 'tooltip',
				maxWidth: '200'
		});

		parent.append(buttonDiv);

		this.element = $('#' + id);
	},

	// Shows and pins the tooltip for the button
	pinButtonTooltip: function() {
		this.element.tooltipster('showPin', 'tooltip-highlighted');
	},

	// Hides and unpins the tooltip for the button
	unpinButtonTooltip: function() {
		this.element.tooltipster('hideUnpin', 'tooltip');
	}

});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = ButtonComponent;
}
;var WindowComponent = ButtonComponent.extend({
	classId: 'WindowComponent',

	button: undefined,
	window: undefined,
	numRows: undefined,

	init: function(windowUrl, windowId, buttonParent, buttonId, buttonClass, tooltip, tooltipPosition) {
		ButtonComponent.prototype.init.call(this, buttonParent, buttonId, buttonClass, tooltip, tooltipPosition);
		var self = this;

		var windows = $('#windows');
		if (windows.length === 0) {
			self.log('Window have not been initialized.', 'error');
			return;
		}

		// ButtonComponent saves the element with the given ID as 'element'. Rename this to button here for
		// convenience.
		self.button = self.element;

		HUDComponent.loadHtml(windowUrl, function(html) {
			windows.append(html);
			self.window = $('#' + windowId);

			self.button.click(function(event) {
				if (self.button.hasClass('active')) {
					self.close();
				}
				else {
					self.open();
					self.emit('opened');
				}
			});

			self.table = self.window.find('table').first();

			self.numRows = 0;

			for (var i = 0; i < WindowComponent.MIN_ROWS; i++) {
				self.addRow();
			}

			self._onWindowLoaded();
		});
	},

	_onWindowLoaded: function() {

	},

	addRow: function() {
		var self = this;
		var row = $('<tr></tr>');
		for (var i = 0; i < WindowComponent.COLS_PER_ROW; i++) {
			row.append('<td></td>');
		}
		row.find('td').click(function() {
			self.select($(this));
		});
		this.table.append(row);
		this.numRows++;
	},

	removeRow: function() {
		// Don't remove rows past the minimum row setting!
		if (this.numRows <= WindowComponent.MIN_ROWS) {
			return;
		}
		this.table.find('tr').last().remove();
		this.numRows--;
	},

	setNumRows: function(numRows) {
		var rowDelta = numRows - this.numRows;
		if (rowDelta > 0) {
			for (var i = 0; i < rowDelta; i++) {
				this.addRow();
			}
		}
		else {
			for (var i = 0; i > rowDelta; i--) {
				this.removeRow();
			}
		}
	},

	drawBlockInCell: function(cell, blockType) {
	var blockTextureContainerDiv = cell.find('.block-texture-container');
		// If a container doesn't exist, create one
		if (blockTextureContainerDiv.length === 0) {
			blockTextureContainerDiv = $('<div></div>').addClass('block-texture-container');
		}
		// If a container already exists, empty it and recreate the elements inside of it
		else {
			blockTextureContainerDiv.empty();
		}

		var block = Block.fromType(blockType);

		// If this does not occur before the containerCanvas is appended, then the
		// containerCanvas will have a height and width of 0.
		cell.append(blockTextureContainerDiv);

		if (block instanceof Part) {
			var img = $('<img/>')[0];
			img.src = "/assets/sprites/" + block.iconFrame;
			blockTextureContainerDiv.append(img);
		}
		else {
			var containerCanvas = $('<canvas/>')[0];
			blockTextureContainerDiv.append(containerCanvas);

			containerCanvas.width = $(containerCanvas).width();
			containerCanvas.height = $(containerCanvas).height();

			var scaleWidth = containerCanvas.width / block._bounds2d.x;
			var scaleHeight = containerCanvas.height / block._bounds2d.y;
			var ctx = containerCanvas.getContext("2d");
			ctx.scale(scaleWidth, scaleHeight);
			ctx.translate(block._bounds2d.x2, block._bounds2d.y2);
			block.texture().render(ctx, block);
		}

		return blockTextureContainerDiv;
	},

	select: function(cell) {

	},

	open: function() {
		this.window.fadeIn();
		this.button.addClass('active');
		this._resizeContainer();
	},

	close: function() {
		this.window.fadeOut(this._resizeContainer);
		this.button.removeClass('active');
	},

	_resizeContainer: function() {
		var visibleChildren = $('#windows').children(':visible');
		var width = 0;
		visibleChildren.each(function() {
			width += $(this).outerWidth(true);
		});
		$('#windows').width(width);
	}
});

WindowComponent.MIN_ROWS = 3;
WindowComponent.COLS_PER_ROW = 6;

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = WindowComponent;
}
;var UserTileComponent = IgeEventingClass.extend({
	classId: 'UserTileComponent',
	componentId: 'userTile',

	element: undefined,
	profilePic: undefined,
	shipName: undefined,
	username: undefined,

	init: function() {
		var self = this;
		var bottomToolbar = $('#bottom-toolbar');
		if (bottomToolbar.length === 0) {
			self.log('Bottom toolbar has not been initialized.', 'error');
			return;
		}

		HUDComponent.loadHtml(UserTileComponent.UI_ROOT + 'user-tile.html', function(html) {
			bottomToolbar.append(html);

			self.element = $('#user-tile');

			self.profilePic = self.element.find('.profile-pic');
			self.shipName = self.element.find('.ship-name');
			self.username = self.element.find('.username');

			ige.on('cosmos:client.player.username.set', function(username) {
				self.username.text(username);
			}, self, true);

			ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', self);
		});
	}
});

UserTileComponent.UI_ROOT = '/components/user-tile/';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = UserTileComponent;
};var ChatComponent = ButtonComponent.extend({
	classId: 'ChatComponent',
	componentId: 'chat',

	button: undefined,
	chatClient: undefined,
	numUnread: undefined,
	unreadLabel: undefined,
	messageInputs: undefined,

	init: function() {
		var self = this;
		var bottomToolbar = $('#bottom-toolbar');

		if (bottomToolbar.length === 0) {
			self.log('Bottom toolbar has not been initialized.', 'error');
			return;
		}

		var chatDiv = $('<div></div>');
		chatDiv.attr('id', 'chat');

		bottomToolbar.append(chatDiv);

		ButtonComponent.prototype.init.call(this, chatDiv, 'chat-button', undefined, 'Chat', 'top');
		self.button = $('#chat-button');
		self.button.addClass('unopened');
		self.button.click(function() {
			$(this).removeClass('unopened');
		});

		self.unreadLabel = $('<span></span>').attr('id', 'chat-unread-label');
		self.button.append(self.unreadLabel);
		self.chatClient = $('<div></div>').attr('id', 'candy');

		chatDiv.append(self.chatClient);

		self.numUnread = 0;

		$.getScript(ChatComponent.CANDY_ROOT + 'libs/libs.min.js', function() {
			$.getScript(ChatComponent.CANDY_ROOT + 'candy.min.js', function() {
				Candy.init('http://tl-xmpp.cloudapp.net:5280/http-bind/', {
					core: {
						debug: false,
						autojoin: ['cosmos@conference.tl-xmpp.cloudapp.net']
					},
					view: { resources: ChatComponent.CANDY_ROOT + 'res/' }
				});

				ige.on('cosmos:client.player.username.set', function(username) {
					self.start();
				}, self, true);

				self.chatClient.hide();

				self.button.click(function(event) {
					if (self.chatClient.is(':visible')) {
						self.chatClient.hide();
						self.emit('cosmos:ChatComponent.hide');
					}
					else {
						self.chatClient.show();
						self.clearUnread();
						self.emit('cosmos:ChatComponent.show');
					}
				});

				ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', self);
			});
		});
	},

	start: function() {
		var self = this;
		Candy.Core.connect('tl-xmpp.cloudapp.net', null, ige.client.player.username());

		// Called when the chat client moves to the disconnected state.
		$(Candy).on('candy:view.connection.status-6', function() {
			// Delay a little bit here to allow the client to fully disconnect before trying to reconnect.
			setTimeout(function() {
				Candy.Core.connect('tl-xmpp.cloudapp.net', null, ige.client.player.username());
			}, 200);
		});

		$(Candy).on('candy:core.message', function(evt, args) {
			if (args.timestamp === undefined && self.chatClient.is(':hidden')) {
				self.incrementUnread();
			}
		});

		$(Candy).on('candy:view.roster.after-update', function(evt, args) {
			// Don't increment unread when the player joins the game
			if (args.action === 'join' && self.chatClient.is(':hidden') && args.user.getNick() !== ige.client.player.username()) {
				self.incrementUnread();
			}
		});

		// When a new room is added, find the message input field and tell it not to propagate keydown
		// events. Otherwise, the player will move in IGE while typing characters that are controls in the
		// game.
		$(Candy).on('candy:view.room.after-add', function() {
			self.messageInputs = self.chatClient.find('input.field');
			self.messageInputs.keydown(function(e) {
				e.stopPropagation();
			});
		});
	},

	incrementUnread: function() {
		this.button.removeClass('unopened');
		this.button.addClass('unread');
		this.numUnread++;
		this.updateLabel();
	},

	clearUnread: function() {
		this.button.removeClass('unread');
		this.numUnread = 0;
		this.updateLabel();
	},

	updateLabel: function() {
		this.unreadLabel.text(this.numUnread);

		var numChars = this.numUnread.toString().length;
		this.unreadLabel.css('font-size', '' + (85 - (numChars - 1) * 20) + '%');
	}
});

ChatComponent.UI_ROOT = '/components/chat/';
ChatComponent.CANDY_ROOT = '/vendor/candy/'

if (typeof(module) !== 'undefined' && typeof(module.expoerts) !== 'undefined') {
	module.exports = ChatComponent;
}
;var MenuComponent = ButtonComponent.extend({
	classId: 'MenuComponent',
	componentId: 'menu',

	init: function() {
		ButtonComponent.prototype.init.call(this, $('#bottom-toolbar'), 'menu-button', undefined, 'Menu', 'top');

		ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', this);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = MenuComponent;
};var FeedbackComponent = ButtonComponent.extend({
	classId: 'FeedbackComponent',
	componentId: 'feedback',

	init: function() {
		ButtonComponent.prototype.init.call(this, $('#bottom-toolbar'), 'feedback-button', undefined, 'Feedback', 'top');
		this.element.addClass('unopened');

		this.element.click(function() {
			$(this).removeClass('unopened');
			$(this).unbind('click');
			ige.hud.bottomToolbar.feedback.emit('cosmos:FeedbackComponent.clicked');
		});

		// Include the UserVoice JavaScript SDK (only needed once on a page)
		UserVoice = window.UserVoice || [];
		(function() {
			var uv = document.createElement('script');
			uv.type = 'text/javascript';
			uv.async = true;
			uv.src = '//widget.uservoice.com/skoKBVYu64FiUKHwnPS0kg.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(uv, s);
		})();

		//
		// UserVoice Javascript SDK developer documentation:
		// https://www.uservoice.com/o/javascript-sdk
		//

		// Set colors
		UserVoice.push(['set', {
			accent_color: '#448dd6',
			trigger_color: 'white',
			trigger_background_color: '#448dd6',
			trigger_style: 'tab',
			contact_enabled: true,
			post_idea_enabled: true,
			permalinks_enabled: true,
			smartvote_enabled: true
		}]);

		// Identify the user and pass traits
		// To enable, replace sample data with actual user traits and uncomment the line
		UserVoice.push(['identify', {
			//email:      'john.doe@example.com', // Users email address
			//name:       'John Doe', // Users real name
			//created_at: 1364406966, // Unix timestamp for the date the user signed up
			//id:         123, // Optional: Unique id of the user (if set, this should not change)
			//type:       'Owner', // Optional: segment your users by type
			//account: {
			//  id:           123, // Optional: associate multiple users with a single account
			//  name:         'Acme, Co.', // Account name
			//  created_at:   1364406966, // Unix timestamp for the date the account was created
			//  monthly_rate: 9.99, // Decimal; monthly rate of the account
			//  ltv:          1495.00, // Decimal; lifetime value of the account
			//  plan:         'Enhanced' // Plan name for the account
			//}
		}]);

		// Add default trigger to the bottom-right corner of the window:
		//UserVoice.push(['addTrigger', { mode: 'smartvote', trigger_position: 'bottom-left' }]);

		// Or, use your own custom trigger:
		UserVoice.push(['addTrigger', '#feedback-button', { mode: 'satisfaction' }]);

		// Autoprompt for Satisfaction and SmartVote (only displayed under certain conditions)
		UserVoice.push(['autoprompt', {}]);

		ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', this);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = FeedbackComponent;
}
;var NewShipComponent = ButtonComponent.extend({
	classId: 'NewShipComponent',
	componentId: 'newShip',

	init: function() {
		ButtonComponent.prototype.init.call(this, $('#bottom-toolbar'), 'new-ship-button', undefined, 'New Ship', 'top');
		this.element.click(this.mouseDown);

		ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', this);
	},

	mouseDown: function() {
		ige.client.metrics.track('cosmos:player.newShip.mouseDown');
		
		var message = "Whoa! This will destroy your current ship and cargo." + "<br>" +
			"Do you want to continue?";

		alertify.set({ buttonFocus: "cancel" }); // "none", "ok", "cancel"
		alertify.confirm(message, function (e) {
			if (e) {
				ige.network.send('new ship');
				ige.emit('new ship button clicked');
			}
		});
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = NewShipComponent;
}
;var RelocateComponent = ButtonComponent.extend({
	classId: 'RelocateComponent',
	componentId: 'relocate',

	init: function() {
		ButtonComponent.prototype.init.call(this, $('#bottom-toolbar'), 'relocate-button', undefined, 'Relocate', 'top');

		this.element.click(this.mouseDown);

		ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', this);
	},

	mouseDown: function() {
		ige.network.send('relocate');
		ige.emit('relocate button clicked');
		ige.hud.bottomToolbar.relocate.emit('cosmos:RelocateComponent.mouseDown');
		ige.client.metrics.track('cosmos:player.relocate.mouseDown');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = RelocateComponent;
}
;/**
 * Manages the UI for the Cargo Window.
 * @author Daniel Chiu
 */
var CargoUI = WindowComponent.extend({
	classId: 'CargoUI',
	componentId: 'cargo',

	button: undefined,
	selectedType: undefined,

	_cargo: undefined,
	_itemMap: undefined,
	_numCellsFilled: undefined,

	init: function() {
		WindowComponent.prototype.init.call(
			this,
			CargoUI.UI_ROOT + 'cargo-window.html',
			'cargo-window',
			$('#left-toolbar'),
			'cargo-button',
			undefined,
			'Cargo',
			'right'
		);

		this._itemMap = {};
		this._numCellsFilled = 0;
	},

	/**
	 * Opens the cargo window.
	 */
	open: function() {
		WindowComponent.prototype.open.call(this);
		this.refresh();

		if (!this.selectedType) {
			this.selectFirst();
		}
	},

	/**
	 * Refreshes the cargo window from the latest changes available by calling
	 * Cargo#recentChanges.
	 */
	refresh: function() {
		// Don't bother spending the time to update the cargo window if the window is not visible.
		if (!this.window.is(':visible')) {
			return;
		}

		var changes = this._cargo.recentChanges();
		this._cargo.resetRecentChanges();

		var rowsNeeded = Math.ceil(this._cargo.numTypes() / WindowComponent.COLS_PER_ROW);
		this.setNumRows(rowsNeeded);

		var self = this;
		var cell;
		_.forOwn(changes, function(delta, type) {
			cell = self._itemMap[type];
			var quantity = self._cargo.numItemsOfType(type);

			// If a container already exists for this type, just modify the quantity.
			if (cell) {
				// TODO: If quantity is 0 and a container exists, remove the container and shift the
				// cells.
				if (quantity === 0) {
					self._numCellsFilled--;
					var currRow = cell.parent();

					// If we now have no cells filled, then there is no selected type.
					if (self._numCellsFilled === 0) {
						self.selectedType = undefined;
					}
					// If this was the selected cell, try to select the next cell. If select returns
					// false, that means the next cell was not selectable (i.e. empty), so select
					// the first cell. There must be an item in the first cell because we know in
					// this case that _numCellsFilled > 0.
					else if (cell.hasClass('active') && !self.select(cell.next())) {
						self.selectFirst();
					}
					cell.remove();
					while (currRow.next().length !== 0) {
						var cellToShift = currRow.next().children().first();
						currRow.append(cellToShift);
						currRow = currRow.next();
					}

					var newCell = $('<td></td>');
					newCell.click(function() {
						self.select($(this));
					});
					currRow.append('<td></td>');
					delete self._itemMap[type];
				}
				else {
					var quantitySpan = cell.find('.quantity').first();
					// Don't show the number if there is just one item.
					if (quantity === 1) {
						quantitySpan.text('');
					}
					else {
						cell.find('.quantity').first().text(quantity);
					}

					// If something has been added and there currently isn't a selected type, we
					// should select this.
					if (!self.selectedType) {
						self.select(cell);
					}
				}
			}
			// No cell already exists. We must find one and fill one.
			else {
				cell = self.table.find('td').eq(self._numCellsFilled);
				self._fillCell(cell, type, quantity);
				self._numCellsFilled++;
				self._itemMap[type] = cell;
			}
		});
	},

	/**
	 * Selects a cell in the cargo window. Also selects that type for use in
	 * things like construction.
	 * @param cell A jQuery object representing the table cell to select.
	 * @returns {boolean} False if the specified cell is empty and cannot be
	 * selected. True otherwise.
	 */
	select: function(cell) {
		// If the user selects an empty cell, do nothing.
		var blockType = cell.attr('data-block-type');
		if (blockType === undefined) {
			return false;
		}

		// Otherwise, select the cell, mark it as active
		this.table.find('td').removeClass('active');
		this.selectedType = blockType;
		cell.addClass('active');
		return true;
	},

	/**
	 * Selects the first cell in the cargo window.
	 */
	selectFirst: function() {
		this.select(this.table.find('td').first());
	},

	_fillCell: function(cell, type, quantity) {
		var blockCanvasCellDiv = this.drawBlockInCell(cell, type);

		// Don't add a label if there's only one block of this type
		var quantitySpan = $('<span></span>').addClass('quantity');
		if (quantity > 1) {
			quantitySpan.text(quantity);
		}
		blockCanvasCellDiv.append(quantitySpan);

		$(cell).attr('data-block-type', type);

		if (this.selectedType === type) {
			this.select($(cell));
		}

		this._fillTooltip(type, cell);

		cell.mouseover(function() {
			ige.hud.inspector.inspect(cosmos.blocks.instances[type]);
		});

		cell.mouseout(function() {
			ige.hud.inspector.hide();
		});
	},

	_fillTooltip: function(type, cell) {
		var content = Block.displayNameFromClassId(type);

		cell.tooltipster({
			content: content,
			delay: 0,
			position: 'bottom',
			theme: 'tooltip cargo',
			maxWidth: '200'
		});
	},

	_onWindowLoaded: function() {
		var self = this;

		// TODO: At some point when the player's active ship can change, we need to switch which
		// cargo the UI is tracking.
		ige.on('cosmos:client.player.currentShip.ready', function() {
			self._cargo = ige.client.player.currentShip().cargo;

			self._cargo.on('add', self.refresh.bind(self));
			self._cargo.on('remove', self.refresh.bind(self));
		});

		ige.emit('cosmos:hud.leftToolbar.windows.subcomponent.loaded', this);
	}
});

CargoUI.UI_ROOT = '/components/cargo/';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CargoUI;
}
;var CraftingUIComponent = WindowComponent.extend({
	classId: 'CraftingUIComponent',
	componentId: 'craftingUI',

	button: undefined,
	pullout: undefined,
	containers: undefined,
	craftingBlocks: undefined,
	emptyLabel: undefined,

	selectedType: undefined,
	// A map of recipes to their respective DOM element. This is useful for
	// toggling tooltips for a particular recipe in the tutorial quest.
	recipeDOMElements: undefined,

	init: function() {
		WindowComponent.prototype.init.call(
			this,
			CraftingUIComponent.UI_ROOT + 'crafting-window.html',
			'crafting-window',
			$('#left-toolbar'),
			'crafting-button',
			undefined,
			'Crafting',
			'right'
		);
		recipeDOMElements = {};
	},

	_onWindowLoaded: function() {
		ige.emit('cosmos:hud.leftToolbar.windows.subcomponent.loaded', this);
	},

	// Refresh crafting UI in response to cargo changes.
	// TODO: Cache blocks and tooltips. Only redraw things that are necessary.
	refresh: function() {
		var recipes = ige.client.player.crafting.recipes();
		var craftableRecipes = ige.client.player.crafting.craftableRecipes();

		// Resize the crafting window, if needed
		var numTypes = Object.keys(recipes).length;
		var rowsNeeded = Math.ceil(numTypes / WindowComponent.COLS_PER_ROW);
		this.setNumRows(rowsNeeded);

		// Populate crafting window with recipes
		this.populate(recipes, craftableRecipes);
	},

	populate: function(recipes, craftableBlocks) {
		var self = this;
		var cells = this.table.find('td');
		cells.removeClass('active');

		var canvases = this.table.find('canvas');
		if (canvases.length > 0) {
			canvases.remove();
		}

		// Clear the existing recipe map
		this.recipeDOMElements = {};

		// TODO: Grey out recipes that are known but not craftable
		var i = 0;
		_.forOwn(craftableBlocks, function(canCraft, blockType) {
			var block = cosmos.blocks.instances[blockType];
			self.fillCell(i, block);
			i++;
		});
	},

	fillCell: function(index, block) {
		var self = this;
		var cell = this.table.find('td').eq(index);
		var recipe = block.recipe;

		// Add an onclick function
		cell.attr('recipe', recipe.name);
		cell.unbind('click');
		cell.click(function() {
			ige.craftingSystem.craftClient(block.classId());
		});

		// Add the recipe DOM element to the recipe map
		this.recipeDOMElements[block.classId()] = cell;

		// Generate tooltip content
		this.fillTooltip(recipe, cell, function(err, out) {
			// Draw the block
			self.drawBlockInCell(cell, block.classId());
		});

		cell.mouseover(function() {
			ige.hud.inspector.inspect(block);
		});

		cell.mouseout(function() {
			ige.hud.inspector.hide();
		});
	},

	fillTooltip: function(recipe, cell, callback) {
		dust.render('crafting/tooltip', recipe.tooltipData(), function(err, out) {
			if (err) {
				this.log('Error rendering crafting tooltip template.');
			}

			var tooltipContent = $(out);

			// If tooltip exists, destroy it so we can set the right functionReady behavior
			if (cell.hasClass('tooltipstered')) {
				cell.tooltipster('destroy');
			}

			// If tooltip doesn't exist, create new tooltip
			cell.tooltipster({
				content: tooltipContent,
				delay: 0,
				position: 'bottom-left',
				theme: 'tooltip crafting',
				maxWidth: '200',
				functionReady: function(origin, tooltip) {
					var textureContainers = $(tooltip).find('.block-texture-container');

					_.forEach(_.zip(textureContainers, recipe.reactants), function(pair) {
						var textureContainer = pair[0];
						var reactant = pair[1];

						var block = cosmos.blocks.instances[reactant.blockType];

						if (block instanceof Part) {
							var imgs = $(textureContainer).find('img');
							var img = (imgs.length === 0) ? $('<img/>')[0] : imgs[0];
							img.src = '/assets/sprites/' + block.iconFrame;
							$(textureContainer).prepend(img);
						}
						else {
							var canvases = $(textureContainer).find('canvas');
							var canvas = (canvases.length === 0) ?
								$('<canvas></canvas>')[0] : canvases[0];
							$(textureContainer).prepend(canvas);

							var scaleWidth = canvas.width / block._bounds2d.x;
							var scaleHeight = canvas.height / block._bounds2d.y;
							canvas.width = canvas.width;
							var ctx = canvas.getContext("2d");
							ctx.scale(scaleWidth, scaleHeight);
							ctx.translate(block._bounds2d.x2, block._bounds2d.y2);
							block.texture().render(ctx, block);
						}
					});
				}
			});

			callback(err, out);
		});
	},

	pinRecipeTooltip: function(recipeName) {
		var elem = this.recipeDOMElements[recipeName];
		elem.tooltipster('showPin');
	},

	unpinRecipeTooltip: function(recipeName) {
		var elem = this.recipeDOMElements[recipeName];
		elem.tooltipster('hideUnpin');
	}

});

CraftingUIComponent.UI_ROOT = '/components/crafting/';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = CraftingUIComponent;
}
;var NamePrompt = IgeEventingClass.extend({
	classId: 'NamePrompt',
	componentId: 'namePrompt',

	element: undefined,
	shipNameInput: undefined,
	usernameInput: undefined,
	goButton: undefined,
	skipButton: undefined,
	hidden: undefined,

	init: function(){
		var self = this;
		// TODO: Move name prompt html from jade file into here. 
		self.element = $('#name-prompt');
		self.shipNameInput = self.element.find('#ship-name-input');
		self.usernameInput = self.element.find('#username-input');
		self.goButton = self.element.find('#name-prompt-go');
		self.skipButton = self.element.find('#name-prompt-skip');

		self.shipNameInput.keydown(function(e) {
			e.stopPropagation();
		});

		self.usernameInput.keydown(function(e) {
			e.stopPropagation();
		});

		self.goButton.click(function(e) {
			var username = self.usernameInput.val();
			if (!Player.usernameIsCorrectLength(username)) {
				ige.emit('cosmos:player.username.set.error', 'Username must be between 2 and 12 characters');
			}
			else if (!Player.usernameIsAlphanumericUnderscore(username)) {
				ige.emit('cosmos:player.username.set.error', 'Alphanumeric characters and underscores only');
			}
			else {
				ige.client.player.requestUsername(self.usernameInput.val());
			}
		});

		self.skipButton.click(function(e) {
			ige.emit('cosmos:namePrompt.skipped');
			ige.emit('cosmos:client.player.username.set', ige.client.player.username());
			self.hide();
		});

		ige.on('cosmos:player.username.set.error', function(error) {
			// Clear the input
			self.usernameInput.val('');

			// Display the error as placeholder text
			self.usernameInput.attr('placeholder', error);

			self.usernameInput.addClass('error');
		});

		var clientPlayerUsernameSetListener = ige.on('cosmos:client.player.username.set', function(username) {
			if (!ige.client.player.hasGuestUsername) {
				ige.emit('cosmos:client.player.login', username);
			}
			self.hide();
		}, self, true);

		self.show();
	},

	show: function() {
		this.hidden = false;
		this.element.show();
		ige.hud.hide();
	},

	hide: function() {
		this.hidden = true;
		this.element.hide();
		ige.hud.show();
		ige.emit('cosmos:NamePrompt.hide');
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = NamePrompt;
}
;var MinimapComponent = IgeEventingClass.extend({
	classId: 'MinimapComponent',
	componentId: 'minimap',

	element: undefined,

	/**
	 * The scene the minimap is displaying
	 * @type {IgeScene2d}
	 * @memberof MinimapComponent
	 * @private
	 * @instance
	 */
	 _scene: undefined,

	/**
	 * The camera the minimap is following
	 * @type {IgeCamera}
	 * @memberof MinimapComponent
	 * @private
	 * @instance
	 */
	 _camera: undefined,


	init: function() {
		var self = this;
		var hud = $('#hud');
		if (hud.length === 0) {
			this.log('HUD has not been initialized.', 'error');
			return;
		}

		this._scene = ige.client.spaceGameScene;
		this._camera = ige.client.mainViewport.camera;

		HUDComponent.loadHtml(MinimapComponent.UI_ROOT + 'minimap.html', function(html) {
			hud.append(html);
			self.element = $('#minimap');
			self.toolbar = self.element.find('.toolbar');
			self.button = self.toolbar.find('#map-button');
			self.zoomInButton = self.toolbar.find('.zoom-in-button');
			self.zoomOutButton = self.toolbar.find('.zoom-out-button');
			self.canvas = self.element.find('.map canvas').first();
			self.coordinates = self.element.find('.map .coordinates');

			ige.addBehaviour('updateCoordinates', self.updateCoordinates);
			ige.addBehaviour('updateMinimap', self.updateMinimap);

			// Set the internal size to match CSS values
			self.ctx = self.canvas[0].getContext('2d');
			self.width = parseInt(self.canvas.css('width'));
			self.height = parseInt(self.canvas.css('height'));
			self.ctx.canvas.width = self.width;
			self.ctx.canvas.height = self.height;

			// Offset the canvas draws so a draw to (0,0) is in the middle
			self.offsetX = self.canvas.width() / 2;
			self.offsetY = self.canvas.height() / 2;
			// Maps the visible minimap area to the canvas via a scale factor
			self.scaleX = Constants.minimapArea.MAXIMUM_WIDTH / self.canvas.width();
			self.scaleY = Constants.minimapArea.MAXIMUM_HEIGHT / self.canvas.height();

			ige.emit('cosmos:hud.subcomponent.loaded', self);
		});
	},

	show: function() {
		this.element.show();
	},

	hide: function() {
		this.element.hide();
	},

	addGlow: function() {
		this.element.addClass('glow-pulse');
	},

	removeGlow: function() {
		this.element.removeClass('glow-pulse');
	},

	updateCoordinates: function() {
		var minimap = ige.hud.minimap;
		minimap.coordinates.text(minimap.getCoordinatesString());
	},

	updateMinimap: function() {
		var minimap = ige.hud.minimap;
		var ctx = minimap.ctx;
		var width = minimap.width;
		var height = minimap.height;
		var offsetX = minimap.offsetX;
		var offsetY = minimap.offsetY;
		var scaleX = minimap.scaleX;
		var scaleY = minimap.scaleY;

		// Clear the minimap canvas so we can redraw the minimap
		ctx.clearRect(0, 0, width, height);
		var camTrans = ige.hud.minimap._camera._translate;

		var sceneChildren = ige.hud.minimap._scene.children();
		for (var i = 0; i < sceneChildren.length; i++) {
			ctx.save();

			var entity = sceneChildren[i];
			if (entity.streamEntityValid() && !entity._newBorn) {
				// The player (show in green)
				// TODO this makes the player's currentship green. What happens if the player has other ships? Right now this isn't a problem, but it will be soon.
				if (ige.client.player && entity === ige.client.player.currentShip()) {
					ctx.fillStyle = '#00FF00';
				}
				// Other players (show in red)
				else if (entity.classId() === 'Ship') {
					ctx.fillStyle = '#FF0000';
				}
				// Other entities, such as asteroids (show in gray)
				else {
					ctx.fillStyle = '#808080';
				}


				// Calculate rectangle size, with a minimum rectangle size of 4x4
				// TODO: Draw actual shape, not just a box
				var w = Math.max(4, entity.width() / (scaleX * 1.5));
				var h = Math.max(4, entity.height() / (scaleY * 1.5));

				// Calculate center of entity on minimap
				var x = (entity.worldPosition().x - camTrans.x) / scaleX + offsetX;
				var y = (entity.worldPosition().y - camTrans.y) / scaleY + offsetY;

				// Rotate entity around its center
				ctx.translate(x,y)
				ctx.rotate(entity.rotate().z());
				ctx.translate(-x,-y);
				ctx.fillRect(x - w/2, y - w/2, w, h);
				ctx.restore();
			}
		}
	},

	/**
	 * Gets the camera translation and treats that as the coordinates
	 * to display.
	 * @memberof MinimapComponent
	 * @instance
	 */
	getCoordinatesString: function() {
		var camTrans = ige.hud.minimap._camera._translate;
		// Round coordinates to nearest 100, then drop a digit.
		// Too much granularity is confusing.
		var x = Math.ceil(camTrans.x / 100) * 10;
		var y = Math.ceil(camTrans.y / 100) * 10;
		return "x: " + x + ", y: " + y;
	}
});

MinimapComponent.UI_ROOT = '/components/minimap/';

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = MinimapComponent;
}
;var CapBar = IgeEventingClass.extend({
	classId: 'CapBar',
	componentId: 'capBar',

	element: undefined,
	numElementsToLoad: undefined,

	init: function() {
		var self = this;
		var bottomToolbar = $('#bottom-toolbar');
		if (bottomToolbar.length === 0) {
			this.log('Bottom toolbar has not been initialized.', 'error');
			return;
		}

		var capBarDiv = document.createElement('div');
		capBarDiv.id = 'cap-bar';

		bottomToolbar.append(capBarDiv);

		this.element = $('#cap-bar');

		this.numElementsToLoad = 2;

		ige.on('cosmos:hud.bottomToolbar.capBar.subcomponent.loaded', function(component) {
			self.numElementsToLoad--;
			if (self.numElementsToLoad === 0) {
				ige.emit('cosmos:hud.bottomToolbar.subcomponent.loaded', self);
			}
		});

		// TODO: Check whether or not the right blocks are on the player's ship before adding these capabilities
		this.addComponent(MineCap);
		this.addComponent(ConstructCap);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.expoerts) !== 'undefined') {
	module.exports = CapBar;
};/**
 * A Cap represents a Cap that the player can interface with to interface
 * with the game environment, similar to a tool in a tool palette. The CapBar can
 * host multiple Caps, all of different types.
 *
 * @class
 * @typedef {Object} Cap
 * @namespace  
 */
var Cap = ButtonComponent.extend({
	classId: "Cap",

	active: undefined,

	/**
	 * Initializes the Cap's styles, label, and attaches event emitters and listeners.
	 * @memberof Cap
	 * @instance
	 */
	init: function(parent, id, className, tooltip) {
		ButtonComponent.prototype.init.call(this, parent, id, className, tooltip, 'top');

		this.active = false;

		// Set up events
		this.initEvents();
	},

	/**
	 * Initializes event listeners for player interaction events and client events
	 * that may trigger a capbar state change.
	 * @memberof Cap
	 * @instance
	 */
	initEvents: function() {
		var self = this;

		this.element.click(function() {
			if (self.active) {
				self.deselect();
			}
			else {
				self.select();
			}
		});

		ige.on('capbar cap selected', function(classId) {
			if (!self.active && classId === self.classId()) {
				self.select();
			}
			else if (classId !== self.classId()) {
				self.deselect();
			}
		});
	},

	/**
	 * Triggered when the Cap is selected via a player interaction or via another
	 * client event. Applies appropriate selection styles, mounts and shows an attached
	 * toolbar, if one is defined for this Cap.
	 * @memberof Cap
	 * @instance
	 */
	select: function() {
		this.element.addClass('active');
		this.active = true;
		ige.emit('capbar cap selected', [this.classId()]);
	},

	/**
	 * Triggered when the Cap is deselected via a player interaction or via another
	 * client event. Applies normal styles, hides and unmounts an attached
	 * toolbar, if one is defined for this Cap.
	 * @memberof Cap
	 * @instance
	 */
	deselect: function() {
		this.element.removeClass('active');
		this.active = false;
		ige.emit('capbar cap cleared', [this.classId()]);
	}
});

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = Cap;
}
;var MineCap = Cap.extend({
	classId: 'MineCap',
	componentId: 'mineCap',

	active: undefined,
	/**
	 * Used to determine whether or not the cooldown has already been activated. Useful for
	 * optimizing streamSync so that startCooldown() only does work once per stream of packets.
	 */
	cooldownActivated: undefined,

	init: function() {
		Cap.prototype.init.call(this, $('#cap-bar'), 'mine-cap', undefined, 'Mine');

		$('#mine-cap').append('<div class="background"></div>');
		$('#mine-cap').append('<div class="icon"></div>');

		ige.emit('cosmos:hud.bottomToolbar.capBar.subcomponent.loaded', this);

		this.cooldownActivated = true;
	},

	startCooldown: function(weapon) {
		if (this.cooldownActivated) {
			return;
		}

		$('#mine-cap .background').stop();

		$('#mine-cap .background').width('0%');

		$('#mine-cap .background').animate({width: "100%"}, weapon.damageSource.cooldown);

		this.cooldownActivated = true;
	}
});

MineCap.COOLDOWN_INTERVAL_MS = 40;

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = MineCap;
};var ConstructCap = Cap.extend({
	classId: 'ConstructCap',
	componentId: 'constructCap',

	init: function() {
		Cap.prototype.init.call(this, $('#cap-bar'), 'construct-cap', undefined, 'Construct');

		ige.emit('cosmos:hud.bottomToolbar.capBar.subcomponent.loaded', this);
	},

	select: function() {
		Cap.prototype.select.call(this);

		ige.hud.leftToolbar.windows.cargo.open();
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
	module.exports = ConstructCap;
}
;var FixtureDebuggingBlock = IgeEntity.extend({
	classId: 'FixtureDebuggingBlock',

	init: function(data) {
		var self = this;
		IgeEntity.prototype.init.call(this);

		if (data !== undefined) {
			this.width(data.width);
			this.height(data.height);
			this.depth(data.depth);
		}

		this.addComponent(PixiRenderableComponent, {
			createDisplayObject: function() {
				var graphic = new PIXI.Graphics();
				graphic.beginFill(0x000000, 0.5);
				graphic.lineStyle(Block.BORDER_WIDTH, 0x640000, self.borderAlpha);
				graphic.drawRect(
						Block.BORDER_WIDTH / 2,
						Block.BORDER_WIDTH / 2,
						self.width() - Block.BORDER_WIDTH,
						self.height() - Block.BORDER_WIDTH
				);
				graphic.endFill();

				return graphic;
			},
			anchor: new IgePoint2d(-self.width() / 2, -self.height() / 2)
		});

		if (!ige.isServer) {
			this.texture(ige.client.textures.fixtureDebuggingTexture);
		}
	},

	streamCreateData: function() {
		return {
			width: this.width(),
			height: this.height(),
			depth: this.depth()
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = FixtureDebuggingBlock; }
;var BlockGridPadding = {
	// Extracts the minimum regular grid from a padded regular grid
	// Regular meaning all rows have same number of columns
	extractMinimumGrid: function(grid) {
		// Find the boundaries of the minimum grid within the padded grid
		if (grid[0] !== undefined) {
			var startCol = grid[0].length;
		} else {
			var startCol = 0;
		}
		
		var endCol = 0;
		var startRow = grid.length;
		var endRow = 0;

		var gridHasBlocks = false;
		for (var row = 0; row < grid.length; row++) {
			for (var col = 0; col < grid[row].length; col++) {
				if (grid[row][col] !== undefined) {
					gridHasBlocks = true;
					if (col < startCol)
						startCol = col;
					if (col > endCol)
						endCol = col;
					if (row < startRow)
						startRow = row;
					if (row > endRow)
						endRow = row;
				}
			}
		}

		// Make a new grid with the correct minimum boundaries
		var minGridRows = gridHasBlocks ? endRow - startRow + 1 : 0;
		var minGridCols = gridHasBlocks ? endCol - startCol + 1 : 0;
		var minGrid = new Array(minGridRows);
		for (var i = 0; i < minGridRows; i++) {
			minGrid[i] = new Array(minGridCols);
		}

		// Copy over to new minimum grid
		for (var i = 0; i < minGridRows; i++) {
			for (var j = 0; j < minGridCols; j++) {
				minGrid[i][j] = grid[i + startRow][j + startCol];
			}
		}

		return minGrid;

	}
};

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = BlockGridPadding;
}
;var MathUtils = {};

MathUtils.roundToDecimals = function(value, decimals) {
	return Number(Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals));
};

MathUtils.round = function(value) {
	return MathUtils.roundToDecimals(value, MathUtils.EPSILON);
};


MathUtils.worldVectorToLocalVector = function(vector, entity) {
	var translatedVector = vector.minusPoint(new IgePoint2d(entity.translate().x(), entity.translate().y()));
	return translatedVector.rotate(entity.rotate().z());
};

MathUtils.localVectorToWorldVector = function(vector, entity) {
	var rotatedVector = vector.rotate(-entity.rotate().z());
	return rotatedVector.addPoint(new IgePoint2d(entity.translate().x(), entity.translate().y()));
};

MathUtils.rotate = function(vector, theta) {
	return new IgePoint2d(
		vector.x * Math.cos(theta) - vector.y * Math.sin(theta),
		vector.x * Math.sin(theta) + vector.y * Math.cos(theta)
	);
};

MathUtils.magnitude = function(vector) {
	return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
};

MathUtils.chooseRandomlyFromArray = function(array) {
	return array[Math.floor(Math.random() * array.length)];
}

// By default, round to 10 decimal places.
// Maybe this should go in the constants file
MathUtils.EPSILON = 10;

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = MathUtils;
}
;/**
 * The NetworkUtils class provides static utility functions for creating the kinds of objects that will be packaged
 * to send across the network from server to client or client to server.
 * @class
 * @namespace
 */
var NetworkUtils = {

};

/**
 * Converts a {@link Block} into a reference to a {@link BlockGrid}, a row, and a column. For use in specifying an
 * effected block when sending messages across the network.
 * @param block {Block} The {@link Block} to turn into a network object.
 * @returns {*} undefined if the provided {@link Block} is undefined, an object of the structure
 * {blockGridId: {number}, row: {number}, col: {number}} otherwise.
 * @memberof NetworkUtils
 * @static
 */
NetworkUtils.block = function(block) {
	if (block === undefined || block.gridData === undefined || block.gridData.loc === undefined) {
		return undefined;
	}

	return {
		blockGridId: block.blockGrid() !== undefined ? block.blockGrid().id() : undefined,
		row: block.gridData.loc.y,
		col: block.gridData.loc.x
	};
};

/**
 * Creates an effect object, which maintains information about what type of effect this is, what the source
 * {@link Block} of the effect is, and, optionally, the target of the effect. Target is only used for certain effects
 * like the laser effect which need to latch onto a second {@link Block}.
 * @param effectType {string} The type of this effect.
 * @param block {Block} The {@link Block} that is generating or associated with this effect.
 * @param targetBlock {Block} Optional argument. Specifies the target {@link Block} for effects like the laser
 * effect, which needs a second {@link Block} to latch onto.
 * @returns {{type: *, sourceBlock: *, targetBlock: *}} An effect object, which stores the effect type and two
 * network-converted {@link Block} objects as returned from {@link NetworkUtils#block}. The source block is the block
 * that the effect is being added to. The target block is a secondary block that is required for certain effects like
 * the laser effect.
 */
NetworkUtils.effect = function(effectType, block, targetBlock) {
	return {
		type: effectType,
		sourceBlock: NetworkUtils.block(block),
		targetBlock: NetworkUtils.block(targetBlock)
	};
};

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = NetworkUtils;
};/**
 * Get a random number from an interval
 * @namespace
 */
var RandomInterval = {
	/**
	 * Get a random number from the interval [min, max]
	 * @param min {Integer}
	 * @param max {Integer}
	 * @returns {Integer}
	 * @memberof RandomInterval
	 * http://stackoverflow.com/questions/4959975/generate-random-value-between-two-numbers-in-javascript
	 */
	randomIntFromInterval: function(min, max) {
		return Math.floor(Math.random() * (max - min + 1 ) + min);
	}
};

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = RandomInterval;
}
;/**
 * Remove an item or group of items from an array
 * @example
 *      // Remove the second item from the array
 *       array.remove(1);
 *      // Remove the second-to-last item from the array
 *      array.remove(-2);
 *      // Remove the second and third items from the array
 *      array.remove(1,2);
 *      // Remove the last and second-to-last items from the array
 *      array.remove(-2,-1);
 * @param from {Integer} From index, inclusive
 * @param to {Integer} To index, inclusive
 * @returns {Integer} The new array length
 * @memberof Array
 * Referenced from http://ejohn.org/blog/javascript-array-remove/
 */
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};

/* Our custom array functions */

/**
 * Gets an item from a 2d array. Returns undefined if out of bounds.
 * @param row {Integer}
 * @param col {Integer}
 * @returns {*} Item at row, col
 * @memberof Array
 */
Array.prototype.get2D = function(row, col) {
	if (row < 0 || col < 0) {
		return undefined;
	}
	if (row >= this.length) {
		return undefined;
	}
	if (col >= this[row].length) {
		return undefined;
	}

	return this[row][col];
};

/**
 * Safely checks to see if a (row, col) is in bounds.
 * @param row {Integer}
 * @param col {Integer}
 * @returns {Boolean} True if (row, col) is in bounds
 * @memberof Array
 */
Array.prototype.is2DInBounds = function (row, col) {
	if ((row < 0) || (col < 0)) {
		return false;
	}

	var maxRowLength = this.length;
	if (row < maxRowLength) {
		if (this[row] === undefined) {
			return false;
		}
		var maxColLength = this[row].length;
		if (col < maxColLength) {
			return true;
		}
	}
	return false;
};

/**
 * Creates a new 2D array with specified dimensions and fills it
 *  with data. If data is undefined, fill with undefined.
 * @param numRows {Integer} Number of rows in new 2D array
 * @param numCols {Integer} Number of cols in new 2D array
 * @param data {*=} Optional array fill parameter
 * @returns {Array} Newly created 2D array
 * @memberof Array
 */

Array.prototype.new2DArray = function(numCols, numRows, data) {
	var grid = [];

	for (var x = 0; x < numCols; x++) {
		var gridCol = [];
		for (var y = 0; y < numRows; y++) {
			if (data !== undefined) {
				gridCol.push(data);
			}
		}
		grid.push(gridCol);
	}

	return grid;
};

/**
 * Gets the maximum row length because javascript 2D arrays are jagged
 * @returns {Integer} Maximum row length of a 2D array
 * @memberof Array
 */
Array.prototype.get2DMaxRowLength = function() {
	var maxRowLength = 0;
	for (var row = 0; row < this.length; row++) {
		if (this[row].length > maxRowLength) {
			maxRowLength = this[row].length;
		}
	}

	return maxRowLength;
};
;var MathUtils = {};

MathUtils.roundToDecimals = function(value, decimals) {
	return Number(Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals));
};

MathUtils.round = function(value) {
	return MathUtils.roundToDecimals(value, MathUtils.EPSILON);
};


MathUtils.worldVectorToLocalVector = function(vector, entity) {
	var translatedVector = vector.minusPoint(new IgePoint2d(entity.translate().x(), entity.translate().y()));
	return translatedVector.rotate(entity.rotate().z());
};

MathUtils.localVectorToWorldVector = function(vector, entity) {
	var rotatedVector = vector.rotate(-entity.rotate().z());
	return rotatedVector.addPoint(new IgePoint2d(entity.translate().x(), entity.translate().y()));
};

MathUtils.rotate = function(vector, theta) {
	return new IgePoint2d(
		vector.x * Math.cos(theta) - vector.y * Math.sin(theta),
		vector.x * Math.sin(theta) + vector.y * Math.cos(theta)
	);
};

MathUtils.magnitude = function(vector) {
	return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
};

MathUtils.chooseRandomlyFromArray = function(array) {
	return array[Math.floor(Math.random() * array.length)];
}

// By default, round to 10 decimal places.
// Maybe this should go in the constants file
MathUtils.EPSILON = 10;

if (typeof (module) !== 'undefined' && typeof (module.exports) !== 'undefined') {
	module.exports = MathUtils;
}
;/**
 * ClientNetworkEvents stores functions that are called as a result of network events.
 * When adding a new event to this class, make sure to link it with the appropriate network event in client.js. For example,
 * ige.network.define('playerEntity', self._onPlayerEntity);
 * links the network event 'playerEntity' to the function _onPlayerEntity.
 * If you don't do this, your function won't ever be called.
 */
var ClientNetworkEvents = {
	/**
	 * Is called when a network packet with the "playerEntity" command
	 * is received by the client from the server. This is the server telling
	 * us which entity is our player entity so that we can track it with
	 * the main camera!
	 * @param data The data object that contains any data sent from the server.
	 * @private
	 */
	_onPlayerEntity: function(data) {
		ige.client.player = new Player();
		ige.client.player.id(data.playerId);
		ige.client.player.username(data.username);
		ige.client.player.loggedIn(data.loggedIn);
		ige.client.player.mount(ige.$("spaceGameScene"));

		ige.client.player.hasGuestUsername = data.hasGuestUsername;

		// We can't afford to create Mixpanel profiles for guest users.
		if (!data.hasGuestUsername) {
			ige.client.metrics.identify(data.username, {
				loggedIn: data.loggedIn,
				hasGuestUsername: data.hasGuestUsername,
				username: data.username
			});
		}

		// Set the time stream UI entity to monitor our player entity
		// time stream data
		//ige.client.tsVis.monitor(ige.client.player);

		if (ige.client.currentShip) {
			ige.client.player.currentShip(ige.client.currentShip);
			ige.emit('cosmos:client.player.currentShip.ready');
		}

		ige.client.metrics.track('cosmos:player.connect', {'playerId': data.playerId});

		// If this player is logged in and has a guest username, prompt for a real
		// username.
		if (ige.client.player.loggedIn() && ige.client.player.hasGuestUsername) {
			ige.client.promptForUsername();
		}
		else {
			ige.emit('cosmos:client.player.username.set', ige.client.player.username());
		}

		ige.emit('cosmos:client.player.streamed');

		// Set the time stream UI entity to monitor our player entity
		// time stream data
		//ige.client.tsVis.monitor(ige.$(data));
	},

	_onPlayerConnected: function(data) {
		if ((ige.client.player && ige.client.player.id() === data.playerId) || ige.$(data.playerId)) {
			return;
		}

		var player = new Player().id(data.playerId)
			.username(data.username)
			.loggedIn(data.loggedIn)
			.mount(ige.$("spaceGameScene"));

		player.hasGuestUsername = data.hasGuestUsername;

		if (ige.$(data.shipId)) {
			player.currentShip(ige.$(data.shipId));
		}
	},

	_onPlayerDisconnected: function(data) {
		var player = ige.$(data);
		if (player) {
			player.destroy();
		}
	},

	/*
	This is how the server assembles the data to send us:
	var sendData = {
		shipId: player.currentShip().id()
	}
	*/
	// TODO: Refactor this code to use the paradigm where the ship sends the playerId in streamCreateData and where
	// messages that create players send down the shipId. This way, it's pretty well-defined that either we're ready
	// when the player is received or when the ship is received and every player and every ship can be paired to the
	// appropriate extant entity.
	_onShipEntity: function(data) {
		if(ige.client.player && ige.$(data.shipId)) {

			ige.client.player.currentShip(ige.$(data.shipId));
		} else {
			//adding ship to player later
			if (!ige.client.player) {
				//save the ship for when the player does arrive
				ige.client.currentShip = ige.$(data.shipId);
			}

			if (!ige.$(data.shipId)) {
				self._eventListener = ige.network.stream.on('entityCreated', function (entity) {
					if (entity.id() === data.shipId) {

						if (ige.client.player) {
							ige.client.player.currentShip(entity);
							ige.emit('cosmos:client.player.currentShip.ready');
						}

						// Set the time stream UI entity to monitor our player entity
						// time stream data
						//ige.client.tsVis.monitor(ige.$(data));

						// Turn off the listener for this event now that we
						// have found and started tracking our player entity
						ige.network.stream.off('entityCreated', self._eventListener, function (result) {
							if (!result) {
								this.log('Could not disable event listener!', 'warning');
							}
						});

						ige.emit('cosmos:client.ship.streamed');
					}
				});
			}
		}
	},

	_onAddEffect: function(effect) {
		var blockGrid = ige.$(effect.sourceBlock.blockGridId);
		if (blockGrid) {
			blockGrid.addEffect(effect);
		}
	},

	_onRemoveEffect: function(effect) {
		var blockGrid = ige.$(effect.sourceBlock.blockGridId);
		if (blockGrid) {
			blockGrid.removeEffect(effect);
		}
	},

	_onConfirm: function(confirmData) {
		ige.client.metrics.track(confirmData.event, confirmData.data);
	},

	_onShipDeath: function(data) {
		ige.client.metrics.track('cosmos:ship.death');
		var message = "Your bridge has been destroyed. You can no longer pilot this ship. Would you like a new ship?";

		alertify.alert(message, function (e) {
			if (e) {
				ige.network.send('new ship');
			}
		});
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = ClientNetworkEvents; }
;/**
 * This file contains functions important for game initialization. A lot of game initialization code is shared between
 * the client and the server, so we've moved that code here to avoid code duplication.
 * @type {{init: init, initScenes: initScenes, initSpaceScene: initSpaceScene, sharedInit: sharedInit, clientInit: clientInit, initPlayerControls: initPlayerControls, initTimeStream: initTimeStream, serverInit: serverInit}}
 */
var GameInit = {
	/**
	 * This is the function to call to initialize the game. It must be called on both the client and the server after
	 * the networking has been setup.
	 * @param game either ige.client or ige.server
	 */
	init: function(game) {
		// Disable debug features for more performance
		ige.debugTiming(false);
		ige.debugEnabled(true);

		this.initScenes(game);

		// Create global cosmos namespace. Cosmos-specific state should go here, not in the IGE namespace.
		cosmos = {};
		this.initBlocks();

		if (ige.isServer) {
			this.initEnvironment();
			this.initPhysics();
			this.initServerEvents();
		} else {
			this.initPlayerState();
			this.initPlayerControls();
			this.initDeconstructionEntity();
			//this.initTimeStream(game);
		}
	},

	/**
	 * Load instances of blocks into the global space so that they are categorized and easily accessible.
	 *
	 * This function loops through the variables in the global context to find the prototypes of the {@link Block}
	 * classes. It then instantiates one of each {@link Block} and keeps it around in the global cosmos namespace so
	 * that we don't have to create random blocks every time we need a block to do something for us.
	 */
	initBlocks: function() {
		var globalContext = (ige.isServer) ? global : window;
		cosmos.blocks = {};
		cosmos.blocks.constructors = {};
		cosmos.blocks.instances = {};
		for (var key in globalContext) {
			if (globalContext.hasOwnProperty(key)
				&& globalContext[key]
				&& globalContext[key].prototype
				&& globalContext[key].prototype instanceof Block
				&& globalContext[key].prototype.classId() !== "Element"
				&& globalContext[key].prototype.classId() !== "Laser")
			{
				cosmos.blocks.constructors[key] = globalContext[key];
				var block = new globalContext[key]();
				cosmos.blocks.instances[key] = block;
			}
		}
	},

	/**
	 * Initializes the scene graph for the game. All scenes should be initialized here and both the server and the
	 * client will run this code to construct the same or similar scene graphs. If either the client or the server alone
	 * need to add some element to the scene graph, use ige.isServer.
	 * @param game either ige.client or ige.server
	 */
	initScenes: function(game) {
		// Load the base scene data
		game.mainScene = new IgeScene2d()
			.id('mainScene');

		// Create the main viewport and set the scene it will "look" at as the new scene1 we just created above.
		// Surprisingly, this must exist on both the client and the server, or a blank screen will be displayed.
		game.mainViewport = new IgeViewport()
			.id('mainViewport')
			.autoSize(true)
			.minimumVisibleArea(
				Constants.visibleArea.MAXIMUM_WIDTH,
				Constants.visibleArea.MAXIMUM_HEIGHT)
			.scene(game.mainScene)
			//Note: drawBounds runs on the server for and will slow performance
			.drawBounds(false) //draws the axis aligned bounding boxes. Set to true for debugging.
			.mount(ige);

		// Initialize client-specific overlay scenes
		if (!ige.isServer) {
			// Initialize UI scenes
			this.initUIScenes();

			// Initialize debugging info
			this.initDebugDisplay();
		}

		// Initialize in-game scenes
		this.initInGameScenes(game);
	},

	/**
	 * Initializes the space scene. The space scene is the initial scene of the game, where the player is in space.
	 * It contains three layers for the background, the actual game content, and the UI.
	 * In general, the server needs to know about scenes so that it can attach entities to those scenes and stream them
	 * to the clients. Scenes that are not associated with streamed entities can usually be loaded on just the client.
	 * @param game either ige.client or ige.server
	 */
	initInGameScenes: function(game) {
		game.spaceScene = new IgeScene2d()
			.id('spaceScene')
			.mount(game.mainScene);

		game.spaceGameScene = new IgeScene2d()
			.id('spaceGameScene')
			.layer(game.LAYER_WORLD)
			.mount(game.spaceScene);

		if (!ige.isServer) {
			// Use entity manager to prevent off-screen entities from being rendered
			game.spaceGameScene.addComponent(IgeEntityManager);
			// Non UI elements don't need to respond to the screen resize event. This
			// provides a performance boost because every time something is mounted
			// to an entity, (eg particles mounted to the spaceGameScene) a resize
			// event happens.
			game.spaceGameScene.resizeSceneChildren(false);

			game.effectsScene = new IgeScene2d()
				.id('effectsScene')
				.layer(game.LAYER_WORLD_OVERLAY)
				.mount(game.spaceScene);

			// This scene's purpose is to catch all clicks on the background
			game.clickScene = new ClickScene()
				.layer(game.LAYER_CLICK_SCENE)
				.mount(game.spaceScene);

			// For now, the server does not need to know about the background scene.
			// The server does not need to load the UI.
			this.initBackgroundScene();
		}
	},

	/**
	 * Initializes the UI scene layer on the client.
	 */
	initUIScenes: function() {
		var client = ige.client;
		client.uiModalScene = new IgeScene2d()
			.id('uiModalScene')
			.layer(client.LAYER_MODAL)
			.ignoreCamera(true)
			.mount(client.mainScene);
	},

	/**
	 * Initializes the environmental background layers on the client.
	 */
	initBackgroundScene: function() {
		var client = ige.client;
		client.spaceBackgroundScene = new IgeScene2d()
				.id('spaceBackgroundScene')
				.layer(client.LAYER_BACKGROUND)
				.mount(client.spaceScene);


		// Instantiate the background tiles
		for (var gridX = 0; gridX < Constants.NUM_BACKGROUND_SQUARES.X; gridX++) {
			for (var gridY = 0; gridY < Constants.NUM_BACKGROUND_SQUARES.Y; gridY++) {
				new Background({textureName: 'background' + gridX + "-" + gridY})
					.id('background' + gridX + "-" + gridY)
					.depth(0)
					.parallaxLag(2)
					.mount(client.spaceBackgroundScene)
					.translateTo(
						(Constants.GRID_SQUARE_SIZE.X - Constants.GRID_SQUARE_OVERLAP)*gridX + Constants.BACKGROUND_OFFSET.X,
						(Constants.GRID_SQUARE_SIZE.Y - Constants.GRID_SQUARE_OVERLAP)*gridY + Constants.BACKGROUND_OFFSET.Y,
						0);
			}
		}

		//Instantiate the background overlay
		for (var gridX = -Constants.NUM_BACKGROUND_OVERLAY_SQUARES.X/2; gridX < Constants.NUM_BACKGROUND_OVERLAY_SQUARES.X/2; gridX++) {
			for (var gridY = -Constants.NUM_BACKGROUND_OVERLAY_SQUARES.Y/2; gridY < Constants.NUM_BACKGROUND_OVERLAY_SQUARES.Y/2; gridY++) {
				new Background({textureName: 'backgroundOverlay'})
					.id('backgroundOverlay' + gridX + "-" + gridY)
					.depth(1)
					.parallaxLag(4)
					.mount(client.spaceBackgroundScene)
					.translateTo(
						Constants.GRID_SQUARE_SIZE.X * gridX,
						Constants.GRID_SQUARE_SIZE.Y * gridY,
						0);
			}
		}

		//Instantiate the second background overlay
		for (var gridX = -Constants.NUM_BACKGROUND_OVERLAY_SQUARES.X/2; gridX < Constants.NUM_BACKGROUND_OVERLAY_SQUARES.X/2; gridX++) {
			for (var gridY = -Constants.NUM_BACKGROUND_OVERLAY_SQUARES.Y/2; gridY < Constants.NUM_BACKGROUND_OVERLAY_SQUARES.Y/2; gridY++) {
				var x = Constants.GRID_SQUARE_SIZE.X * gridX;
				var y = Constants.GRID_SQUARE_SIZE.Y * gridY;

				new Background({textureName: 'backgroundOverlay'})
					.id('backgroundOverlayTheSecond' + gridX + "-" + gridY)
					.depth(1)
					.parallaxLag(5)
					.mount(client.spaceBackgroundScene)
					.translateTo(
						x * Math.cos(Constants.SECOND_OVERLAY_ROTATION) - y * Math.sin(Constants.SECOND_OVERLAY_ROTATION),
						x * Math.sin(Constants.SECOND_OVERLAY_ROTATION) + y * Math.cos(Constants.SECOND_OVERLAY_ROTATION),
						0)
					.rotate().z(Constants.SECOND_OVERLAY_ROTATION);
			}
		}
		/*
		var NUM_STAR_FIELDS = 5;
		for (var starfieldNumber = 0; starfieldNumber < NUM_STAR_FIELDS; starfieldNumber++) {
			this.moveRandomly(
				new StarfieldBackground()
					.id('starfield_background' + starfieldNumber)
					.depth(2)
					.parallaxLag(6 + starfieldNumber)
					.mount(client.spaceBackgroundScene)
			);
		}
		*/
	},

	initDebugDisplay: function() {
	},

	/**
	 * Initializes the in-game environment on the server.
	 * TODO: Creating the environment on the client may speed up init time
	 */
	initEnvironment: function() {
		var server = ige.server;

		var NUM_SMALL_ASTEROIDS = 20;
		for (var asteroidNumber = 0; asteroidNumber < NUM_SMALL_ASTEROIDS; asteroidNumber++) {
			this.spawnStructure([0, 0, 0, 0, 1, 1, 1, 1], BlockStructureGenerator.elementDistributions.randomDistribution());// Note that 8000 here doens't do anything. To modify the sizes of the asteroids, go to the asteroid generator.
		}

		var NUM_NORMAL_ASTEROIDS = 10;
		for (var asteroidNumber = 0; asteroidNumber < NUM_NORMAL_ASTEROIDS; asteroidNumber++) {
			this.spawnStructure([0, 0, 0, 1, 1, 1, 1, 1], BlockStructureGenerator.elementDistributions.randomDistribution());// Note that 8000 here doens't do anything. To modify the sizes of the asteroids, go to the asteroid generator.
		}

		var NUM_HUGE_ASTEROIDS = 5;
		for (var asteroidNumber = 0; asteroidNumber < NUM_HUGE_ASTEROIDS; asteroidNumber++) {
			this.spawnStructure([0, 0, 1, 1, 1, 1, 1, 1], BlockStructureGenerator.elementDistributions.randomDistribution());// Note that 8000 here doens't do anything. To modify the sizes of the asteroids, go to the asteroid generator.
		}
		// TODO: The procedural generation algorithm is causing strange problems with the new BlockGrid system. Leave
		// this stuff commented out until it is figured out.
		/*
		var NUM_DERELICT_SPACESHIPS = 10;
		for (var asteroidNumber = 0; asteroidNumber < NUM_DERELICT_SPACESHIPS; asteroidNumber++) {
			this.spawnStructure(60, BlockStructureGenerator.partDistributions.randomDistribution(), true);
		}
		*/
	},

	spawnStructure: function(numLayers, blockDistribution, symmetric) {
		// Create a structure within a 10,000 x 10,000 box centered at (0,0)
		var transactionalOpts = {
			viableAabbWidth: 10000,
			viableAabbHeight: 10000,
			viableX: 0,
			viableY: 0,
			numRetries: 10,
			callback: handleTransactionResult
		}

		var structure = BlockStructureGenerator
			.genProceduralAsteroid(numLayers, blockDistribution, symmetric,
				transactionalOpts);

		// TODO: @Eric Race condition where structure may not be uninitialized
		// before this callback is called.
		function handleTransactionResult(success) {
			if (success) {
				structure.streamMode(1);
				structure.mount(ige.server.spaceGameScene);
			}
			else {
				structure.destroy();
			}
		}
	},

	/**
	 * Initializes the physics on the server.
	 * TODO: Running physics on the client may improve performance.
	 */
	initPhysics: function() {
		// Set up custom contacts
		var contactIdentifiers = {
			'shipDropBegin': 1,
			'shipDropEnd': 2,
			'shipDropPreSolve': 3,
			'dropPreSolve': 4
		}

		var beginContacts = [{
			a_fixture_category: Ship.ATTRACTOR_BOX2D_CATEGORY_BITS,
			b_fixture_category: Drop.BOX2D_CATEGORY_BITS,
			disable_contact: true,
			identifier: contactIdentifiers['shipDropBegin']
		}];

		var endContacts = [{
			a_fixture_category: Ship.ATTRACTOR_BOX2D_CATEGORY_BITS,
			b_fixture_category: Drop.BOX2D_CATEGORY_BITS,
			disable_contact:false,
			identifier: contactIdentifiers['shipDropEnd']
		}];

		var preSolveContacts = [{
			a_fixture_category: Ship.BOX2D_CATEGORY_BITS,
			b_fixture_category: Drop.BOX2D_CATEGORY_BITS,
			disable_contact: true,
			identifier: contactIdentifiers['shipDropPreSolve']
		}];

		ige.physicsSystem.newCustomContacts({contacts: beginContacts, contactType:
			'BEGIN_CONTACT'});
		ige.physicsSystem.newCustomContacts({contacts: endContacts, contactType:
			'END_CONTACT'});
		ige.physicsSystem.newCustomContacts({contacts: preSolveContacts, contactType:
			'PRE_SOLVE'});

		// Set up collision callbacks
		ige.physicsSystem.registerCollisionCallbacks({
			beginContact: function(entity1, entity2, identifier) {
				switch (identifier) {
					case contactIdentifiers.shipDropBegin:
						var results = entityByCategory(entity1, entity2, Drop.BOX2D_CATEGORY_BITS,
							Ship.BOX2D_CATEGORY_BITS);
						var drop = results.category1Entity;
						var ship = results.category2Entity;

						if (drop.getAttractedTo() === undefined && drop.isOwner(ship)) {
							drop.setAttractedTo(ship);
						}
						break;
					default:
						this.log('GameInit#initPhysics: beginContact bad identifier', 'warning');
						break;
				}
			},

			endContact: function(entity1, entity2, identifier) {
				switch (identifier) {
					case contactIdentifiers.shipDropEnd:
						var results = entityByCategory(entity1, entity2, Drop.BOX2D_CATEGORY_BITS,
							Ship.BOX2D_CATEGORY_BITS);
						var drop = results.category1Entity;
						var ship = results.category2Entity;

						if (drop.isOwner(ship)) {
							drop.setAttractedTo(undefined);
						}
						break;
					default:
						this.log('GameInit#initPhysics: endContact bad identifier', 'warning');
						break;
				}
			},

			preSolve: function(entity1, entity2, identifier) {
				switch (identifier) {
					case contactIdentifiers.shipDropPreSolve:
						var results = entityByCategory(entity1, entity2, Drop.BOX2D_CATEGORY_BITS,
							Ship.BOX2D_CATEGORY_BITS);
						var drop = results.category1Entity;
						var ship = results.category2Entity;

						// Ignore multiple collision points
						if (drop === undefined || !drop.alive()) {
							return;
						}
						var block = drop.block();

						ship.cargo.add(block.classId());
						drop.destroy();
						break;
					case contactIdentifiers.dropPreSolve:
						// TODO: Make drops not collide (this needs physics server support)
						break;
					default:
						this.log('GameInit#initPhysics: preSolve bad identifier', 'warning');
						break;
				}
			},

			postSolve: function(entity1, entity2, identifier) {
			}
		});
		// Gets entity by category. Assumes each entity maps to either category1
		// or the other category.
		function entityByCategory(entity1, entity2, category1, category2) {
			var category1Entity;
			var category2Entity;

			if ((entity1.category() === category1) &&
				(entity2.category() === category2)) {
				category1Entity = entity1;
				category2Entity = entity2;
			}
			else if ((entity1.category() === category2) &&
				(entity2.category() === category1)) {
				category1Entity = entity2;
				category2Entity = entity1;
			}
			else {
				this.log('GameInit#entityByCategory: Entities do not match categories!', 'error');
			}

			return {
				category1Entity: category1Entity,
				category2Entity: category2Entity,
			};
		}
	},

	initServerEvents: function() {

	},

	initClientEvents: function() {

	},

	/**
	 * Sets up the player controls.
	 * @param client the client (ige.client)
	 */
	initPlayerControls: function() {
		// Define our player controls
		ige.input.mapAction('key.left', ige.input.key.left);
		ige.input.mapAction('key.right', ige.input.key.right);
		ige.input.mapAction('key.up', ige.input.key.up);
		ige.input.mapAction('key.down', ige.input.key.down);

		// Alternate WASD controls
		ige.input.mapAction('key.left_A', ige.input.key.a);
		ige.input.mapAction('key.right_D', ige.input.key.d);
		ige.input.mapAction('key.up_W', ige.input.key.w);
		ige.input.mapAction('key.down_S', ige.input.key.s);

		ige.input.mapAction('mouse.button1', ige.input.mouse.button1);
		ige.input.mapAction('mouse.button2', ige.input.mouse.button2);
		ige.input.mapAction('mouse.button3', ige.input.mouse.button3);
	},

	initPlayerState: function() {
		ige.client.state = new ClientState();
	},

	initDeconstructionEntity: function() {
		new DeconstructionIndicator()
			.id("deconstructionEntity")
			.depth(1);
	},

	/**
	 * Initializes the time stream UI element for debugging.
	 * @param client the client (ige.client)
	 */
	initTimeStream: function(client) {
		// Create an IgeUiTimeStream entity that will allow us to "visualise" the
		// timestream data being interpolated by the player entity
		client.tsVis = new IgeUiTimeStream()
			.height(140)
			.width(400)
			.top(0)
			.center(0)
			.mount(client.uiModalScene);

		client.custom1 = {
			name: 'Delta',
			value: 0
		};

		client.custom2 = {
			name: 'Data Delta',
			value: 0
		};

		client.custom3 = {
			name: 'Offset Delta',
			value: 0
		};

		client.custom4 = {
			name: 'Interpolate Time',
			value: 0
		};

		ige.watchStart(client.custom1);
		ige.watchStart(client.custom2);
		ige.watchStart(client.custom3);
		ige.watchStart(client.custom4);
	},

};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = GameInit; }
;var Client = IgeClass.extend({
	classId: 'Client',

	init: function () {
		window.addEventListener("keydown", function(e) {
			// space and arrow keys
			if([37, 38, 39, 40].indexOf(e.keyCode) > -1) {
				e.preventDefault();
			}
		}, false);

		var self = this;
		window.onerror = function(message, url, lineNumber) {
			self.onLoadError(message);
			return false;
		};

		ige.setFps(Constants.fps.CLIENT_FPS);

		// Load our textures
		var self = this;

		self.LAYER_BACKGROUND = 10;
		self.LAYER_CLICK_SCENE = 15;
		self.LAYER_WORLD = 50;
		self.LAYER_WORLD_OVERLAY = 51;
		self.LAYER_HUD = 90;
		self.LAYER_MODAL = 100;

		// Enable IGE on screen editor
		//ige.addComponent(IgeEditorComponent);

		// Enable networking
		ige.addComponent(IgeNetIoComponent);

		// Implement our game methods
		this.implement(ClientNetworkEvents);

		// IGE rendering system is left attached in order to support the textures system which, for now, is still used
		// for displaying blocks in canvases in the HUD.
		ige.addSystem(IgeRenderingSystem, {autoSize: true});

		ige.addSystem(PixiRenderingSystem, {autoSize: true});

		// Load textures
		var textures = {};
		textures.background_starfield = 'assets/backgrounds/starfield.png'

		for (var gridX = 0; gridX < Constants.NUM_BACKGROUND_SQUARES.X; gridX++) {
			for (var gridY = 0; gridY < Constants.NUM_BACKGROUND_SQUARES.Y; gridY++) {
				textures['background' + gridX + '-' + gridY] = 'assets/backgrounds/background' + gridX + '-' + gridY + '.jpg';
			}
		}
		textures['backgroundOverlay'] = 'assets/backgrounds/backgroundOverlay.png';

		ige.rendering.loadTextures(textures);
		ige.rendering.loadSpriteSheets(['assets/sprites/sprites.json']);
		ige.rendering.start();

		ige.rendering.on('texturesLoaded', function() {

			ige.rendering.log('Finished Pixi loading textures.');

			// Load the textures we want to use
			var textures = {
				block: new IgeTexture('assets/BlockTexture.js'),
				glow: new IgeTexture('assets/GlowEffectTexture.js'),
				background_helix_nebula: new IgeTexture(
					'assets/backgrounds/helix_nebula.jpg'),
				background_starfield: new IgeTexture(
					'assets/backgrounds/starfield.png'),
				//rectangleTexture: new IgeTexture(
				//	'assets/effects/particles/Rectangle.js'),
				healthBar: new IgeTexture('assets/HealthBarTexture.js'),

				// Cap textures
				mineCap_color: new IgeTexture('assets/ui/mine/mine-color.png'),
				mineCap_white: new IgeTexture('assets/ui/mine/mine-white.png'),
				constructCap_color: new IgeTexture('assets/ui/construct/construct-color.png'),
				constructCap_white: new IgeTexture('assets/ui/construct/construct-white.png'),
				baseCap_color: new IgeTexture('assets/ui/base/base-color.png'),
				baseCap_white: new IgeTexture('assets/ui/base/base-white.png'),
			}

			for (var gridX = 0; gridX < Constants.NUM_BACKGROUND_SQUARES.X; gridX++) {
				for (var gridY = 0; gridY < Constants.NUM_BACKGROUND_SQUARES.Y; gridY++) {
					textures['background' + gridX + '-' + gridY] = new IgeTexture('assets/backgrounds/background' + gridX + '-' + gridY + '.jpg');
				}
			}
			textures['backgroundOverlay'] = new IgeTexture('assets/backgrounds/backgroundOverlay.png');

			self.textures = textures;

			ige.on('texturesLoaded', function () {
				// Ask the engine to start
				ige.start(function (success) {
					// Check if the engine started successfully
					if (success) {
						ige.client.metrics = new MetricsHandler();
						ige.client.startClientPerformanceMetrics();

						// Start the networking (you can do this elsewhere if it
						// makes sense to connect to the server later on rather
						// than before the scene etc are created... maybe you want
						// a splash screen or a menu first? Then connect after you've
						// got a username or something?

						// Read the game server url injected by the cosmos.jade file
						ige.network.start(window.config.gameServerUrl, function () {
							ige.client.metrics.track('cosmos:network.connect');

							// Setup the network command listeners
							ige.network.define('playerEntity', self._onPlayerEntity);
							ige.network.define('playerConnected', self._onPlayerConnected);
							ige.network.define('playerDisconnected', self._onPlayerDisconnected);
							ige.network.define('shipEntity', self._onShipEntity);

							// Called when the server wants to add an effect to a block
							ige.network.define('addEffect', self._onAddEffect);
							// Called when the server wants to remove an effect from a block
							ige.network.define('removeEffect', self._onRemoveEffect);

							ige.network.define('confirm', self._onConfirm);

							ige.network.define('cosmos:player.username.set.approve', Player.onUsernameRequestApproved);
							ige.network.define('cosmos:player.username.set.error', Player.onUsernameRequestError);

							ige.network.define('cosmos:ship.death', self._onShipDeath);

							// Setup the network stream handler
							ige.network.addComponent(IgeStreamComponent)
								.stream.renderLatency(100); // Render the simulation 100 milliseconds in the past

							// Enable notifications
							ige.addComponent(NotificationComponent);
							ige.notification.start();

							// Enable crafting system
							ige.addComponent(CraftingSystem);

							// Enable quest system
							ige.addComponent(QuestSystem);

							GameInit.init(self);

							//ige.editor.showStats();

							ige.addComponent(HUDComponent);
							// Wait until the HUD finishes loading to ask for the player.
							ige.on('cosmos:hud.loaded', function (hud) {
								ige.hud.log('HUD Loaded.');
								$('#ready').show();
								$('.igeLoading.loadingFloat.preview').hide();

								$('#ready button').click(function() {
									self.takeFullscreen();
									window.onerror = undefined;
									$('.igeLoading').hide();
									// Ask the server to create an entity for us
									ige.network.send('playerEntity', {sid: self.getSessionId()});
								});
							});
						});
					}
				});
			});
		});
	},

	onFullscreenChange: function() {
		ige.hud.hide();
		setTimeout(function() {
			ige.hud.show();
		}, 500);
	},

	onLoadError: function(message) {
		if (message === "Uncaught IGE *error* [IgeNetIoComponent] : Error with connection: Cannot establish connection, is server running?") {
			message = "Could not connect to the game server. It may be offline or down for maintenance."
		}

		$('#loading-error').show();
		$('#loading-error .message').html(message);
		$('.igeLoading.loadingFloat.preview').hide();
		ige._loadingPreText = "Error";
		$('#loadingText').html('Error');
		$('#loadingText').addClass('error');
	},


	promptForUsername: function() {
		ige.addComponent(NamePrompt);
	},

	takeFullscreen: function() {
		if ($('#fullscreen').is(':checked')
			&& (document.fullscreenEnabled
				|| document.webkitFullscreenEnabled
				|| document.mozFullScreenEnabled
				|| document.msFullscreenEnabled))
		{
			var body = document.body;
			if (body.requestFullscreen) {
				body.requestFullscreen();
			}
			else if (body.webkitRequestFullscreen) {
				body.webkitRequestFullscreen();
			}
			else if (body.mozRequestFullScreen) {
				body.mozRequestFullScreen();
			}
			else if (body.msRequestFullscreen) {
				body.msRequestFullscreen;
			}
			document.addEventListener("fullscreenchange", this.onFullscreenChange);
			document.addEventListener("webkitfullscreenchange", this.onFullscreenChange);
			document.addEventListener("mozfullscreenchange", this.onFullscreenChange);
			document.addEventListener("MSFullscreenChange", this.onFullscreenChange);
		}
		else {
			ige.hud.show();
		}
	},

	getSessionId: function() {
		var cookie = this.parseCookie();
		var sid = cookie['connect.sid'];

		if (sid === undefined) {
			return undefined;
		}
		// connect.sid comes in the form: s:<id>.<???>+<???>
		return sid.substring(sid.indexOf(':') + 1, sid.indexOf('.'));
	},

	parseCookie: function() {
		var cookieArray = document.cookie.split(';');
		var cookie = {};
		cookieArray.each(function(element) {
			var split = element.split('=');
			cookie[split[0].trim()] = decodeURIComponent(split[1]);
		});

		return cookie;
	},

	/* Send performance metrics to Google analytics */
	startClientPerformanceMetrics: function() {
		/*setInterval(function() {
			ige.client.metrics.track('cosmos:engine.performance', {'FPS': ige.fps()});
		}, 200000); */// Send every 200s//This has been removed temporarially because the low send rate makes it not very useful. TODO: At some point let's make an aggregate statistic and send that over all at once.
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Client; }
;var Game = IgeClass.extend({
	classId: 'Game',

	init: function (App, options) {
		// Create the engine
		ige = new IgeEngine();

		if (!ige.isServer) {
			ige.client = new App();
		}

		if (ige.isServer) {
			ige.server = new App(options);
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = Game; } else { var game = new Game(Client); }
;/**
 * The MetricsHandler class handles in game metrics like what UI elements
 * are being clicked and FPS.
 * Currently, this uses Segment.io.
 * @class
 * @typedef {Object} MetricsHandler
 * @namespace
 */
var MetricsHandler = IgeEventingClass.extend({
	classId: "MetricsHandler",

	validStrings: undefined,

	init: function() {
		console.info("Metrics: Initializing...");

		this.validStrings = {
			/* Tutorial Quest. Each of these metrics corresponds to completing a stage of the tutorial */
			"cosmos:quest.tutorialQuest.clicked": true, // This is fired when you click "ok", I will take the tutorial. The alternative is to cancel the tutorial.
			"cosmos:quest.tutorialQuest.skipped": true, // This is fired when you click "cancel" and decline to take the tutorial.
			"cosmos:quest.tutorialQuest.welcome.completed": true,
			"cosmos:quest.tutorialQuest.moveForward.completed": true,
			"cosmos:quest.tutorialQuest.moveBackwards.completed": true,
			"cosmos:quest.tutorialQuest.rotateLeft.completed": true,
			"cosmos:quest.tutorialQuest.rotateRight.completed": true,
			"cosmos:quest.tutorialQuest.moveAround.completed": true,
			"cosmos:quest.tutorialQuest.minimap.completed": true,
			"cosmos:quest.tutorialQuest.collect.completed": true,
			"cosmos:quest.tutorialQuest.mine.completed": true,
			"cosmos:quest.tutorialQuest.cargo.completed": true,
			"cosmos:quest.tutorialQuest.craft.completed": true,
			"cosmos:quest.tutorialQuest.construct.completed": true,
			"cosmos:quest.tutorialQuest.chat.completed": true,
			"cosmos:quest.tutorialQuest.newShip.completed": true,
			"cosmos:quest.tutorialQuest.completed": true, // This is fired when you finish the entire tutorial.

			/* player */
			"cosmos:player.connect": true, // This is fired when the game has finished loaded and _onPlayerEntity is called on the client
			"cosmos:player.attack": true,
			'cosmos:player.relocate.mouseDown': true, // This is fired whenever the player presses the relocate button in the bottom right
			'cosmos:player.newShip.mouseDown': true, // This is fired whenever the player pushed the new ship button in the bottom right

			/* engine */
			"cosmos:engine.performance": true,

			/* network */
			"cosmos:network.connect": true,

			/* construction */
			"cosmos:construct.attempt.new": false,
			"cosmos:construct.new": false,

			"cosmos:construct.attempt.existing": false,

			// This has been removed because it fired too many events.
			"cosmos:construct.existing": false,

			"cosmos:construct.attempt.deconstruct": true,
			"cosmos:construct.deconstruct": false,

			/* ship */
			"cosmos:ship.death": true,

			/* crafting */
			"cosmos:CraftingSystem.craft.success": true, // This is fired whenever a player successfully crafts something. The name of the recipe is passed to the analytics server.

			/* misc */
			// This has been removed because it fired too many events.
			"cosmos:block.mine": false,

			"cosmos:block.attack": true // Note that this includes when you mine yourself as well as when you mine other players
		}
	},

	track: function(event, data) {
		if (this.validStrings[event]) {
			analytics.track(event, data);
		}
	},

	identify: function(userId, traits) {
		analytics.identify(userId, traits);
	}
});

MetricsHandler.PLAYER_DIMENSION = 'dimension1';
;